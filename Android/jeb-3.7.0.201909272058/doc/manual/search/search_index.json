{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Getting Started \u00b6 This document is a usage manual for JEB3. The latest version of this manual can be found online on the PNF Software web site . JEB is a reverse-engineering platform to perform disassembly, decompilation, debugging, and analysis of code and document files, manually or as part of an analysis pipeline. The first part of this guide is a user manual that covers basic usage related to analyzing, decompiling and debugging applications (Android apps, as well as native binaries). It is not an exhaustive resource. We recommend visiting our blog for additional, pointed resources describing a variety of use cases. The second half is a developer portal for advanced users who will want to use the JEB API to script tasks, develop plugins, or even craft their own front-ends. Alongside these pages, the API reference documentation website will be an indispensable resource. Installation \u00b6 Software Package \u00b6 The software package is distributed as a zip archive, custom-generated for each registered user. It contains the back-end components as well as the reference front-end implementation for desktop platforms, referred to as the \"UI client\". This manual focuses mostly on using JEB through the UI client. The UI client client runs on Windows 64-bit, Linux/GTK 64-bit, and macOS 64-bit. Requirements \u00b6 Java \u00b6 JEB requires a Java Runtime Environment (JRE) or Java Development Kit (JDK) version 8 or above (8.191+). Setup \u00b6 Make sure you have a JRE or JDK installed. The java binary must be accessible from the PATH environment variable. Optionally, you may also want to set a JAVA_HOME environment variable pointing to your Java installation folder. 64-bit OS with 32-bit JRE: A common source of problems are 64-bit systems having a 32-bit JRE accessible from the PATH. You may have different versions of Java installed, but always make sure that your PATH or JAVA_HOME refers to one that matches your system specifications. Startup \u00b6 Next, execute the startup script appropriate for your environment: On Windows: execute jeb_wincon.bat On Linux: execute jeb_linux.sh . On MacOS: execute jeb_macos.sh The startup script will locate and decrypt the JEB binary file. It may prompt the user and ask for the decryption password, which can be found within your software delivery email received from PNF Software. Enter the password to allow the startup script to finish the installation process. JEB will start. Registration \u00b6 If it is the first time you are running a non-floating JEB client, you will be asked accept the end-user license agreement, and generate a license key: If your machine is connected to the Internet, the license key can be automatically generated by clicking \"Generate a Key\". If need be, you may also configure your Proxy settings. If your machine is not connected to the Internet, you will need to generate a manual key. Click \"Manual Key Generation\" and follow the instruction. You will be asked to visit the key generation portal on a separate machine (connected to the Internet), and provide your license data. The license key will be stored in the bin/jeb-client.cfg file, under the .LicenseKey key entry. A key is specific to the user-account and machine configuration on which JEB is running. Do not attempt to reuse a key on another system. Note : If you need to deprecate an older key (eg, because of a machine replacement, user departure, or else), email Licensing . First use \u00b6 Congratulation! JEB is now running. Workspace \u00b6 You should be greeted by an empty workspace, using a default three-part layout: Project explorer on the left side Logger and Console at the bottom Empty area in the center Starting an Analysis \u00b6 Let's open our first file in JEB. Go ahead and download Raasta.apk , a sample (clean) Android application that will serve as our testing ground for the next couple of chapters. Open it via the File menu. A new project will be created with a single artifact, Raasta.apk. The application is processed by various Android analysis plugins: The APK plugin takes care of unbundling the app, decoding the manifest and resources The DEX plugin performs the analysis and disassembly of the DEX bytecode file (or files) The XML parser analyzes XML resources The Certificate plugin analyzes the certificate ... and so on. Note : JEB performs recursive analysis on input artifacts and units, using the loaded parser plugins . The project explorer tree should display a Bytecode node, representing the DEX unit (more on the concept of units later). The DEX views should be opened automatically by the UI client, as they are detected as the principal views of an APK artifact. Your workspace should look like: The workspace can be customized by the user: Views can be dragged and dropped, resized, stacked and docked with other views Views can be detached and placed in separate windows - something particularly useful for multi-monitor setups. Terminology \u00b6 The Project Explorer contains three types of nodes: The top-most entity accessible within the UI client is a project Currently, the UI client can only handle a single project per session A project contains various artifacts , which represent data to be analyzed Artifacts are usually files read from the local file system The analysis of artifacts yield units and sub-units Ex: Analyzing an Android DEX file artifact will yield at least one DEX unit representing the bytecode of that DEX file Users interact with units through views that contain fragments representing various aspects of a unit Within the UI client, fragments are visible as tabs at the bottom of a view Most units are interactive . Users can interact with them through a variety of ways, including via Actions , available in the similarly-named menu. Example: an Android Bytecode file artifact (classes.dex), after analysis, will yield a DEX unit that represents the bytecode of that DEX file. In the next section, we will show what actions can be performed to make the analysis of code interactive.","title":"Getting Started"},{"location":"index.html#getting-started","text":"This document is a usage manual for JEB3. The latest version of this manual can be found online on the PNF Software web site . JEB is a reverse-engineering platform to perform disassembly, decompilation, debugging, and analysis of code and document files, manually or as part of an analysis pipeline. The first part of this guide is a user manual that covers basic usage related to analyzing, decompiling and debugging applications (Android apps, as well as native binaries). It is not an exhaustive resource. We recommend visiting our blog for additional, pointed resources describing a variety of use cases. The second half is a developer portal for advanced users who will want to use the JEB API to script tasks, develop plugins, or even craft their own front-ends. Alongside these pages, the API reference documentation website will be an indispensable resource.","title":"Getting Started"},{"location":"index.html#installation","text":"","title":"Installation"},{"location":"index.html#software-package","text":"The software package is distributed as a zip archive, custom-generated for each registered user. It contains the back-end components as well as the reference front-end implementation for desktop platforms, referred to as the \"UI client\". This manual focuses mostly on using JEB through the UI client. The UI client client runs on Windows 64-bit, Linux/GTK 64-bit, and macOS 64-bit.","title":"Software Package"},{"location":"index.html#requirements","text":"","title":"Requirements"},{"location":"index.html#java","text":"JEB requires a Java Runtime Environment (JRE) or Java Development Kit (JDK) version 8 or above (8.191+).","title":"Java"},{"location":"index.html#setup","text":"Make sure you have a JRE or JDK installed. The java binary must be accessible from the PATH environment variable. Optionally, you may also want to set a JAVA_HOME environment variable pointing to your Java installation folder. 64-bit OS with 32-bit JRE: A common source of problems are 64-bit systems having a 32-bit JRE accessible from the PATH. You may have different versions of Java installed, but always make sure that your PATH or JAVA_HOME refers to one that matches your system specifications.","title":"Setup"},{"location":"index.html#startup","text":"Next, execute the startup script appropriate for your environment: On Windows: execute jeb_wincon.bat On Linux: execute jeb_linux.sh . On MacOS: execute jeb_macos.sh The startup script will locate and decrypt the JEB binary file. It may prompt the user and ask for the decryption password, which can be found within your software delivery email received from PNF Software. Enter the password to allow the startup script to finish the installation process. JEB will start.","title":"Startup"},{"location":"index.html#registration","text":"If it is the first time you are running a non-floating JEB client, you will be asked accept the end-user license agreement, and generate a license key: If your machine is connected to the Internet, the license key can be automatically generated by clicking \"Generate a Key\". If need be, you may also configure your Proxy settings. If your machine is not connected to the Internet, you will need to generate a manual key. Click \"Manual Key Generation\" and follow the instruction. You will be asked to visit the key generation portal on a separate machine (connected to the Internet), and provide your license data. The license key will be stored in the bin/jeb-client.cfg file, under the .LicenseKey key entry. A key is specific to the user-account and machine configuration on which JEB is running. Do not attempt to reuse a key on another system. Note : If you need to deprecate an older key (eg, because of a machine replacement, user departure, or else), email Licensing .","title":"Registration"},{"location":"index.html#first-use","text":"Congratulation! JEB is now running.","title":"First use"},{"location":"index.html#workspace","text":"You should be greeted by an empty workspace, using a default three-part layout: Project explorer on the left side Logger and Console at the bottom Empty area in the center","title":"Workspace"},{"location":"index.html#starting-an-analysis","text":"Let's open our first file in JEB. Go ahead and download Raasta.apk , a sample (clean) Android application that will serve as our testing ground for the next couple of chapters. Open it via the File menu. A new project will be created with a single artifact, Raasta.apk. The application is processed by various Android analysis plugins: The APK plugin takes care of unbundling the app, decoding the manifest and resources The DEX plugin performs the analysis and disassembly of the DEX bytecode file (or files) The XML parser analyzes XML resources The Certificate plugin analyzes the certificate ... and so on. Note : JEB performs recursive analysis on input artifacts and units, using the loaded parser plugins . The project explorer tree should display a Bytecode node, representing the DEX unit (more on the concept of units later). The DEX views should be opened automatically by the UI client, as they are detected as the principal views of an APK artifact. Your workspace should look like: The workspace can be customized by the user: Views can be dragged and dropped, resized, stacked and docked with other views Views can be detached and placed in separate windows - something particularly useful for multi-monitor setups.","title":"Starting an Analysis"},{"location":"index.html#terminology","text":"The Project Explorer contains three types of nodes: The top-most entity accessible within the UI client is a project Currently, the UI client can only handle a single project per session A project contains various artifacts , which represent data to be analyzed Artifacts are usually files read from the local file system The analysis of artifacts yield units and sub-units Ex: Analyzing an Android DEX file artifact will yield at least one DEX unit representing the bytecode of that DEX file Users interact with units through views that contain fragments representing various aspects of a unit Within the UI client, fragments are visible as tabs at the bottom of a view Most units are interactive . Users can interact with them through a variety of ways, including via Actions , available in the similarly-named menu. Example: an Android Bytecode file artifact (classes.dex), after analysis, will yield a DEX unit that represents the bytecode of that DEX file. In the next section, we will show what actions can be performed to make the analysis of code interactive.","title":"Terminology"},{"location":"actions.html","text":"Analysis Basics \u00b6 The primary use case for JEB is the analysis of binary code. This section focuses on the basics of code analysis and refactoring , such as: Renaming items such as methods or fields Changing the code structure by moving items to packages Commenting Navigating a code base via cross-references Viewing type hierarchies Viewing method overrides Graphing routines (CFG) Replacing items or rebasing immediates In the UI client, most fundamental interactions can be achieved via the Action and Navigation menus. Those actions are implemented by most JEB analysis modules that perform code disassembly. Note : Other action groups such as Native code actions and Debugging actions are detailed in later sections. Note : The examples in this section are based on the analysis of Raasta.apk using the Android DEX parser. Keep in mind that features and behaviors of Actions depend on the module implementing and performing them. Decompiling \u00b6 The next section covers decompiling code in depth. Renaming \u00b6 An important requirement for analysts is the ability to rename code items such as types, methods and routines, fields and data items, packages, etc. consistently across a code base. Position the caret on the item to be renamed Hit the N key or select Action, Rename Enter the new name and press Enter Tip: Within the Rename dialog box, press Ctrl+Space to bring up your renaming history. Commenting \u00b6 Anywhere in the code, press the / (slash) key to add a comment. Comments are attached to addresses or items. Navigating \u00b6 Pressing the Enter key on an item or double-clicking it will bring the caret to the definition of the item. You can navigate back and forth using the traditional Alt + Arrow Left (or Escape ) and Alt + Arrow Right key combos, or via the Navigation menu. The Next Item and Previous Item command allow you to jump to the similar item after or before the currently selected item. Cross-references \u00b6 Cross-references on an item allow the examination of items referencing it. Press the X key to visualize them. You can jump to a cross-reference by double-clicking it. Type Hierarchies \u00b6 Use the T key on a type item (such as a class or an interface) to visualize its ancestors and children. Double-click on a type item to jump to the item definition. Restructuring \u00b6 The Create Package and Move to Package actions offer powerful refactoring possibilities, especially useful in the case of large obfuscated binary files. If the module supports it, users are able to: Create artifical packages (aka, namespaces) using the K key. Move items, such as types, to existing or artificial packages using the L key. The following screenshot is an example where the class AppHelp was moved from the com.pnfsoftware.raasta package to a newly created package named com.abc . Want to learn more? Have a look at our YouTube demo video that demonstrates advanced refactoring and automatic restructuring of a heavily obfuscated Android malware application. Type Hierarchies \u00b6 The H key allows the examination of type hierarchy, such as parent classes, descendant classes, implemented interfaces, etc. Object Overrides \u00b6 The O key allows the examination of overrides, such as virtual method redefinitions in the case of object-oriented bytecode files. Rebasing Constants \u00b6 This feature allows the selection of the radix used to render immediate constant integers. Press the B key repeatedly to cycle through the bases offered by the plugin. Typically, bases 8, 10, 16 are offered. Some plugins may offer additional bases such as base 2, or non-conventional representation modes, such as character-based immediate rendering.","title":"Common Actions"},{"location":"actions.html#analysis-basics","text":"The primary use case for JEB is the analysis of binary code. This section focuses on the basics of code analysis and refactoring , such as: Renaming items such as methods or fields Changing the code structure by moving items to packages Commenting Navigating a code base via cross-references Viewing type hierarchies Viewing method overrides Graphing routines (CFG) Replacing items or rebasing immediates In the UI client, most fundamental interactions can be achieved via the Action and Navigation menus. Those actions are implemented by most JEB analysis modules that perform code disassembly. Note : Other action groups such as Native code actions and Debugging actions are detailed in later sections. Note : The examples in this section are based on the analysis of Raasta.apk using the Android DEX parser. Keep in mind that features and behaviors of Actions depend on the module implementing and performing them.","title":"Analysis Basics"},{"location":"actions.html#decompiling","text":"The next section covers decompiling code in depth.","title":"Decompiling"},{"location":"actions.html#renaming","text":"An important requirement for analysts is the ability to rename code items such as types, methods and routines, fields and data items, packages, etc. consistently across a code base. Position the caret on the item to be renamed Hit the N key or select Action, Rename Enter the new name and press Enter Tip: Within the Rename dialog box, press Ctrl+Space to bring up your renaming history.","title":"Renaming"},{"location":"actions.html#commenting","text":"Anywhere in the code, press the / (slash) key to add a comment. Comments are attached to addresses or items.","title":"Commenting"},{"location":"actions.html#navigating","text":"Pressing the Enter key on an item or double-clicking it will bring the caret to the definition of the item. You can navigate back and forth using the traditional Alt + Arrow Left (or Escape ) and Alt + Arrow Right key combos, or via the Navigation menu. The Next Item and Previous Item command allow you to jump to the similar item after or before the currently selected item.","title":"Navigating"},{"location":"actions.html#cross-references","text":"Cross-references on an item allow the examination of items referencing it. Press the X key to visualize them. You can jump to a cross-reference by double-clicking it.","title":"Cross-references"},{"location":"actions.html#type-hierarchies","text":"Use the T key on a type item (such as a class or an interface) to visualize its ancestors and children. Double-click on a type item to jump to the item definition.","title":"Type Hierarchies"},{"location":"actions.html#restructuring","text":"The Create Package and Move to Package actions offer powerful refactoring possibilities, especially useful in the case of large obfuscated binary files. If the module supports it, users are able to: Create artifical packages (aka, namespaces) using the K key. Move items, such as types, to existing or artificial packages using the L key. The following screenshot is an example where the class AppHelp was moved from the com.pnfsoftware.raasta package to a newly created package named com.abc . Want to learn more? Have a look at our YouTube demo video that demonstrates advanced refactoring and automatic restructuring of a heavily obfuscated Android malware application.","title":"Restructuring"},{"location":"actions.html#type-hierarchies_1","text":"The H key allows the examination of type hierarchy, such as parent classes, descendant classes, implemented interfaces, etc.","title":"Type Hierarchies"},{"location":"actions.html#object-overrides","text":"The O key allows the examination of overrides, such as virtual method redefinitions in the case of object-oriented bytecode files.","title":"Object Overrides"},{"location":"actions.html#rebasing-constants","text":"This feature allows the selection of the radix used to render immediate constant integers. Press the B key repeatedly to cycle through the bases offered by the plugin. Typically, bases 8, 10, 16 are offered. Some plugins may offer additional bases such as base 2, or non-conventional representation modes, such as character-based immediate rendering.","title":"Rebasing Constants"},{"location":"android-debugging.html","text":"Android App Debugging \u00b6 JEB supports debugging Dalvik code via JDWP and Native *.so libraries via gdb/lldb. A single JEB session allows seamless transition between debugging the Dalvik VM, jumping into native methods invoked via JNI, debugging native code (arm, x86, else), and switching back to Dalvik. First, make sure to read the Generic debugging page. Technical Articles \u00b6 Tutorial, intro: An introduction to JEB Android Debuggers Tutorial, intermediate: Advanced Debugger Usage via the Interpreter A note on recent Android versions: Debugging Android apps on Android Pie and above API/Scripting: Crypto Monitoring with the Android Debuggers API Use-case, obfuscation: Defeating AppSolid Android application protector Use-case, dynamic dex: Debugging Dynamically Loaded DEX Bytecode Files JNI debugging helper: Dynamic JNI Detection Plugin (Reference: List to all blog articles on debugging ) Generating Debuggable APK \u00b6 While JEB does its best to support debugging non-debuggable apps (eg, on emulators or rooted devices, with caveats), it is generally easier to debug Android applications explicitly marked debuggable in their Manifest: <application android:debuggable=\"true\" ...> JEB has built-in utility to rebuild a non-debuggable APK into a debuggable one, while maintaining the entire structure of the application intact, except for its signing data of course. Navigate to your JEB folder, and use the start-up script to run: (in the example below, on Windows) $ jeb_wincon.bat -c --makeapkdebug -- file.apk Upon success, file_debuggable.apk will be generated. Sign it using Android SDK's apksigner , install it on your device, and start debugging. Keep in mind that this solution has shortcomings: Anti-debugging code may check at runtime that the app is not debuggable, as would be expected. More elaborate protections may implement certificate pinning-style checks, where the code verifies that it is signed using a specific certificate. Section under construction.","title":"Android App Debugging"},{"location":"android-debugging.html#android-app-debugging","text":"JEB supports debugging Dalvik code via JDWP and Native *.so libraries via gdb/lldb. A single JEB session allows seamless transition between debugging the Dalvik VM, jumping into native methods invoked via JNI, debugging native code (arm, x86, else), and switching back to Dalvik. First, make sure to read the Generic debugging page.","title":"Android App Debugging"},{"location":"android-debugging.html#technical-articles","text":"Tutorial, intro: An introduction to JEB Android Debuggers Tutorial, intermediate: Advanced Debugger Usage via the Interpreter A note on recent Android versions: Debugging Android apps on Android Pie and above API/Scripting: Crypto Monitoring with the Android Debuggers API Use-case, obfuscation: Defeating AppSolid Android application protector Use-case, dynamic dex: Debugging Dynamically Loaded DEX Bytecode Files JNI debugging helper: Dynamic JNI Detection Plugin (Reference: List to all blog articles on debugging )","title":"Technical Articles"},{"location":"android-debugging.html#generating-debuggable-apk","text":"While JEB does its best to support debugging non-debuggable apps (eg, on emulators or rooted devices, with caveats), it is generally easier to debug Android applications explicitly marked debuggable in their Manifest: <application android:debuggable=\"true\" ...> JEB has built-in utility to rebuild a non-debuggable APK into a debuggable one, while maintaining the entire structure of the application intact, except for its signing data of course. Navigate to your JEB folder, and use the start-up script to run: (in the example below, on Windows) $ jeb_wincon.bat -c --makeapkdebug -- file.apk Upon success, file_debuggable.apk will be generated. Sign it using Android SDK's apksigner , install it on your device, and start debugging. Keep in mind that this solution has shortcomings: Anti-debugging code may check at runtime that the app is not debuggable, as would be expected. More elaborate protections may implement certificate pinning-style checks, where the code verifies that it is signed using a specific certificate. Section under construction.","title":"Generating Debuggable APK"},{"location":"android.html","text":"Android App Analysis \u00b6 JEB is a well-known industry tool used to reverse-engineer and audit Android applications. Using JEB, you can: Analyze APK files and their contents, including DEX files, Certificates, Resources, Assets, Native Library code, etc. Examine encoded resource files and manifests: JEB ships with its own resource decoder, with support for obfuscated resource names and locations. Examine certificates data (legacy, v2, and v3) Decompile DEX bytecode, with full-support for multi-DEX reconstruction. Analyze native library (.so) code: more on the Native code analysis section Debug Android applications (Dalvik and Native - x86, arm, mips - code) and transition seamlessly from Dalvik to Native, and vice-versa. API support for client scripts in Python, back-end plugins in Java, and client contributions (UI overlays). Section under construction. Please head over to our Blog to learn more about specific features of our Android modules. Blogs \u00b6 Link: All PNF Software blog posts tagged Android. Using additional frameworks \u00b6 When analyzing applications using resources located in other frameworks that the Android Framework (e.g. the Samsung framework), follow those steps: retrieve the framework archive, which is normally stored on the device; let's call it framework.zip run aapt2 dump framework.zip and retrieve the first line, which will be something like Package name=xxxxxxx id=N . Note the id, N navigate to the folder listed in your .parsers.apk.FrameworksDirectory engines property. Typically, it will be the HOME_FOLDER/.jeb-android-frameworks folder copy framework.zip into this folder, and rename it to N.zip JEB should now be able to pick up that framework and use its resources when needed Note: 1.zip in the FrameworksDirectory folder is the Android Framework itself, which has id 1","title":"Android App Analysis"},{"location":"android.html#android-app-analysis","text":"JEB is a well-known industry tool used to reverse-engineer and audit Android applications. Using JEB, you can: Analyze APK files and their contents, including DEX files, Certificates, Resources, Assets, Native Library code, etc. Examine encoded resource files and manifests: JEB ships with its own resource decoder, with support for obfuscated resource names and locations. Examine certificates data (legacy, v2, and v3) Decompile DEX bytecode, with full-support for multi-DEX reconstruction. Analyze native library (.so) code: more on the Native code analysis section Debug Android applications (Dalvik and Native - x86, arm, mips - code) and transition seamlessly from Dalvik to Native, and vice-versa. API support for client scripts in Python, back-end plugins in Java, and client contributions (UI overlays). Section under construction. Please head over to our Blog to learn more about specific features of our Android modules.","title":"Android App Analysis"},{"location":"android.html#blogs","text":"Link: All PNF Software blog posts tagged Android.","title":"Blogs"},{"location":"android.html#using-additional-frameworks","text":"When analyzing applications using resources located in other frameworks that the Android Framework (e.g. the Samsung framework), follow those steps: retrieve the framework archive, which is normally stored on the device; let's call it framework.zip run aapt2 dump framework.zip and retrieve the first line, which will be something like Package name=xxxxxxx id=N . Note the id, N navigate to the folder listed in your .parsers.apk.FrameworksDirectory engines property. Typically, it will be the HOME_FOLDER/.jeb-android-frameworks folder copy framework.zip into this folder, and rename it to N.zip JEB should now be able to pick up that framework and use its resources when needed Note: 1.zip in the FrameworksDirectory folder is the Android Framework itself, which has id 1","title":"Using additional frameworks"},{"location":"client-configuration.html","text":"Client Configuration \u00b6 The UI client stores its client configuration , also known as the front-end configuration, in bin/jeb-client.cfg . The configuration file is a key-value store where keys are fully-qualified identifiers that start with a leading dot. The public keys can safely be changed by a user. They are accessible in the Options dialog, Advanced mode, panel Client . .CheckUpdates \u00b6 Description : Let JEB automatically check for software updates (requires an Internet connection) Type and Default : Boolean(true) .DevelopmentMode \u00b6 Description : Increase verbosity and error messages. Recommended when developing JEB Extensions (plugins or scripts). Type and Default : Boolean(false) .NetworkProxy \u00b6 Description : Network proxy settings for JEB client components. The format of this property is: 'type|hostname|port|user|pass|whitelist'. type can be direct (no proxy), http, or socks hostname and port are mandatory for non-direct proxy types user and password are optional (needed only if your proxy requires authentication) whitelist is an optional list of domains/IPs (with support for the wildcard character *) for which no proxy connection should be used (always direct connect) Type and Default : String(\"\") .ScriptsFolder \u00b6 Description : Folder containing JEB client scripts written in Python Type and Default : Path(\"$JEB_HOME/scripts\") .UploadErrorLogs \u00b6 Description : Securely upload error logs to PNF Software error server Type and Default : Boolean(true) .ui.AlwaysLoadFragments \u00b6 Description : Always load view fragments (leave to false to let lazy fragments load their data only they are visualized by the user) Type and Default : Boolean(false) .ui.AutoOpenDefaultUnit \u00b6 Description : Upon processing a new file artifact, the default unit (internal rule set) will be opened - and the default fragment potentially opened as well Type and Default : Boolean(true) .ui.DoNotReplaceViews \u00b6 Description : Create a new fragment when visualizing a type of document already opened in the workspace (instead of replacing it) Type and Default : Boolean(true) .ui.ExpandTreeNodesOnFiltering \u00b6 Description : Expand matching tree nodes when applying a string filter Type and Default : Boolean(true) .ui.KeyboardShortcutsFile \u00b6 Description : Location of the custom keyboard shortcuts file Type and Default : Path(\"jeb-shortcuts.cfg\") .ui.LoggerMaxLength \u00b6 Description : Maximum log buffer size in characters (older logger lines get discarded) Type and Default : Integer(524288){0+} .ui.PreferRealAddressesInDialogs \u00b6 Description : In dialogs displaying addresses (eg, cross-references), always display real (internal) addresses over user-friendly addresses that may be provided by plugins Type and Default : Boolean(false) .ui.ProjectUnitSync \u00b6 Description : Keep the unit that generated the currently visualized item visible in the Project tree Type and Default : Boolean(false) .ui.ShowWarningNotificationsInStatus \u00b6 Description : Show important notifications by flashing a Warning sign in the status bar Type and Default : Boolean(true) .ui.graphs.AutoGenerate \u00b6 Description : Auto-generate the global graph upon processing a binary file Type and Default : Boolean(false) .ui.graphs.KeepInMainDock \u00b6 Description : Keep the global graph docked in the main shell instead of being in a floating modeless dialog Type and Default : Boolean(true) .ui.graphs.LockView \u00b6 Description : Lock the global graph: prevent auto-moving/sync'ing with the currently active method or code item Type and Default : Boolean(false) .ui.native.DisableTypePreparsing \u00b6 Description : Disable native type pre-parsing (syntax validation) in type edition dialogs Type and Default : Boolean(false) .ui.state.MainShellBounds \u00b6 Description : Bounds of the main shell. Leave blank for default; else: -1=maximized, or a set of \"x,y,w,h\" to remember position and size) Type and Default : String(\"\") .ui.text.AllowLineWrapping \u00b6 Description : Wrap overly long lines Type and Default : Boolean(false) .ui.text.CharactersPerLineMax \u00b6 Description : Maximum number of characters per line before forcing a line-wrap (whether or not line wrapping is enabled) Type and Default : Integer(4000){0+} .ui.text.CharactersWrap \u00b6 Description : Limit of a line before wrapping, if line wrap is enabled Type and Default : Integer(-1) .ui.text.DisplayEolAtEod \u00b6 Description : Display an extra line at the end of a text document Type and Default : Boolean(true) .ui.text.NavigationBarPosition \u00b6 Description : Position of the navigation bar: 1=top, 2=right (default), 3=bottom, 4=left Type and Default : Integer(2){0-4} .ui.text.ScrollLineSize \u00b6 Description : Number of lines scrolled on a mouse-whell scroll action Type and Default : Integer(2) .ui.text.cfg.ShowAddresses \u00b6 Description : Show addresses in control flow graph views Type and Default : Boolean(false) .ui.text.cfg.ShowBytesCount \u00b6 Description : Show bytes in control flow graph views Type and Default : Integer(0) .ui.tree.BucketFlatMaxElements \u00b6 Description : Maximum number of elements in a single artificial bucket Type and Default : Integer(500){0+} .ui.tree.BucketFlatThreshold \u00b6 Description : Element count threshold that will trigger the creation of buckets in tree viewers with flat structures (eg, native code hierarchies) Type and Default : Integer(2000){0+} .ui.tree.BucketTreeMaxElements \u00b6 Description : Maximum number of elements in a single artificial bucket Type and Default : Integer(200){0+} .ui.tree.BucketTreeThreshold \u00b6 Description : Element count threshold that will trigger the creation of buckets in tree viewers with hierarchical structures (eg, Dalvik hierarchies) Type and Default : Integer(200){0+} .ui.tree.UseExplicitDefaultPackage \u00b6 Description : Use a default package when artificial buckets in tree viewers are created Type and Default : Boolean(true)","title":"Client Configuration"},{"location":"client-configuration.html#client-configuration","text":"The UI client stores its client configuration , also known as the front-end configuration, in bin/jeb-client.cfg . The configuration file is a key-value store where keys are fully-qualified identifiers that start with a leading dot. The public keys can safely be changed by a user. They are accessible in the Options dialog, Advanced mode, panel Client .","title":"Client Configuration"},{"location":"client-configuration.html#checkupdates","text":"Description : Let JEB automatically check for software updates (requires an Internet connection) Type and Default : Boolean(true)","title":".CheckUpdates"},{"location":"client-configuration.html#developmentmode","text":"Description : Increase verbosity and error messages. Recommended when developing JEB Extensions (plugins or scripts). Type and Default : Boolean(false)","title":".DevelopmentMode"},{"location":"client-configuration.html#networkproxy","text":"Description : Network proxy settings for JEB client components. The format of this property is: 'type|hostname|port|user|pass|whitelist'. type can be direct (no proxy), http, or socks hostname and port are mandatory for non-direct proxy types user and password are optional (needed only if your proxy requires authentication) whitelist is an optional list of domains/IPs (with support for the wildcard character *) for which no proxy connection should be used (always direct connect) Type and Default : String(\"\")","title":".NetworkProxy"},{"location":"client-configuration.html#scriptsfolder","text":"Description : Folder containing JEB client scripts written in Python Type and Default : Path(\"$JEB_HOME/scripts\")","title":".ScriptsFolder"},{"location":"client-configuration.html#uploaderrorlogs","text":"Description : Securely upload error logs to PNF Software error server Type and Default : Boolean(true)","title":".UploadErrorLogs"},{"location":"client-configuration.html#uialwaysloadfragments","text":"Description : Always load view fragments (leave to false to let lazy fragments load their data only they are visualized by the user) Type and Default : Boolean(false)","title":".ui.AlwaysLoadFragments"},{"location":"client-configuration.html#uiautoopendefaultunit","text":"Description : Upon processing a new file artifact, the default unit (internal rule set) will be opened - and the default fragment potentially opened as well Type and Default : Boolean(true)","title":".ui.AutoOpenDefaultUnit"},{"location":"client-configuration.html#uidonotreplaceviews","text":"Description : Create a new fragment when visualizing a type of document already opened in the workspace (instead of replacing it) Type and Default : Boolean(true)","title":".ui.DoNotReplaceViews"},{"location":"client-configuration.html#uiexpandtreenodesonfiltering","text":"Description : Expand matching tree nodes when applying a string filter Type and Default : Boolean(true)","title":".ui.ExpandTreeNodesOnFiltering"},{"location":"client-configuration.html#uikeyboardshortcutsfile","text":"Description : Location of the custom keyboard shortcuts file Type and Default : Path(\"jeb-shortcuts.cfg\")","title":".ui.KeyboardShortcutsFile"},{"location":"client-configuration.html#uiloggermaxlength","text":"Description : Maximum log buffer size in characters (older logger lines get discarded) Type and Default : Integer(524288){0+}","title":".ui.LoggerMaxLength"},{"location":"client-configuration.html#uipreferrealaddressesindialogs","text":"Description : In dialogs displaying addresses (eg, cross-references), always display real (internal) addresses over user-friendly addresses that may be provided by plugins Type and Default : Boolean(false)","title":".ui.PreferRealAddressesInDialogs"},{"location":"client-configuration.html#uiprojectunitsync","text":"Description : Keep the unit that generated the currently visualized item visible in the Project tree Type and Default : Boolean(false)","title":".ui.ProjectUnitSync"},{"location":"client-configuration.html#uishowwarningnotificationsinstatus","text":"Description : Show important notifications by flashing a Warning sign in the status bar Type and Default : Boolean(true)","title":".ui.ShowWarningNotificationsInStatus"},{"location":"client-configuration.html#uigraphsautogenerate","text":"Description : Auto-generate the global graph upon processing a binary file Type and Default : Boolean(false)","title":".ui.graphs.AutoGenerate"},{"location":"client-configuration.html#uigraphskeepinmaindock","text":"Description : Keep the global graph docked in the main shell instead of being in a floating modeless dialog Type and Default : Boolean(true)","title":".ui.graphs.KeepInMainDock"},{"location":"client-configuration.html#uigraphslockview","text":"Description : Lock the global graph: prevent auto-moving/sync'ing with the currently active method or code item Type and Default : Boolean(false)","title":".ui.graphs.LockView"},{"location":"client-configuration.html#uinativedisabletypepreparsing","text":"Description : Disable native type pre-parsing (syntax validation) in type edition dialogs Type and Default : Boolean(false)","title":".ui.native.DisableTypePreparsing"},{"location":"client-configuration.html#uistatemainshellbounds","text":"Description : Bounds of the main shell. Leave blank for default; else: -1=maximized, or a set of \"x,y,w,h\" to remember position and size) Type and Default : String(\"\")","title":".ui.state.MainShellBounds"},{"location":"client-configuration.html#uitextallowlinewrapping","text":"Description : Wrap overly long lines Type and Default : Boolean(false)","title":".ui.text.AllowLineWrapping"},{"location":"client-configuration.html#uitextcharactersperlinemax","text":"Description : Maximum number of characters per line before forcing a line-wrap (whether or not line wrapping is enabled) Type and Default : Integer(4000){0+}","title":".ui.text.CharactersPerLineMax"},{"location":"client-configuration.html#uitextcharacterswrap","text":"Description : Limit of a line before wrapping, if line wrap is enabled Type and Default : Integer(-1)","title":".ui.text.CharactersWrap"},{"location":"client-configuration.html#uitextdisplayeolateod","text":"Description : Display an extra line at the end of a text document Type and Default : Boolean(true)","title":".ui.text.DisplayEolAtEod"},{"location":"client-configuration.html#uitextnavigationbarposition","text":"Description : Position of the navigation bar: 1=top, 2=right (default), 3=bottom, 4=left Type and Default : Integer(2){0-4}","title":".ui.text.NavigationBarPosition"},{"location":"client-configuration.html#uitextscrolllinesize","text":"Description : Number of lines scrolled on a mouse-whell scroll action Type and Default : Integer(2)","title":".ui.text.ScrollLineSize"},{"location":"client-configuration.html#uitextcfgshowaddresses","text":"Description : Show addresses in control flow graph views Type and Default : Boolean(false)","title":".ui.text.cfg.ShowAddresses"},{"location":"client-configuration.html#uitextcfgshowbytescount","text":"Description : Show bytes in control flow graph views Type and Default : Integer(0)","title":".ui.text.cfg.ShowBytesCount"},{"location":"client-configuration.html#uitreebucketflatmaxelements","text":"Description : Maximum number of elements in a single artificial bucket Type and Default : Integer(500){0+}","title":".ui.tree.BucketFlatMaxElements"},{"location":"client-configuration.html#uitreebucketflatthreshold","text":"Description : Element count threshold that will trigger the creation of buckets in tree viewers with flat structures (eg, native code hierarchies) Type and Default : Integer(2000){0+}","title":".ui.tree.BucketFlatThreshold"},{"location":"client-configuration.html#uitreebuckettreemaxelements","text":"Description : Maximum number of elements in a single artificial bucket Type and Default : Integer(200){0+}","title":".ui.tree.BucketTreeMaxElements"},{"location":"client-configuration.html#uitreebuckettreethreshold","text":"Description : Element count threshold that will trigger the creation of buckets in tree viewers with hierarchical structures (eg, Dalvik hierarchies) Type and Default : Integer(200){0+}","title":".ui.tree.BucketTreeThreshold"},{"location":"client-configuration.html#uitreeuseexplicitdefaultpackage","text":"Description : Use a default package when artificial buckets in tree viewers are created Type and Default : Boolean(true)","title":".ui.tree.UseExplicitDefaultPackage"},{"location":"debugging.html","text":"Debugging \u00b6 Debuggers are special modules that attach to existing code units. They do not produce additional units; instead, they provide specialized actions , accessible graphically via the Debugger menu in the UI client. The following picture shows two debugger units connected to an Android app. Note to developers : debugger modules offer a rich API. UI clients can only reflect those functionality partly. Visit the Resources sub-section for more information on how to use the debuggers API to perform advanced dynamic analysis of applications. Availability \u00b6 Currently, JEB ships with debuggers for: Android DEX bytecode: the debugger is a custom JDWP client implementation x86/x86-64, ARM/ARM64, and MIPS: the debuggers are custom GDB client implementations Attaching to a Target \u00b6 Open a code view representing the code unit to be debugged. Execute *Debugger/Attach\" Select the target machine and target process Click Attach One or more debugger unit(s) will be created, depending on your target application. Views \u00b6 The UI client will also open automatically open views that represent the debugger units. Those views are: Threads Breakpoints Local variables and registers Memory and live disassembly (if applicable) Current stack (if applicable) Log view You may want to switch to a custom layout to better accommodate those additional views. The above pictures shows an on-going debugging session of an Android app. A custom layout is used: the bytecode debugger views are in the top-right hand quadrant the process code debugger views are in the bottom-right hand quadrant A breakpoint can also be seen, as well as the about-to-be-executed line of code. Basic Commands \u00b6 The basic commands are accessible from the Debugger menu. Detach from or restart the debugging session Pause, resume, or terminate the target Suspend or resume threads Set breakpoints Step execution (into, over, or out of a routine) etc. The live values of variables and registers can also be examining by hovering over an item representing them. More : a detailed overview of basic debugging capabilities, specifically for Android app debugging, can be found on our blog . Advanced Commands \u00b6 Advanced debugging commands can be used via the Console view. This view is linked to command interpreters offered by the currently focused unit. Debuggers offer command interpreter to perform advanced tasks such as: Searching patterns in memory Examining objects Creating objects or invoking methods Custom tasks specific to a given debugger that cannot be generically represented by the UI client The screenshot below shows the expanded Console view with an interpreter connected to the Dalvik Bytecode debugger: More : a detailed overview of the interpreters' features can be found on our blog . Resources \u00b6 Debugger Tutorial, part 1 - Android: An Introduction to JEB Android Debuggers Debugger Tutorial, part 2 - Interpreter: Advanced Debugger Usage via the Interpreter Debugger Tutorial, part 3 - Automation: Crypto Monitoring with the Android Debuggers API Also consult the Reference API Documentation .","title":"Debugging"},{"location":"debugging.html#debugging","text":"Debuggers are special modules that attach to existing code units. They do not produce additional units; instead, they provide specialized actions , accessible graphically via the Debugger menu in the UI client. The following picture shows two debugger units connected to an Android app. Note to developers : debugger modules offer a rich API. UI clients can only reflect those functionality partly. Visit the Resources sub-section for more information on how to use the debuggers API to perform advanced dynamic analysis of applications.","title":"Debugging"},{"location":"debugging.html#availability","text":"Currently, JEB ships with debuggers for: Android DEX bytecode: the debugger is a custom JDWP client implementation x86/x86-64, ARM/ARM64, and MIPS: the debuggers are custom GDB client implementations","title":"Availability"},{"location":"debugging.html#attaching-to-a-target","text":"Open a code view representing the code unit to be debugged. Execute *Debugger/Attach\" Select the target machine and target process Click Attach One or more debugger unit(s) will be created, depending on your target application.","title":"Attaching to a Target"},{"location":"debugging.html#views","text":"The UI client will also open automatically open views that represent the debugger units. Those views are: Threads Breakpoints Local variables and registers Memory and live disassembly (if applicable) Current stack (if applicable) Log view You may want to switch to a custom layout to better accommodate those additional views. The above pictures shows an on-going debugging session of an Android app. A custom layout is used: the bytecode debugger views are in the top-right hand quadrant the process code debugger views are in the bottom-right hand quadrant A breakpoint can also be seen, as well as the about-to-be-executed line of code.","title":"Views"},{"location":"debugging.html#basic-commands","text":"The basic commands are accessible from the Debugger menu. Detach from or restart the debugging session Pause, resume, or terminate the target Suspend or resume threads Set breakpoints Step execution (into, over, or out of a routine) etc. The live values of variables and registers can also be examining by hovering over an item representing them. More : a detailed overview of basic debugging capabilities, specifically for Android app debugging, can be found on our blog .","title":"Basic Commands"},{"location":"debugging.html#advanced-commands","text":"Advanced debugging commands can be used via the Console view. This view is linked to command interpreters offered by the currently focused unit. Debuggers offer command interpreter to perform advanced tasks such as: Searching patterns in memory Examining objects Creating objects or invoking methods Custom tasks specific to a given debugger that cannot be generically represented by the UI client The screenshot below shows the expanded Console view with an interpreter connected to the Dalvik Bytecode debugger: More : a detailed overview of the interpreters' features can be found on our blog .","title":"Advanced Commands"},{"location":"debugging.html#resources","text":"Debugger Tutorial, part 1 - Android: An Introduction to JEB Android Debuggers Debugger Tutorial, part 2 - Interpreter: Advanced Debugger Usage via the Interpreter Debugger Tutorial, part 3 - Automation: Crypto Monitoring with the Android Debuggers API Also consult the Reference API Documentation .","title":"Resources"},{"location":"decompiling.html","text":"Decompiling Code \u00b6 Decompiler are special modules that work on units as input instead of artifacts. They produce units as well, representing portions of decompiled source code. JEB Pro ships with decompilers for: Dalvik (Android DEX files) WebAssembly modules (wasm) Ethereum contracts (EVM code) Intel x86 32-bit (all x86 - SSE/AVX support coming in JEB 3.1) Intel x86 64-bit (all x86 - SSE/AVX support coming in JEB 3.1) ARM 32-bit (and common ISA extensions) ARM 64-bit (v8 / aarch64) MIPS 32-bit The following picture shows a child decompiler unit, as well as a suite of decompiled classes units. How to Decompile \u00b6 In the assembly view, position your caret on the area of code you would like to decompile. Hit the Tab key to decompile code (you can customize this, see the Keyboard Shortcuts section in the Settings page ) If a decompiler unit can be created for the current code unit, a new decompiled code unit will be created The decompiled code unit will receive focus and the caret positioned on the area of code that most closely corresponds to the low-level bytecode or machine code Back to the Assembly \u00b6 Conversely, you can go back to the assembly from a decompiled view by using the Tab or Q key. Managing Views \u00b6 By default, a view representing a portion of decompiled code (eg, a class) will be replaced by the next class being decompiled. This default behavior is to avoid cluttering the workspace with tens of views representing various decompiled artifacts. However, if you would like to open every piece of decompiled code in a separate view, you may do so by checking the Navigation, do not replace Views menu option. Actions and Interactivity \u00b6 Generally, when it comes to interactity, decompilation plugins proxy requests to their corresponding parent code unit. That means that the actions set offered is essentially the same. The consistency between views is maintained.","title":"Decompiling"},{"location":"decompiling.html#decompiling-code","text":"Decompiler are special modules that work on units as input instead of artifacts. They produce units as well, representing portions of decompiled source code. JEB Pro ships with decompilers for: Dalvik (Android DEX files) WebAssembly modules (wasm) Ethereum contracts (EVM code) Intel x86 32-bit (all x86 - SSE/AVX support coming in JEB 3.1) Intel x86 64-bit (all x86 - SSE/AVX support coming in JEB 3.1) ARM 32-bit (and common ISA extensions) ARM 64-bit (v8 / aarch64) MIPS 32-bit The following picture shows a child decompiler unit, as well as a suite of decompiled classes units.","title":"Decompiling Code"},{"location":"decompiling.html#how-to-decompile","text":"In the assembly view, position your caret on the area of code you would like to decompile. Hit the Tab key to decompile code (you can customize this, see the Keyboard Shortcuts section in the Settings page ) If a decompiler unit can be created for the current code unit, a new decompiled code unit will be created The decompiled code unit will receive focus and the caret positioned on the area of code that most closely corresponds to the low-level bytecode or machine code","title":"How to Decompile"},{"location":"decompiling.html#back-to-the-assembly","text":"Conversely, you can go back to the assembly from a decompiled view by using the Tab or Q key.","title":"Back to the Assembly"},{"location":"decompiling.html#managing-views","text":"By default, a view representing a portion of decompiled code (eg, a class) will be replaced by the next class being decompiled. This default behavior is to avoid cluttering the workspace with tens of views representing various decompiled artifacts. However, if you would like to open every piece of decompiled code in a separate view, you may do so by checking the Navigation, do not replace Views menu option.","title":"Managing Views"},{"location":"decompiling.html#actions-and-interactivity","text":"Generally, when it comes to interactity, decompilation plugins proxy requests to their corresponding parent code unit. That means that the actions set offered is essentially the same. The consistency between views is maintained.","title":"Actions and Interactivity"},{"location":"engines-configuration.html","text":"Engines Configuration \u00b6 JEB clients store the JEB engines configuration , also known as the back-end configuration, in the bin/jeb-engines.cfg . The configuration file is a key-value store where keys are fully-qualified identifiers that start with a leading dot. This file contains general back-end settings as well as the settings of common plugins shipping with most distributions of JEB. Each plugin has its own sub-namespace ( .PluginType ) within the .parsers namespace. Keys pertaining to document rendering are stored in a sub-region named .text . The public keys can safely be changed by a user. They are accessible in the Options dialog, Advanced mode, panel Engines . The engines configuration acts as a template for your projects' settings. Once a project is loaded, an additional tab named Project-Specific allows the user to modify the back-end settings of the project only, without changing the global back-end settings. ) .DatabaseBackupBeforeSave \u00b6 Description : Before saving a project to JDB2, the current JDB2 database is copied to the %TEMP% folder and will be used as backup is any problem showed up during saving. Type and Default : Boolean(true) .DevPluginClassnames \u00b6 Description : Classnames of your in-development plugin entry-point classes (they are not JARs) Type and Default : String(\"\") .DevPluginClasspath \u00b6 Description : Classpath for your in-development plugins (they are not JARs) Type and Default : String(\"\") .LoadPythonPlugins \u00b6 Description : Specify whether or not JEB back-end plugins written in Python are allowed and should be loaded Type and Default : Boolean(true) .NetworkProxy \u00b6 Description : Network proxy settings for JEB back-end components. The format of this property is: 'protocol|hostname|port|user|pass'. Protocol can be http or socks. User and password are optional (needed only if your proxy requires authentication) Type and Default : String(\"\") .PluginsFolder \u00b6 Description : Location of the JEB back-end plugins folder Type and Default : String(\"$JEB_HOME/coreplugins\") .SiglibsAutoLoadPackages \u00b6 Description : Specify whether or not signature libraries should be automatically loaded when target file is deemed suitable Type and Default : Boolean(true) .SiglibsAutoModeSaveCount \u00b6 Description : Number of signatures that need to be created before saving to a signature package; if 0 the package is not saved by this manager Type and Default : Integer(10) .SiglibsFolder \u00b6 Description : Folder containing native code signature libraries Type and Default : String(\"$JEB_HOME/siglibs\") .TypelibsFolder \u00b6 Description : Folder containing native type libraries Type and Default : String(\"$JEB_HOME/typelibs\") .parsers.EnforceVersionChecks \u00b6 Description : Verify that the plugins's requirements in terms for JEB are met. Ex: if enabled, a plugin requiring JEB [2.3.10, 3.0.7] will not be loaded if JEB is older than 2.3.10 or newer than 3.0.7 Type and Default : Boolean(true) .parsers.apk.AndroidJavadocRoot \u00b6 Description : Location of Java/Android API documentation files; by default, local files stored in your Android SDK folder will be preferred over web-based API doc Type and Default : String(\"($ANDROID_HOME/docs|$ANDROID_SDK_HOME/docs|$ANDROID_SDK_ROOT/docs)/reference/;https://developer.android.com/reference/;($JAVA_HOME)/docs/api\") .parsers.apk.DisableAssetsProcessingThreshold \u00b6 Description : The plugin will suggest disabling the auto-processing of APK assets if the number of asset files exceed that threshold (0 to disable) Type and Default : Integer(300){0+} .parsers.apk.DisableResourcesProcessingThreshold \u00b6 Description : The plugin will suggest disabling the auto-processing of APK resources if the number of resource files exceed that threshold (0 to disable) Type and Default : Integer(500){0+} .parsers.apk.FrameworksDirectory \u00b6 Description : Directory containing additional frameworks. Leave empty to use the default, which is the '.jeb-android-frameworks' directory in your Home folder Type and Default : Path(\"\") .parsers.apk.GenerateAapt2Output \u00b6 Description : Tick to generate an additional text fragment that will describe the APK resources similarly to AAPT2's output Type and Default : Boolean(false) .parsers.apk.MergeMultiDex \u00b6 Description : Attempt to merge the DEX files of a multi-DEX APK into a single, unified DEX unit Type and Default : Boolean(true) .parsers.apk.ProcessAssets \u00b6 Description : Process files in the APK's Assets directory Type and Default : Boolean(true) .parsers.apk.ProcessBytecode \u00b6 Description : Process the Dalvik bytecode (classes[N].dex) Type and Default : Boolean(true) .parsers.apk.ProcessCertificates \u00b6 Description : Process the APK's certificates data (legacy, v1, and v2) Type and Default : Boolean(true) .parsers.apk.ProcessLibraries \u00b6 Description : Process native code (.so) libraries Type and Default : Boolean(true) .parsers.apk.ProcessManifest \u00b6 Description : Decode and process the APK Manifest Type and Default : Boolean(true) .parsers.apk.ProcessResources \u00b6 Description : Decode and process the Resources (if this option is true, the Manifest is always processed) Type and Default : Boolean(true) .parsers.arm.AdvancedAnalysisRoutineCountWarning \u00b6 Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+} .parsers.arm.AllowAdvancedAnalysis \u00b6 Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false) .parsers.arm.AnalysisStyle \u00b6 Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4} .parsers.arm.DebugInformationRetrievalPolicy \u00b6 Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2} .parsers.arm.DebugInformationUsagePolicy \u00b6 Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2} .parsers.arm.PerformClassRecovery \u00b6 Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false) .parsers.arm.PerformGlobalAnalysis \u00b6 Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.arm.PreferSynchronousExecution \u00b6 Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false) .parsers.arm.WantedEndianness \u00b6 Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\") .parsers.arm.WantedImageBase \u00b6 Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\") .parsers.arm.text.BlockXrefsCount \u00b6 Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.arm.text.CharBreak64BitAddresses \u00b6 Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.arm.text.GapPreferRawFormatting \u00b6 Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false) .parsers.arm.text.GapRawBytesPerLine \u00b6 Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.arm.text.GapRawIntegerSize \u00b6 Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.arm.text.InstructionAreaLength \u00b6 Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.arm.text.LabelAreaLength \u00b6 Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.arm.text.RoutineSeparatorLength \u00b6 Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.arm.text.ShowAddresses \u00b6 Description : Display addresses of items Type and Default : Boolean(true) .parsers.arm.text.ShowBytesCount \u00b6 Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.arm.text.ShowSegmentHeaders \u00b6 Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.arm.text.ShowSpaceBetweenBlocks \u00b6 Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.arm64.AdvancedAnalysisRoutineCountWarning \u00b6 Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+} .parsers.arm64.AllowAdvancedAnalysis \u00b6 Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false) .parsers.arm64.AnalysisStyle \u00b6 Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4} .parsers.arm64.DebugInformationRetrievalPolicy \u00b6 Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2} .parsers.arm64.DebugInformationUsagePolicy \u00b6 Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2} .parsers.arm64.PerformClassRecovery \u00b6 Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false) .parsers.arm64.PerformGlobalAnalysis \u00b6 Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.arm64.PreferSynchronousExecution \u00b6 Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false) .parsers.arm64.WantedEndianness \u00b6 Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\") .parsers.arm64.WantedImageBase \u00b6 Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\") .parsers.arm64.text.BlockXrefsCount \u00b6 Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.arm64.text.CharBreak64BitAddresses \u00b6 Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.arm64.text.GapPreferRawFormatting \u00b6 Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false) .parsers.arm64.text.GapRawBytesPerLine \u00b6 Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.arm64.text.GapRawIntegerSize \u00b6 Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.arm64.text.InstructionAreaLength \u00b6 Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.arm64.text.LabelAreaLength \u00b6 Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.arm64.text.RoutineSeparatorLength \u00b6 Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.arm64.text.ShowAddresses \u00b6 Description : Display addresses of items Type and Default : Boolean(true) .parsers.arm64.text.ShowBytesCount \u00b6 Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.arm64.text.ShowSegmentHeaders \u00b6 Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.arm64.text.ShowSpaceBetweenBlocks \u00b6 Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.armT32.AdvancedAnalysisRoutineCountWarning \u00b6 Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+} .parsers.armT32.AllowAdvancedAnalysis \u00b6 Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false) .parsers.armT32.AnalysisStyle \u00b6 Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4} .parsers.armT32.DebugInformationRetrievalPolicy \u00b6 Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2} .parsers.armT32.DebugInformationUsagePolicy \u00b6 Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2} .parsers.armT32.PerformClassRecovery \u00b6 Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false) .parsers.armT32.PerformGlobalAnalysis \u00b6 Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.armT32.PreferSynchronousExecution \u00b6 Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false) .parsers.armT32.WantedEndianness \u00b6 Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\") .parsers.armT32.WantedImageBase \u00b6 Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\") .parsers.armT32.text.BlockXrefsCount \u00b6 Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.armT32.text.CharBreak64BitAddresses \u00b6 Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.armT32.text.GapPreferRawFormatting \u00b6 Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false) .parsers.armT32.text.GapRawBytesPerLine \u00b6 Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.armT32.text.GapRawIntegerSize \u00b6 Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.armT32.text.InstructionAreaLength \u00b6 Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.armT32.text.LabelAreaLength \u00b6 Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.armT32.text.RoutineSeparatorLength \u00b6 Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.armT32.text.ShowAddresses \u00b6 Description : Display addresses of items Type and Default : Boolean(true) .parsers.armT32.text.ShowBytesCount \u00b6 Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.armT32.text.ShowSegmentHeaders \u00b6 Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.armT32.text.ShowSpaceBetweenBlocks \u00b6 Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.avr.AdvancedAnalysisRoutineCountWarning \u00b6 Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+} .parsers.avr.AllowAdvancedAnalysis \u00b6 Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false) .parsers.avr.AnalysisStyle \u00b6 Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4} .parsers.avr.DebugInformationRetrievalPolicy \u00b6 Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2} .parsers.avr.DebugInformationUsagePolicy \u00b6 Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2} .parsers.avr.PerformClassRecovery \u00b6 Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false) .parsers.avr.PerformGlobalAnalysis \u00b6 Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.avr.PreferSynchronousExecution \u00b6 Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false) .parsers.avr.WantedEndianness \u00b6 Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\") .parsers.avr.WantedImageBase \u00b6 Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\") .parsers.avr.text.BlockXrefsCount \u00b6 Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.avr.text.CharBreak64BitAddresses \u00b6 Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.avr.text.GapPreferRawFormatting \u00b6 Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false) .parsers.avr.text.GapRawBytesPerLine \u00b6 Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.avr.text.GapRawIntegerSize \u00b6 Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.avr.text.InstructionAreaLength \u00b6 Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.avr.text.LabelAreaLength \u00b6 Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.avr.text.RoutineSeparatorLength \u00b6 Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.avr.text.ShowAddresses \u00b6 Description : Display addresses of items Type and Default : Boolean(true) .parsers.avr.text.ShowBytesCount \u00b6 Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.avr.text.ShowSegmentHeaders \u00b6 Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.avr.text.ShowSpaceBetweenBlocks \u00b6 Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.dbug_apk.AttachPortRangeSize \u00b6 Description : Number of ports to try after the preferred port if the preferred port is in useby another program Type and Default : Integer(20){1-100} .parsers.dbug_apk.AttachPortRangeStart \u00b6 Description : Preferred TCP port to use and listen to when attaching to the JDWP debugger Type and Default : Integer(8900){1024-65535} .parsers.dbug_apk.BlockingQueryTimeoutSeconds \u00b6 Description : Maximum time in seconds to wait for a response from the debugger server Type and Default : Integer(15){0+} .parsers.dbug_apk.NativeAttachPortRangeSize \u00b6 Description : Number of ports to try after the preferred port if the preferred port is in useby another program Type and Default : Integer(20){1-100} .parsers.dbug_apk.NativeAttachPortRangeStart \u00b6 Description : Preferred TCP port to use and listen to when attaching to the native debugger Type and Default : Integer(8950){1024-65535} .parsers.dbug_apk.PreferLldbserver \u00b6 Description : Prefer the use of LLDB server over GDB server for debugging native Android code. Type and Default : Boolean(true) .parsers.dbug_apk.PreferredGdbserverVersion \u00b6 Description : Preferred GDB server version to use. JEB does not ship with all versions of GDB server for all platforms. See the core/assets/ folder in your jeb.jar software archive.It is recommended to use the default. Type and Default : String(\"\") .parsers.dbug_apk.PreferredLldbserverVersion \u00b6 Description : Preferred LLDB server version to use. JEB does not ship with all versions of LLDB server for all platforms. See the core/assets/ folder in your jeb.jar software archive.It is recommended to use the default. Type and Default : String(\"\") .parsers.dbug_apk.UseNativeDebugger \u00b6 Description : If the client does not provide this information, this setting is used to determine whether the native debugger should be used as well. Use DEFAULT to let JEB choose (which will result in a yes if and only if a native library folder containing SO files exist), else use ALWAYS or NEVER. Type and Default : String(\"DEFAULT\") .parsers.dbug_elf.BlockingQueryTimeoutSeconds \u00b6 Description : Maximum time in seconds to wait for a response from the debugger server Type and Default : Integer(15){0+} .parsers.dcmp_arm.ASTOptimizerMaxRunCount \u00b6 Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.dcmp_arm.FailOnPipelineError \u00b6 Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true) .parsers.dcmp_arm.IROptimizerDisableAggressivePass \u00b6 Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false) .parsers.dcmp_arm.IROptimizerMaxRunCount \u00b6 Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5) .parsers.dcmp_arm.MemoryResolutionPolicy \u00b6 Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2) .parsers.dcmp_arm.ReconversionMaxCount \u00b6 Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+} .parsers.dcmp_arm.StructurerUseVersion \u00b6 Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3} .parsers.dcmp_arm.UseFriendlyVariableNames \u00b6 Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true) .parsers.dcmp_arm.UseSSAForm \u00b6 Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false) .parsers.dcmp_arm.text.MergeAdjacentDefinitions \u00b6 Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true) .parsers.dcmp_arm.text.SpaceOutCompounds \u00b6 Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.dcmp_arm64.ASTOptimizerMaxRunCount \u00b6 Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.dcmp_arm64.FailOnPipelineError \u00b6 Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true) .parsers.dcmp_arm64.IROptimizerDisableAggressivePass \u00b6 Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false) .parsers.dcmp_arm64.IROptimizerMaxRunCount \u00b6 Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5) .parsers.dcmp_arm64.MemoryResolutionPolicy \u00b6 Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2) .parsers.dcmp_arm64.ReconversionMaxCount \u00b6 Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+} .parsers.dcmp_arm64.StructurerUseVersion \u00b6 Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3} .parsers.dcmp_arm64.UseFriendlyVariableNames \u00b6 Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true) .parsers.dcmp_arm64.UseSSAForm \u00b6 Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false) .parsers.dcmp_arm64.text.MergeAdjacentDefinitions \u00b6 Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true) .parsers.dcmp_arm64.text.SpaceOutCompounds \u00b6 Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.dcmp_avr.ASTOptimizerMaxRunCount \u00b6 Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.dcmp_avr.FailOnPipelineError \u00b6 Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true) .parsers.dcmp_avr.IROptimizerDisableAggressivePass \u00b6 Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false) .parsers.dcmp_avr.IROptimizerMaxRunCount \u00b6 Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5) .parsers.dcmp_avr.MemoryResolutionPolicy \u00b6 Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2) .parsers.dcmp_avr.ReconversionMaxCount \u00b6 Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+} .parsers.dcmp_avr.StructurerUseVersion \u00b6 Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3} .parsers.dcmp_avr.UseFriendlyVariableNames \u00b6 Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true) .parsers.dcmp_avr.UseSSAForm \u00b6 Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false) .parsers.dcmp_avr.text.MergeAdjacentDefinitions \u00b6 Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true) .parsers.dcmp_avr.text.SpaceOutCompounds \u00b6 Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.dcmp_dex.AggressiveSubstitutions \u00b6 Description : IR optimization: Allow aggressive (potentially unsafe) substitutions Type and Default : Boolean(true) .parsers.dcmp_dex.FullCFGSubstitutionsInsnCountThreshold \u00b6 Description : Experimental IR optimization: Allow full-CFG expression propagation for methods having less than threshold instructions (-1 to disable the threshold and enable for all methods regardless of their size) Type and Default : Integer(100) .parsers.dcmp_dex.IdentifierNamingStrategy \u00b6 Description : Naming strategy for the identifiers: 0= reflect underlying register usage as much as possible: argN, vN, vN_x 1= derive names from types Type and Default : Integer(0) .parsers.dcmp_dex.JarLibraryClasspath \u00b6 Description : A classpath containing Java classfiles to be used to support the decompiler. Refer to JarLibraryEnabled. If non-empty, this classpath takes precedence over JarLibraryFolder. Type and Default : String(\"\") .parsers.dcmp_dex.JarLibraryEnabled \u00b6 Description : Enable external Java library file parsing. They can be used by the decompiler to achieve better typing (cast reduction). To activate, enable this property and set either one of JarLibraryClasspath or JarLibraryFolder property. Type and Default : Boolean(true) .parsers.dcmp_dex.JarLibraryFolder \u00b6 Description : A folder containing Jar library files to be used to support the decompiler. Refer to JarLibraryEnabled. The default value (empty) means to use the folder ~/.jeb-android-libraries, which always contains a recent copy of the Android framework (android.jar). You may change the value to point to another folder, or drop additional jars in this folder.Note that JarLibraryClasspath takes precedence over this value. Type and Default : String(\"\") .parsers.dcmp_dex.MethodDecompilationTimeout \u00b6 Description : Maximum time in seconds allowed for a method decompilation (use 0 to specify no time-out) Type and Default : Integer(0){0+} .parsers.dcmp_dex.OptimizeCreateConditionalAssignments \u00b6 Description : AST optimization: allow condition assignments (using the ternary operator) Type and Default : Boolean(true) .parsers.dcmp_dex.OptimizeCreateFinallyBlocks \u00b6 Description : AST optimization: attempt to create try-(catch,multi-catch)-finally blocks. This heuristic is potentially unsafe. Type and Default : Boolean(true) .parsers.dcmp_dex.OptimizeCreateForLoops \u00b6 Description : AST optimization: Allow the creation of for-loops Type and Default : Boolean(true) .parsers.dcmp_dex.OptimizeCreateMultiDimArrays \u00b6 Description : AST optimization: allow the creation of multi-dimensional arrays Type and Default : Boolean(true) .parsers.dcmp_dex.OptimizeCreateStringSwitches \u00b6 Description : AST optimization: attempt to create switch-on-strings. This heuristic is potentially unsafe. Type and Default : Boolean(true) .parsers.dcmp_dex.OptimizeCreateSynchronizedBlocks \u00b6 Description : AST optimization: attempt to create synchronized blocks. This heuristic is potentially unsafe. Type and Default : Boolean(true) .parsers.dcmp_dex.OptimizeCreateVarArgs \u00b6 Description : AST optimization: support the creation of variable-argument methods Type and Default : Boolean(true) .parsers.dcmp_dex.OptimizeInlineSyntheticAccessCalls \u00b6 Description : AST optimization: Inline calls to accessor (synthetic) methods Type and Default : Boolean(true) .parsers.dcmp_dex.OptimizeStringConcatenation \u00b6 Description : AST optimization: Allow String concatenation Type and Default : Boolean(true) .parsers.dcmp_dex.ParseDebugInformation \u00b6 Description : Process debug information. If enabled, debug names can be used to name identifiers. Proceed with caution! DEX metadata is not reliable, it can be forged and/or obfuscated to mislead analysis. Type and Default : Boolean(true) .parsers.dcmp_dex.ParseExceptionBlocks \u00b6 Description : Parse exception blocks Type and Default : Boolean(true) .parsers.dcmp_dex.text.DisplayMethodInternalsAsComment \u00b6 Description : When rendering source, prepend method internals as a comment block before rendering the method (0: none, 1: original method signature, 2: signature + flattened AST rendering) Type and Default : Integer(0) .parsers.dcmp_dex.text.DisplayPrivateMethodsLast \u00b6 Description : Output private methods last (after public, default and protected methods) Type and Default : Boolean(false) .parsers.dcmp_dex.text.GenerateAnnotations \u00b6 Description : Generate Java annotations Type and Default : Boolean(true) .parsers.dcmp_dex.text.GenerateOverrideAnnotations \u00b6 Description : Geneate additional @Override annotations for methods for which super implementations or definitions were found Type and Default : Boolean(true) .parsers.dcmp_dex.text.GenerateSyntheticFields \u00b6 Description : Explicitly generate all synthetic fields Type and Default : Boolean(false) .parsers.dcmp_dex.text.GenerateSyntheticMethods \u00b6 Description : Explicitly generate all synthetic methods Type and Default : Boolean(false) .parsers.dcmp_dex.text.InsertBlankLinesAfterCompounds \u00b6 Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.dcmp_dex.text.ResolveFieldAccessTargets \u00b6 Description : Resolve accesses to object and class fields Type and Default : Boolean(true) .parsers.dcmp_dex.text.ResolveMethodCallTargets \u00b6 Description : Resolve calls to virtual and static methods, possibly offering a list of candidates methods to client code Type and Default : Boolean(true) .parsers.dcmp_dex.text.SortItemsForRendering \u00b6 Description : Sort class, field and method source items before rendering them (0: no sort (rendered as they appear in native code), 1: alphabetically + access type) Type and Default : Integer(1) .parsers.dcmp_dex.text.UseDebugInfoNames \u00b6 Description : Use names located in DEX debug information (if available) Type and Default : Boolean(true) .parsers.dcmp_evmbc.ASTOptimizerMaxRunCount \u00b6 Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.dcmp_evmbc.FailOnPipelineError \u00b6 Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true) .parsers.dcmp_evmbc.IROptimizerDisableAggressivePass \u00b6 Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false) .parsers.dcmp_evmbc.IROptimizerMaxRunCount \u00b6 Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5) .parsers.dcmp_evmbc.MemoryResolutionPolicy \u00b6 Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2) .parsers.dcmp_evmbc.ReconversionMaxCount \u00b6 Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+} .parsers.dcmp_evmbc.StructurerUseVersion \u00b6 Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3} .parsers.dcmp_evmbc.UseFriendlyVariableNames \u00b6 Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(false) .parsers.dcmp_evmbc.UseSSAForm \u00b6 Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false) .parsers.dcmp_evmbc.text.MergeAdjacentDefinitions \u00b6 Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true) .parsers.dcmp_evmbc.text.SpaceOutCompounds \u00b6 Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.dcmp_libravm_bc.ASTOptimizerMaxRunCount \u00b6 Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.dcmp_libravm_bc.FailOnPipelineError \u00b6 Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true) .parsers.dcmp_libravm_bc.IROptimizerDisableAggressivePass \u00b6 Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false) .parsers.dcmp_libravm_bc.IROptimizerMaxRunCount \u00b6 Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5) .parsers.dcmp_libravm_bc.MemoryResolutionPolicy \u00b6 Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2) .parsers.dcmp_libravm_bc.ReconversionMaxCount \u00b6 Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+} .parsers.dcmp_libravm_bc.StructurerUseVersion \u00b6 Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3} .parsers.dcmp_libravm_bc.UseFriendlyVariableNames \u00b6 Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(false) .parsers.dcmp_libravm_bc.UseSSAForm \u00b6 Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false) .parsers.dcmp_libravm_bc.text.MergeAdjacentDefinitions \u00b6 Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true) .parsers.dcmp_libravm_bc.text.SpaceOutCompounds \u00b6 Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.dcmp_mips.ASTOptimizerMaxRunCount \u00b6 Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.dcmp_mips.FailOnPipelineError \u00b6 Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true) .parsers.dcmp_mips.IROptimizerDisableAggressivePass \u00b6 Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false) .parsers.dcmp_mips.IROptimizerMaxRunCount \u00b6 Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5) .parsers.dcmp_mips.MemoryResolutionPolicy \u00b6 Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2) .parsers.dcmp_mips.ReconversionMaxCount \u00b6 Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+} .parsers.dcmp_mips.StructurerUseVersion \u00b6 Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3} .parsers.dcmp_mips.UseFriendlyVariableNames \u00b6 Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true) .parsers.dcmp_mips.UseSSAForm \u00b6 Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false) .parsers.dcmp_mips.text.MergeAdjacentDefinitions \u00b6 Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true) .parsers.dcmp_mips.text.SpaceOutCompounds \u00b6 Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.dcmp_mips64.ASTOptimizerMaxRunCount \u00b6 Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.dcmp_mips64.FailOnPipelineError \u00b6 Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true) .parsers.dcmp_mips64.IROptimizerDisableAggressivePass \u00b6 Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false) .parsers.dcmp_mips64.IROptimizerMaxRunCount \u00b6 Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5) .parsers.dcmp_mips64.MemoryResolutionPolicy \u00b6 Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2) .parsers.dcmp_mips64.ReconversionMaxCount \u00b6 Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+} .parsers.dcmp_mips64.StructurerUseVersion \u00b6 Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3} .parsers.dcmp_mips64.UseFriendlyVariableNames \u00b6 Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true) .parsers.dcmp_mips64.UseSSAForm \u00b6 Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false) .parsers.dcmp_mips64.text.MergeAdjacentDefinitions \u00b6 Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true) .parsers.dcmp_mips64.text.SpaceOutCompounds \u00b6 Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.dcmp_wasmbc.ASTOptimizerMaxRunCount \u00b6 Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.dcmp_wasmbc.FailOnPipelineError \u00b6 Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true) .parsers.dcmp_wasmbc.IROptimizerDisableAggressivePass \u00b6 Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false) .parsers.dcmp_wasmbc.IROptimizerMaxRunCount \u00b6 Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5) .parsers.dcmp_wasmbc.MemoryResolutionPolicy \u00b6 Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2) .parsers.dcmp_wasmbc.ReconversionMaxCount \u00b6 Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+} .parsers.dcmp_wasmbc.StructurerUseVersion \u00b6 Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3} .parsers.dcmp_wasmbc.UseFriendlyVariableNames \u00b6 Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true) .parsers.dcmp_wasmbc.UseSSAForm \u00b6 Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false) .parsers.dcmp_wasmbc.text.MergeAdjacentDefinitions \u00b6 Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true) .parsers.dcmp_wasmbc.text.SpaceOutCompounds \u00b6 Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.dcmp_x86.ASTOptimizerMaxRunCount \u00b6 Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.dcmp_x86.FailOnPipelineError \u00b6 Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true) .parsers.dcmp_x86.IROptimizerDisableAggressivePass \u00b6 Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false) .parsers.dcmp_x86.IROptimizerMaxRunCount \u00b6 Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5) .parsers.dcmp_x86.MemoryResolutionPolicy \u00b6 Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2) .parsers.dcmp_x86.ReconversionMaxCount \u00b6 Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+} .parsers.dcmp_x86.StructurerUseVersion \u00b6 Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3} .parsers.dcmp_x86.UseFriendlyVariableNames \u00b6 Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true) .parsers.dcmp_x86.UseSSAForm \u00b6 Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false) .parsers.dcmp_x86.text.MergeAdjacentDefinitions \u00b6 Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true) .parsers.dcmp_x86.text.SpaceOutCompounds \u00b6 Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.dcmp_x86_64.ASTOptimizerMaxRunCount \u00b6 Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20) .parsers.dcmp_x86_64.FailOnPipelineError \u00b6 Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true) .parsers.dcmp_x86_64.IROptimizerDisableAggressivePass \u00b6 Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false) .parsers.dcmp_x86_64.IROptimizerMaxRunCount \u00b6 Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5) .parsers.dcmp_x86_64.MemoryResolutionPolicy \u00b6 Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2) .parsers.dcmp_x86_64.ReconversionMaxCount \u00b6 Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+} .parsers.dcmp_x86_64.StructurerUseVersion \u00b6 Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3} .parsers.dcmp_x86_64.UseFriendlyVariableNames \u00b6 Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true) .parsers.dcmp_x86_64.UseSSAForm \u00b6 Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false) .parsers.dcmp_x86_64.text.MergeAdjacentDefinitions \u00b6 Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true) .parsers.dcmp_x86_64.text.SpaceOutCompounds \u00b6 Description : Insert blank lines between compounds Type and Default : Boolean(true) .parsers.dex.AndroidJavadocRoot \u00b6 Description : Location of Java/Android API documentation files; by default, local files stored in your Android SDK folder will be preferred over web-based API doc Type and Default : String(\"($ANDROID_HOME/docs|$ANDROID_SDK_HOME/docs|$ANDROID_SDK_ROOT/docs)/reference/;https://developer.android.com/reference/;($JAVA_HOME)/docs/api\") .parsers.dex.DalvikParserMode \u00b6 Description : Dalvik parser mode: 0: Legacy DEX, including odex and extended opcodes (0xFFxx) - designed for DEX <=37 If DEX version >= 38 is detected, the mode will be bumped to 100, 110, or more, automatically 50: ART introduction 100: DEX version 38 (+invoke-polymorphic, +invoke-custom, and variants) 110: DEX version 39 (+const-method-handle, +const-method-type) 1000: Newest, including things that may not be supported in JEB yet Type and Default : Integer(50) .parsers.dex.ParseExtendedOpcodes \u00b6 Description : Support parsing for the extended opcodes Type and Default : Boolean(true) .parsers.dex.ParseOptimizedOpcodes \u00b6 Description : Support parsing for the optimized opcodes Type and Default : Boolean(true) .parsers.dex.VerifyAccessFlags \u00b6 Description : Fail parsing if the access flags of a class, method, or field appear to be illegal Type and Default : Boolean(false) .parsers.dex.VerifyHashes \u00b6 Description : Fail parsing if the DEX Adler checksum is not the expected one Type and Default : Boolean(false) .parsers.dex.VerifyVersion \u00b6 Description : Fail parsing if the DEX version number is not in the range [35, 39] Type and Default : Boolean(false) .parsers.dex.WellKnownLibraryPackages \u00b6 Description : CSL of well-known packages that may not be provided as fully-expanded in code hierarchy tree documents. Use * to prevent auto-expansion for all packages. In practice, the JEB UI client will not auto-expand those packages by default to avoid cluttering the code hierarchy fragment view. Type and Default : String(\"android,androidx,android_src,com.google,java,javax,org.acra,org.json,org.apache\") .parsers.dex.text.ClassSeparatorLength \u00b6 Description : Length of the class separator line in characters Type and Default : Integer(0){0+} .parsers.dex.text.MethodSeparatorLength \u00b6 Description : Length of the method separator line in characters Type and Default : Integer(0){0+} .parsers.dex.text.ShowAddresses \u00b6 Description : Display addresses of items Type and Default : Boolean(true) .parsers.dex.text.ShowAnnotations \u00b6 Description : Show the DEX annotations Type and Default : Boolean(true) .parsers.dex.text.ShowBytecode \u00b6 Description : Display the instruction bytecode Type and Default : Boolean(false) .parsers.dex.text.ShowDebugDirectives \u00b6 Description : Show the debug directives (metadata) Type and Default : Boolean(false) .parsers.dex.text.ShowInstructionsInGaps \u00b6 Description : Parse byte gaps (aka slack space, or unsued data bytes, that can be present of method's body) and display those bytes as Dalvik instructions Type and Default : Boolean(false) .parsers.dex.text.ShowLineNumbers \u00b6 Description : Show the source line numbers (metadata) Type and Default : Boolean(false) .parsers.dex.text.ShowSpaceBetweenBlocks \u00b6 Description : Insert a blank line between basic blocks Type and Default : Boolean(false) .parsers.dex.text.SmaliCompatibility \u00b6 Description : Generate assembly code closer to (sometimes, compatible with) Smali, eg, using fully-qualified names everywhere Type and Default : Boolean(false) .parsers.dex.text.UsePForParameters \u00b6 Description : Use p0,p1,... instead of v0,v1,... for variables Type and Default : Boolean(true) .parsers.evmbc.AdvancedAnalysisRoutineCountWarning \u00b6 Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+} .parsers.evmbc.AllowAdvancedAnalysis \u00b6 Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false) .parsers.evmbc.AnalysisStyle \u00b6 Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4} .parsers.evmbc.DebugInformationRetrievalPolicy \u00b6 Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2} .parsers.evmbc.DebugInformationUsagePolicy \u00b6 Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2} .parsers.evmbc.PerformClassRecovery \u00b6 Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false) .parsers.evmbc.PerformGlobalAnalysis \u00b6 Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.evmbc.PreferSynchronousExecution \u00b6 Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false) .parsers.evmbc.WantedEndianness \u00b6 Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\") .parsers.evmbc.WantedImageBase \u00b6 Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\") .parsers.evmbc.text.BlockXrefsCount \u00b6 Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.evmbc.text.CharBreak64BitAddresses \u00b6 Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.evmbc.text.GapPreferRawFormatting \u00b6 Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false) .parsers.evmbc.text.GapRawBytesPerLine \u00b6 Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.evmbc.text.GapRawIntegerSize \u00b6 Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.evmbc.text.InstructionAreaLength \u00b6 Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.evmbc.text.LabelAreaLength \u00b6 Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.evmbc.text.RoutineSeparatorLength \u00b6 Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.evmbc.text.ShowAddresses \u00b6 Description : Display addresses of items Type and Default : Boolean(true) .parsers.evmbc.text.ShowBytesCount \u00b6 Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.evmbc.text.ShowSegmentHeaders \u00b6 Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.evmbc.text.ShowSpaceBetweenBlocks \u00b6 Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.ihex.BigEndian \u00b6 Description : Set to true to specify big-endian. The default is little-endian, unless a specific processor setting overrides it. Type and Default : Boolean(false) .parsers.ihex.Processor \u00b6 Description : Target processor/microcontroller code: 'x86', 'x86_64', 'arm', 'arm64', 'mips', 'avr', etc. The default is x86 Type and Default : String(\"x86\") .parsers.ihex.WantedImageBase \u00b6 Description : Base address hint. Leave empty to let the plugin decide Type and Default : String(\"\") .parsers.ihex.WantedWordsize \u00b6 Description : Desired wordsize in bits: 8, 16, 32, etc. Leave empty to let the plugin decide by heuristics Type and Default : String(\"\") .parsers.libravm_bc.AdvancedAnalysisRoutineCountWarning \u00b6 Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+} .parsers.libravm_bc.AllowAdvancedAnalysis \u00b6 Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false) .parsers.libravm_bc.AnalysisStyle \u00b6 Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4} .parsers.libravm_bc.DebugInformationRetrievalPolicy \u00b6 Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2} .parsers.libravm_bc.DebugInformationUsagePolicy \u00b6 Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2} .parsers.libravm_bc.PerformClassRecovery \u00b6 Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false) .parsers.libravm_bc.PerformGlobalAnalysis \u00b6 Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.libravm_bc.PreferSynchronousExecution \u00b6 Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false) .parsers.libravm_bc.WantedEndianness \u00b6 Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\") .parsers.libravm_bc.WantedImageBase \u00b6 Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\") .parsers.libravm_bc.text.BlockXrefsCount \u00b6 Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.libravm_bc.text.CharBreak64BitAddresses \u00b6 Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.libravm_bc.text.GapPreferRawFormatting \u00b6 Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false) .parsers.libravm_bc.text.GapRawBytesPerLine \u00b6 Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.libravm_bc.text.GapRawIntegerSize \u00b6 Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.libravm_bc.text.InstructionAreaLength \u00b6 Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.libravm_bc.text.LabelAreaLength \u00b6 Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.libravm_bc.text.RoutineSeparatorLength \u00b6 Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.libravm_bc.text.ShowAddresses \u00b6 Description : Display addresses of items Type and Default : Boolean(true) .parsers.libravm_bc.text.ShowBytesCount \u00b6 Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.libravm_bc.text.ShowSegmentHeaders \u00b6 Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.libravm_bc.text.ShowSpaceBetweenBlocks \u00b6 Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.mips.AdvancedAnalysisRoutineCountWarning \u00b6 Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+} .parsers.mips.AllowAdvancedAnalysis \u00b6 Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false) .parsers.mips.AnalysisStyle \u00b6 Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4} .parsers.mips.DebugInformationRetrievalPolicy \u00b6 Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2} .parsers.mips.DebugInformationUsagePolicy \u00b6 Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2} .parsers.mips.PerformClassRecovery \u00b6 Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false) .parsers.mips.PerformGlobalAnalysis \u00b6 Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.mips.PreferSynchronousExecution \u00b6 Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false) .parsers.mips.WantedEndianness \u00b6 Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\") .parsers.mips.WantedImageBase \u00b6 Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\") .parsers.mips.text.BlockXrefsCount \u00b6 Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.mips.text.CharBreak64BitAddresses \u00b6 Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.mips.text.GapPreferRawFormatting \u00b6 Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false) .parsers.mips.text.GapRawBytesPerLine \u00b6 Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.mips.text.GapRawIntegerSize \u00b6 Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.mips.text.InstructionAreaLength \u00b6 Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.mips.text.LabelAreaLength \u00b6 Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.mips.text.RoutineSeparatorLength \u00b6 Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.mips.text.ShowAddresses \u00b6 Description : Display addresses of items Type and Default : Boolean(true) .parsers.mips.text.ShowBytesCount \u00b6 Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.mips.text.ShowSegmentHeaders \u00b6 Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.mips.text.ShowSpaceBetweenBlocks \u00b6 Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.mips64.AdvancedAnalysisRoutineCountWarning \u00b6 Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+} .parsers.mips64.AllowAdvancedAnalysis \u00b6 Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false) .parsers.mips64.AnalysisStyle \u00b6 Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4} .parsers.mips64.DebugInformationRetrievalPolicy \u00b6 Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2} .parsers.mips64.DebugInformationUsagePolicy \u00b6 Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2} .parsers.mips64.PerformClassRecovery \u00b6 Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false) .parsers.mips64.PerformGlobalAnalysis \u00b6 Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.mips64.PreferSynchronousExecution \u00b6 Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false) .parsers.mips64.WantedEndianness \u00b6 Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\") .parsers.mips64.WantedImageBase \u00b6 Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\") .parsers.mips64.text.BlockXrefsCount \u00b6 Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.mips64.text.CharBreak64BitAddresses \u00b6 Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.mips64.text.GapPreferRawFormatting \u00b6 Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false) .parsers.mips64.text.GapRawBytesPerLine \u00b6 Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.mips64.text.GapRawIntegerSize \u00b6 Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.mips64.text.InstructionAreaLength \u00b6 Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.mips64.text.LabelAreaLength \u00b6 Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.mips64.text.RoutineSeparatorLength \u00b6 Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.mips64.text.ShowAddresses \u00b6 Description : Display addresses of items Type and Default : Boolean(true) .parsers.mips64.text.ShowBytesCount \u00b6 Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.mips64.text.ShowSegmentHeaders \u00b6 Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.mips64.text.ShowSpaceBetweenBlocks \u00b6 Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.wasmbc.AdvancedAnalysisRoutineCountWarning \u00b6 Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+} .parsers.wasmbc.AllowAdvancedAnalysis \u00b6 Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false) .parsers.wasmbc.AnalysisStyle \u00b6 Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4} .parsers.wasmbc.DebugInformationRetrievalPolicy \u00b6 Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2} .parsers.wasmbc.DebugInformationUsagePolicy \u00b6 Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2} .parsers.wasmbc.PerformClassRecovery \u00b6 Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false) .parsers.wasmbc.PerformGlobalAnalysis \u00b6 Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.wasmbc.PreferSynchronousExecution \u00b6 Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false) .parsers.wasmbc.WantedEndianness \u00b6 Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\") .parsers.wasmbc.WantedImageBase \u00b6 Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\") .parsers.wasmbc.text.BlockXrefsCount \u00b6 Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.wasmbc.text.CharBreak64BitAddresses \u00b6 Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.wasmbc.text.GapPreferRawFormatting \u00b6 Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false) .parsers.wasmbc.text.GapRawBytesPerLine \u00b6 Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.wasmbc.text.GapRawIntegerSize \u00b6 Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.wasmbc.text.InstructionAreaLength \u00b6 Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.wasmbc.text.LabelAreaLength \u00b6 Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.wasmbc.text.RoutineSeparatorLength \u00b6 Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.wasmbc.text.ShowAddresses \u00b6 Description : Display addresses of items Type and Default : Boolean(true) .parsers.wasmbc.text.ShowBytesCount \u00b6 Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.wasmbc.text.ShowSegmentHeaders \u00b6 Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.wasmbc.text.ShowSpaceBetweenBlocks \u00b6 Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.x86.AdvancedAnalysisRoutineCountWarning \u00b6 Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+} .parsers.x86.AllowAdvancedAnalysis \u00b6 Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false) .parsers.x86.AnalysisStyle \u00b6 Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4} .parsers.x86.DebugInformationRetrievalPolicy \u00b6 Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2} .parsers.x86.DebugInformationUsagePolicy \u00b6 Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2} .parsers.x86.PerformClassRecovery \u00b6 Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false) .parsers.x86.PerformGlobalAnalysis \u00b6 Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.x86.PreferSynchronousExecution \u00b6 Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false) .parsers.x86.WantedEndianness \u00b6 Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\") .parsers.x86.WantedImageBase \u00b6 Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\") .parsers.x86.text.BlockXrefsCount \u00b6 Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.x86.text.CharBreak64BitAddresses \u00b6 Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.x86.text.GapPreferRawFormatting \u00b6 Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false) .parsers.x86.text.GapRawBytesPerLine \u00b6 Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.x86.text.GapRawIntegerSize \u00b6 Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.x86.text.InstructionAreaLength \u00b6 Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.x86.text.LabelAreaLength \u00b6 Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.x86.text.RoutineSeparatorLength \u00b6 Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.x86.text.ShowAddresses \u00b6 Description : Display addresses of items Type and Default : Boolean(true) .parsers.x86.text.ShowBytesCount \u00b6 Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.x86.text.ShowSegmentHeaders \u00b6 Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.x86.text.ShowSpaceBetweenBlocks \u00b6 Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .parsers.x86_64.AdvancedAnalysisRoutineCountWarning \u00b6 Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+} .parsers.x86_64.AllowAdvancedAnalysis \u00b6 Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false) .parsers.x86_64.AnalysisStyle \u00b6 Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4} .parsers.x86_64.DebugInformationRetrievalPolicy \u00b6 Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2} .parsers.x86_64.DebugInformationUsagePolicy \u00b6 Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2} .parsers.x86_64.PerformClassRecovery \u00b6 Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false) .parsers.x86_64.PerformGlobalAnalysis \u00b6 Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false) .parsers.x86_64.PreferSynchronousExecution \u00b6 Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false) .parsers.x86_64.WantedEndianness \u00b6 Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\") .parsers.x86_64.WantedImageBase \u00b6 Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\") .parsers.x86_64.text.BlockXrefsCount \u00b6 Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50) .parsers.x86_64.text.CharBreak64BitAddresses \u00b6 Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\") .parsers.x86_64.text.GapPreferRawFormatting \u00b6 Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false) .parsers.x86_64.text.GapRawBytesPerLine \u00b6 Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+} .parsers.x86_64.text.GapRawIntegerSize \u00b6 Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+} .parsers.x86_64.text.InstructionAreaLength \u00b6 Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+} .parsers.x86_64.text.LabelAreaLength \u00b6 Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+} .parsers.x86_64.text.RoutineSeparatorLength \u00b6 Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+} .parsers.x86_64.text.ShowAddresses \u00b6 Description : Display addresses of items Type and Default : Boolean(true) .parsers.x86_64.text.ShowBytesCount \u00b6 Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+} .parsers.x86_64.text.ShowSegmentHeaders \u00b6 Description : Display the segment or section headers Type and Default : Boolean(true) .parsers.x86_64.text.ShowSpaceBetweenBlocks \u00b6 Description : Insert blank lines between basic blocks Type and Default : Boolean(false) .project.AlwaysProcessDuplicateInputs \u00b6 Description : Always process binary inputs even if that input was seen earlier and processed as another unit already Type and Default : Boolean(false) .project.ArtifactProcessingDepth \u00b6 Description : Determine the maximum depth an input artifact (eg, a file) will be explored to create units and sub-units representing analysis entities Type and Default : Integer(20){1+} .project.CompressPersistedProject \u00b6 Description : Compress the JDB2 database (recommended) Type and Default : Boolean(true) .project.PersistenceStrategy \u00b6 Description : Determine how a project will be saved to JDB2: 0: default (full save) 1: explicit full save 2: quick save Type and Default : Integer(0){0-2}","title":"Engines Configuration"},{"location":"engines-configuration.html#engines-configuration","text":"JEB clients store the JEB engines configuration , also known as the back-end configuration, in the bin/jeb-engines.cfg . The configuration file is a key-value store where keys are fully-qualified identifiers that start with a leading dot. This file contains general back-end settings as well as the settings of common plugins shipping with most distributions of JEB. Each plugin has its own sub-namespace ( .PluginType ) within the .parsers namespace. Keys pertaining to document rendering are stored in a sub-region named .text . The public keys can safely be changed by a user. They are accessible in the Options dialog, Advanced mode, panel Engines . The engines configuration acts as a template for your projects' settings. Once a project is loaded, an additional tab named Project-Specific allows the user to modify the back-end settings of the project only, without changing the global back-end settings. )","title":"Engines Configuration"},{"location":"engines-configuration.html#databasebackupbeforesave","text":"Description : Before saving a project to JDB2, the current JDB2 database is copied to the %TEMP% folder and will be used as backup is any problem showed up during saving. Type and Default : Boolean(true)","title":".DatabaseBackupBeforeSave"},{"location":"engines-configuration.html#devpluginclassnames","text":"Description : Classnames of your in-development plugin entry-point classes (they are not JARs) Type and Default : String(\"\")","title":".DevPluginClassnames"},{"location":"engines-configuration.html#devpluginclasspath","text":"Description : Classpath for your in-development plugins (they are not JARs) Type and Default : String(\"\")","title":".DevPluginClasspath"},{"location":"engines-configuration.html#loadpythonplugins","text":"Description : Specify whether or not JEB back-end plugins written in Python are allowed and should be loaded Type and Default : Boolean(true)","title":".LoadPythonPlugins"},{"location":"engines-configuration.html#networkproxy","text":"Description : Network proxy settings for JEB back-end components. The format of this property is: 'protocol|hostname|port|user|pass'. Protocol can be http or socks. User and password are optional (needed only if your proxy requires authentication) Type and Default : String(\"\")","title":".NetworkProxy"},{"location":"engines-configuration.html#pluginsfolder","text":"Description : Location of the JEB back-end plugins folder Type and Default : String(\"$JEB_HOME/coreplugins\")","title":".PluginsFolder"},{"location":"engines-configuration.html#siglibsautoloadpackages","text":"Description : Specify whether or not signature libraries should be automatically loaded when target file is deemed suitable Type and Default : Boolean(true)","title":".SiglibsAutoLoadPackages"},{"location":"engines-configuration.html#siglibsautomodesavecount","text":"Description : Number of signatures that need to be created before saving to a signature package; if 0 the package is not saved by this manager Type and Default : Integer(10)","title":".SiglibsAutoModeSaveCount"},{"location":"engines-configuration.html#siglibsfolder","text":"Description : Folder containing native code signature libraries Type and Default : String(\"$JEB_HOME/siglibs\")","title":".SiglibsFolder"},{"location":"engines-configuration.html#typelibsfolder","text":"Description : Folder containing native type libraries Type and Default : String(\"$JEB_HOME/typelibs\")","title":".TypelibsFolder"},{"location":"engines-configuration.html#parsersenforceversionchecks","text":"Description : Verify that the plugins's requirements in terms for JEB are met. Ex: if enabled, a plugin requiring JEB [2.3.10, 3.0.7] will not be loaded if JEB is older than 2.3.10 or newer than 3.0.7 Type and Default : Boolean(true)","title":".parsers.EnforceVersionChecks"},{"location":"engines-configuration.html#parsersapkandroidjavadocroot","text":"Description : Location of Java/Android API documentation files; by default, local files stored in your Android SDK folder will be preferred over web-based API doc Type and Default : String(\"($ANDROID_HOME/docs|$ANDROID_SDK_HOME/docs|$ANDROID_SDK_ROOT/docs)/reference/;https://developer.android.com/reference/;($JAVA_HOME)/docs/api\")","title":".parsers.apk.AndroidJavadocRoot"},{"location":"engines-configuration.html#parsersapkdisableassetsprocessingthreshold","text":"Description : The plugin will suggest disabling the auto-processing of APK assets if the number of asset files exceed that threshold (0 to disable) Type and Default : Integer(300){0+}","title":".parsers.apk.DisableAssetsProcessingThreshold"},{"location":"engines-configuration.html#parsersapkdisableresourcesprocessingthreshold","text":"Description : The plugin will suggest disabling the auto-processing of APK resources if the number of resource files exceed that threshold (0 to disable) Type and Default : Integer(500){0+}","title":".parsers.apk.DisableResourcesProcessingThreshold"},{"location":"engines-configuration.html#parsersapkframeworksdirectory","text":"Description : Directory containing additional frameworks. Leave empty to use the default, which is the '.jeb-android-frameworks' directory in your Home folder Type and Default : Path(\"\")","title":".parsers.apk.FrameworksDirectory"},{"location":"engines-configuration.html#parsersapkgenerateaapt2output","text":"Description : Tick to generate an additional text fragment that will describe the APK resources similarly to AAPT2's output Type and Default : Boolean(false)","title":".parsers.apk.GenerateAapt2Output"},{"location":"engines-configuration.html#parsersapkmergemultidex","text":"Description : Attempt to merge the DEX files of a multi-DEX APK into a single, unified DEX unit Type and Default : Boolean(true)","title":".parsers.apk.MergeMultiDex"},{"location":"engines-configuration.html#parsersapkprocessassets","text":"Description : Process files in the APK's Assets directory Type and Default : Boolean(true)","title":".parsers.apk.ProcessAssets"},{"location":"engines-configuration.html#parsersapkprocessbytecode","text":"Description : Process the Dalvik bytecode (classes[N].dex) Type and Default : Boolean(true)","title":".parsers.apk.ProcessBytecode"},{"location":"engines-configuration.html#parsersapkprocesscertificates","text":"Description : Process the APK's certificates data (legacy, v1, and v2) Type and Default : Boolean(true)","title":".parsers.apk.ProcessCertificates"},{"location":"engines-configuration.html#parsersapkprocesslibraries","text":"Description : Process native code (.so) libraries Type and Default : Boolean(true)","title":".parsers.apk.ProcessLibraries"},{"location":"engines-configuration.html#parsersapkprocessmanifest","text":"Description : Decode and process the APK Manifest Type and Default : Boolean(true)","title":".parsers.apk.ProcessManifest"},{"location":"engines-configuration.html#parsersapkprocessresources","text":"Description : Decode and process the Resources (if this option is true, the Manifest is always processed) Type and Default : Boolean(true)","title":".parsers.apk.ProcessResources"},{"location":"engines-configuration.html#parsersarmadvancedanalysisroutinecountwarning","text":"Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+}","title":".parsers.arm.AdvancedAnalysisRoutineCountWarning"},{"location":"engines-configuration.html#parsersarmallowadvancedanalysis","text":"Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false)","title":".parsers.arm.AllowAdvancedAnalysis"},{"location":"engines-configuration.html#parsersarmanalysisstyle","text":"Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4}","title":".parsers.arm.AnalysisStyle"},{"location":"engines-configuration.html#parsersarmdebuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2}","title":".parsers.arm.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parsersarmdebuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2}","title":".parsers.arm.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parsersarmperformclassrecovery","text":"Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false)","title":".parsers.arm.PerformClassRecovery"},{"location":"engines-configuration.html#parsersarmperformglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.arm.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parsersarmprefersynchronousexecution","text":"Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false)","title":".parsers.arm.PreferSynchronousExecution"},{"location":"engines-configuration.html#parsersarmwantedendianness","text":"Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\")","title":".parsers.arm.WantedEndianness"},{"location":"engines-configuration.html#parsersarmwantedimagebase","text":"Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\")","title":".parsers.arm.WantedImageBase"},{"location":"engines-configuration.html#parsersarmtextblockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.arm.text.BlockXrefsCount"},{"location":"engines-configuration.html#parsersarmtextcharbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.arm.text.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parsersarmtextgappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false)","title":".parsers.arm.text.GapPreferRawFormatting"},{"location":"engines-configuration.html#parsersarmtextgaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.arm.text.GapRawBytesPerLine"},{"location":"engines-configuration.html#parsersarmtextgaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.arm.text.GapRawIntegerSize"},{"location":"engines-configuration.html#parsersarmtextinstructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.arm.text.InstructionAreaLength"},{"location":"engines-configuration.html#parsersarmtextlabelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.arm.text.LabelAreaLength"},{"location":"engines-configuration.html#parsersarmtextroutineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.arm.text.RoutineSeparatorLength"},{"location":"engines-configuration.html#parsersarmtextshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.arm.text.ShowAddresses"},{"location":"engines-configuration.html#parsersarmtextshowbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.arm.text.ShowBytesCount"},{"location":"engines-configuration.html#parsersarmtextshowsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.arm.text.ShowSegmentHeaders"},{"location":"engines-configuration.html#parsersarmtextshowspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.arm.text.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersarm64advancedanalysisroutinecountwarning","text":"Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+}","title":".parsers.arm64.AdvancedAnalysisRoutineCountWarning"},{"location":"engines-configuration.html#parsersarm64allowadvancedanalysis","text":"Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false)","title":".parsers.arm64.AllowAdvancedAnalysis"},{"location":"engines-configuration.html#parsersarm64analysisstyle","text":"Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4}","title":".parsers.arm64.AnalysisStyle"},{"location":"engines-configuration.html#parsersarm64debuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2}","title":".parsers.arm64.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parsersarm64debuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2}","title":".parsers.arm64.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parsersarm64performclassrecovery","text":"Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false)","title":".parsers.arm64.PerformClassRecovery"},{"location":"engines-configuration.html#parsersarm64performglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.arm64.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parsersarm64prefersynchronousexecution","text":"Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false)","title":".parsers.arm64.PreferSynchronousExecution"},{"location":"engines-configuration.html#parsersarm64wantedendianness","text":"Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\")","title":".parsers.arm64.WantedEndianness"},{"location":"engines-configuration.html#parsersarm64wantedimagebase","text":"Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\")","title":".parsers.arm64.WantedImageBase"},{"location":"engines-configuration.html#parsersarm64textblockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.arm64.text.BlockXrefsCount"},{"location":"engines-configuration.html#parsersarm64textcharbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.arm64.text.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parsersarm64textgappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false)","title":".parsers.arm64.text.GapPreferRawFormatting"},{"location":"engines-configuration.html#parsersarm64textgaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.arm64.text.GapRawBytesPerLine"},{"location":"engines-configuration.html#parsersarm64textgaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.arm64.text.GapRawIntegerSize"},{"location":"engines-configuration.html#parsersarm64textinstructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.arm64.text.InstructionAreaLength"},{"location":"engines-configuration.html#parsersarm64textlabelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.arm64.text.LabelAreaLength"},{"location":"engines-configuration.html#parsersarm64textroutineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.arm64.text.RoutineSeparatorLength"},{"location":"engines-configuration.html#parsersarm64textshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.arm64.text.ShowAddresses"},{"location":"engines-configuration.html#parsersarm64textshowbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.arm64.text.ShowBytesCount"},{"location":"engines-configuration.html#parsersarm64textshowsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.arm64.text.ShowSegmentHeaders"},{"location":"engines-configuration.html#parsersarm64textshowspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.arm64.text.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersarmt32advancedanalysisroutinecountwarning","text":"Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+}","title":".parsers.armT32.AdvancedAnalysisRoutineCountWarning"},{"location":"engines-configuration.html#parsersarmt32allowadvancedanalysis","text":"Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false)","title":".parsers.armT32.AllowAdvancedAnalysis"},{"location":"engines-configuration.html#parsersarmt32analysisstyle","text":"Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4}","title":".parsers.armT32.AnalysisStyle"},{"location":"engines-configuration.html#parsersarmt32debuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2}","title":".parsers.armT32.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parsersarmt32debuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2}","title":".parsers.armT32.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parsersarmt32performclassrecovery","text":"Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false)","title":".parsers.armT32.PerformClassRecovery"},{"location":"engines-configuration.html#parsersarmt32performglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.armT32.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parsersarmt32prefersynchronousexecution","text":"Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false)","title":".parsers.armT32.PreferSynchronousExecution"},{"location":"engines-configuration.html#parsersarmt32wantedendianness","text":"Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\")","title":".parsers.armT32.WantedEndianness"},{"location":"engines-configuration.html#parsersarmt32wantedimagebase","text":"Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\")","title":".parsers.armT32.WantedImageBase"},{"location":"engines-configuration.html#parsersarmt32textblockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.armT32.text.BlockXrefsCount"},{"location":"engines-configuration.html#parsersarmt32textcharbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.armT32.text.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parsersarmt32textgappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false)","title":".parsers.armT32.text.GapPreferRawFormatting"},{"location":"engines-configuration.html#parsersarmt32textgaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.armT32.text.GapRawBytesPerLine"},{"location":"engines-configuration.html#parsersarmt32textgaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.armT32.text.GapRawIntegerSize"},{"location":"engines-configuration.html#parsersarmt32textinstructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.armT32.text.InstructionAreaLength"},{"location":"engines-configuration.html#parsersarmt32textlabelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.armT32.text.LabelAreaLength"},{"location":"engines-configuration.html#parsersarmt32textroutineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.armT32.text.RoutineSeparatorLength"},{"location":"engines-configuration.html#parsersarmt32textshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.armT32.text.ShowAddresses"},{"location":"engines-configuration.html#parsersarmt32textshowbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.armT32.text.ShowBytesCount"},{"location":"engines-configuration.html#parsersarmt32textshowsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.armT32.text.ShowSegmentHeaders"},{"location":"engines-configuration.html#parsersarmt32textshowspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.armT32.text.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersavradvancedanalysisroutinecountwarning","text":"Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+}","title":".parsers.avr.AdvancedAnalysisRoutineCountWarning"},{"location":"engines-configuration.html#parsersavrallowadvancedanalysis","text":"Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false)","title":".parsers.avr.AllowAdvancedAnalysis"},{"location":"engines-configuration.html#parsersavranalysisstyle","text":"Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4}","title":".parsers.avr.AnalysisStyle"},{"location":"engines-configuration.html#parsersavrdebuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2}","title":".parsers.avr.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parsersavrdebuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2}","title":".parsers.avr.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parsersavrperformclassrecovery","text":"Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false)","title":".parsers.avr.PerformClassRecovery"},{"location":"engines-configuration.html#parsersavrperformglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.avr.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parsersavrprefersynchronousexecution","text":"Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false)","title":".parsers.avr.PreferSynchronousExecution"},{"location":"engines-configuration.html#parsersavrwantedendianness","text":"Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\")","title":".parsers.avr.WantedEndianness"},{"location":"engines-configuration.html#parsersavrwantedimagebase","text":"Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\")","title":".parsers.avr.WantedImageBase"},{"location":"engines-configuration.html#parsersavrtextblockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.avr.text.BlockXrefsCount"},{"location":"engines-configuration.html#parsersavrtextcharbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.avr.text.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parsersavrtextgappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false)","title":".parsers.avr.text.GapPreferRawFormatting"},{"location":"engines-configuration.html#parsersavrtextgaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.avr.text.GapRawBytesPerLine"},{"location":"engines-configuration.html#parsersavrtextgaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.avr.text.GapRawIntegerSize"},{"location":"engines-configuration.html#parsersavrtextinstructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.avr.text.InstructionAreaLength"},{"location":"engines-configuration.html#parsersavrtextlabelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.avr.text.LabelAreaLength"},{"location":"engines-configuration.html#parsersavrtextroutineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.avr.text.RoutineSeparatorLength"},{"location":"engines-configuration.html#parsersavrtextshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.avr.text.ShowAddresses"},{"location":"engines-configuration.html#parsersavrtextshowbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.avr.text.ShowBytesCount"},{"location":"engines-configuration.html#parsersavrtextshowsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.avr.text.ShowSegmentHeaders"},{"location":"engines-configuration.html#parsersavrtextshowspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.avr.text.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersdbug_apkattachportrangesize","text":"Description : Number of ports to try after the preferred port if the preferred port is in useby another program Type and Default : Integer(20){1-100}","title":".parsers.dbug_apk.AttachPortRangeSize"},{"location":"engines-configuration.html#parsersdbug_apkattachportrangestart","text":"Description : Preferred TCP port to use and listen to when attaching to the JDWP debugger Type and Default : Integer(8900){1024-65535}","title":".parsers.dbug_apk.AttachPortRangeStart"},{"location":"engines-configuration.html#parsersdbug_apkblockingquerytimeoutseconds","text":"Description : Maximum time in seconds to wait for a response from the debugger server Type and Default : Integer(15){0+}","title":".parsers.dbug_apk.BlockingQueryTimeoutSeconds"},{"location":"engines-configuration.html#parsersdbug_apknativeattachportrangesize","text":"Description : Number of ports to try after the preferred port if the preferred port is in useby another program Type and Default : Integer(20){1-100}","title":".parsers.dbug_apk.NativeAttachPortRangeSize"},{"location":"engines-configuration.html#parsersdbug_apknativeattachportrangestart","text":"Description : Preferred TCP port to use and listen to when attaching to the native debugger Type and Default : Integer(8950){1024-65535}","title":".parsers.dbug_apk.NativeAttachPortRangeStart"},{"location":"engines-configuration.html#parsersdbug_apkpreferlldbserver","text":"Description : Prefer the use of LLDB server over GDB server for debugging native Android code. Type and Default : Boolean(true)","title":".parsers.dbug_apk.PreferLldbserver"},{"location":"engines-configuration.html#parsersdbug_apkpreferredgdbserverversion","text":"Description : Preferred GDB server version to use. JEB does not ship with all versions of GDB server for all platforms. See the core/assets/ folder in your jeb.jar software archive.It is recommended to use the default. Type and Default : String(\"\")","title":".parsers.dbug_apk.PreferredGdbserverVersion"},{"location":"engines-configuration.html#parsersdbug_apkpreferredlldbserverversion","text":"Description : Preferred LLDB server version to use. JEB does not ship with all versions of LLDB server for all platforms. See the core/assets/ folder in your jeb.jar software archive.It is recommended to use the default. Type and Default : String(\"\")","title":".parsers.dbug_apk.PreferredLldbserverVersion"},{"location":"engines-configuration.html#parsersdbug_apkusenativedebugger","text":"Description : If the client does not provide this information, this setting is used to determine whether the native debugger should be used as well. Use DEFAULT to let JEB choose (which will result in a yes if and only if a native library folder containing SO files exist), else use ALWAYS or NEVER. Type and Default : String(\"DEFAULT\")","title":".parsers.dbug_apk.UseNativeDebugger"},{"location":"engines-configuration.html#parsersdbug_elfblockingquerytimeoutseconds","text":"Description : Maximum time in seconds to wait for a response from the debugger server Type and Default : Integer(15){0+}","title":".parsers.dbug_elf.BlockingQueryTimeoutSeconds"},{"location":"engines-configuration.html#parsersdcmp_armastoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.dcmp_arm.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_armfailonpipelineerror","text":"Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true)","title":".parsers.dcmp_arm.FailOnPipelineError"},{"location":"engines-configuration.html#parsersdcmp_armiroptimizerdisableaggressivepass","text":"Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false)","title":".parsers.dcmp_arm.IROptimizerDisableAggressivePass"},{"location":"engines-configuration.html#parsersdcmp_armiroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5)","title":".parsers.dcmp_arm.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_armmemoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2)","title":".parsers.dcmp_arm.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersdcmp_armreconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+}","title":".parsers.dcmp_arm.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersdcmp_armstructureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3}","title":".parsers.dcmp_arm.StructurerUseVersion"},{"location":"engines-configuration.html#parsersdcmp_armusefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true)","title":".parsers.dcmp_arm.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersdcmp_armusessaform","text":"Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false)","title":".parsers.dcmp_arm.UseSSAForm"},{"location":"engines-configuration.html#parsersdcmp_armtextmergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true)","title":".parsers.dcmp_arm.text.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersdcmp_armtextspaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.dcmp_arm.text.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersdcmp_arm64astoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.dcmp_arm64.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_arm64failonpipelineerror","text":"Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true)","title":".parsers.dcmp_arm64.FailOnPipelineError"},{"location":"engines-configuration.html#parsersdcmp_arm64iroptimizerdisableaggressivepass","text":"Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false)","title":".parsers.dcmp_arm64.IROptimizerDisableAggressivePass"},{"location":"engines-configuration.html#parsersdcmp_arm64iroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5)","title":".parsers.dcmp_arm64.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_arm64memoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2)","title":".parsers.dcmp_arm64.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersdcmp_arm64reconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+}","title":".parsers.dcmp_arm64.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersdcmp_arm64structureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3}","title":".parsers.dcmp_arm64.StructurerUseVersion"},{"location":"engines-configuration.html#parsersdcmp_arm64usefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true)","title":".parsers.dcmp_arm64.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersdcmp_arm64usessaform","text":"Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false)","title":".parsers.dcmp_arm64.UseSSAForm"},{"location":"engines-configuration.html#parsersdcmp_arm64textmergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true)","title":".parsers.dcmp_arm64.text.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersdcmp_arm64textspaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.dcmp_arm64.text.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersdcmp_avrastoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.dcmp_avr.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_avrfailonpipelineerror","text":"Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true)","title":".parsers.dcmp_avr.FailOnPipelineError"},{"location":"engines-configuration.html#parsersdcmp_avriroptimizerdisableaggressivepass","text":"Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false)","title":".parsers.dcmp_avr.IROptimizerDisableAggressivePass"},{"location":"engines-configuration.html#parsersdcmp_avriroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5)","title":".parsers.dcmp_avr.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_avrmemoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2)","title":".parsers.dcmp_avr.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersdcmp_avrreconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+}","title":".parsers.dcmp_avr.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersdcmp_avrstructureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3}","title":".parsers.dcmp_avr.StructurerUseVersion"},{"location":"engines-configuration.html#parsersdcmp_avrusefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true)","title":".parsers.dcmp_avr.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersdcmp_avrusessaform","text":"Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false)","title":".parsers.dcmp_avr.UseSSAForm"},{"location":"engines-configuration.html#parsersdcmp_avrtextmergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true)","title":".parsers.dcmp_avr.text.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersdcmp_avrtextspaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.dcmp_avr.text.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersdcmp_dexaggressivesubstitutions","text":"Description : IR optimization: Allow aggressive (potentially unsafe) substitutions Type and Default : Boolean(true)","title":".parsers.dcmp_dex.AggressiveSubstitutions"},{"location":"engines-configuration.html#parsersdcmp_dexfullcfgsubstitutionsinsncountthreshold","text":"Description : Experimental IR optimization: Allow full-CFG expression propagation for methods having less than threshold instructions (-1 to disable the threshold and enable for all methods regardless of their size) Type and Default : Integer(100)","title":".parsers.dcmp_dex.FullCFGSubstitutionsInsnCountThreshold"},{"location":"engines-configuration.html#parsersdcmp_dexidentifiernamingstrategy","text":"Description : Naming strategy for the identifiers: 0= reflect underlying register usage as much as possible: argN, vN, vN_x 1= derive names from types Type and Default : Integer(0)","title":".parsers.dcmp_dex.IdentifierNamingStrategy"},{"location":"engines-configuration.html#parsersdcmp_dexjarlibraryclasspath","text":"Description : A classpath containing Java classfiles to be used to support the decompiler. Refer to JarLibraryEnabled. If non-empty, this classpath takes precedence over JarLibraryFolder. Type and Default : String(\"\")","title":".parsers.dcmp_dex.JarLibraryClasspath"},{"location":"engines-configuration.html#parsersdcmp_dexjarlibraryenabled","text":"Description : Enable external Java library file parsing. They can be used by the decompiler to achieve better typing (cast reduction). To activate, enable this property and set either one of JarLibraryClasspath or JarLibraryFolder property. Type and Default : Boolean(true)","title":".parsers.dcmp_dex.JarLibraryEnabled"},{"location":"engines-configuration.html#parsersdcmp_dexjarlibraryfolder","text":"Description : A folder containing Jar library files to be used to support the decompiler. Refer to JarLibraryEnabled. The default value (empty) means to use the folder ~/.jeb-android-libraries, which always contains a recent copy of the Android framework (android.jar). You may change the value to point to another folder, or drop additional jars in this folder.Note that JarLibraryClasspath takes precedence over this value. Type and Default : String(\"\")","title":".parsers.dcmp_dex.JarLibraryFolder"},{"location":"engines-configuration.html#parsersdcmp_dexmethoddecompilationtimeout","text":"Description : Maximum time in seconds allowed for a method decompilation (use 0 to specify no time-out) Type and Default : Integer(0){0+}","title":".parsers.dcmp_dex.MethodDecompilationTimeout"},{"location":"engines-configuration.html#parsersdcmp_dexoptimizecreateconditionalassignments","text":"Description : AST optimization: allow condition assignments (using the ternary operator) Type and Default : Boolean(true)","title":".parsers.dcmp_dex.OptimizeCreateConditionalAssignments"},{"location":"engines-configuration.html#parsersdcmp_dexoptimizecreatefinallyblocks","text":"Description : AST optimization: attempt to create try-(catch,multi-catch)-finally blocks. This heuristic is potentially unsafe. Type and Default : Boolean(true)","title":".parsers.dcmp_dex.OptimizeCreateFinallyBlocks"},{"location":"engines-configuration.html#parsersdcmp_dexoptimizecreateforloops","text":"Description : AST optimization: Allow the creation of for-loops Type and Default : Boolean(true)","title":".parsers.dcmp_dex.OptimizeCreateForLoops"},{"location":"engines-configuration.html#parsersdcmp_dexoptimizecreatemultidimarrays","text":"Description : AST optimization: allow the creation of multi-dimensional arrays Type and Default : Boolean(true)","title":".parsers.dcmp_dex.OptimizeCreateMultiDimArrays"},{"location":"engines-configuration.html#parsersdcmp_dexoptimizecreatestringswitches","text":"Description : AST optimization: attempt to create switch-on-strings. This heuristic is potentially unsafe. Type and Default : Boolean(true)","title":".parsers.dcmp_dex.OptimizeCreateStringSwitches"},{"location":"engines-configuration.html#parsersdcmp_dexoptimizecreatesynchronizedblocks","text":"Description : AST optimization: attempt to create synchronized blocks. This heuristic is potentially unsafe. Type and Default : Boolean(true)","title":".parsers.dcmp_dex.OptimizeCreateSynchronizedBlocks"},{"location":"engines-configuration.html#parsersdcmp_dexoptimizecreatevarargs","text":"Description : AST optimization: support the creation of variable-argument methods Type and Default : Boolean(true)","title":".parsers.dcmp_dex.OptimizeCreateVarArgs"},{"location":"engines-configuration.html#parsersdcmp_dexoptimizeinlinesyntheticaccesscalls","text":"Description : AST optimization: Inline calls to accessor (synthetic) methods Type and Default : Boolean(true)","title":".parsers.dcmp_dex.OptimizeInlineSyntheticAccessCalls"},{"location":"engines-configuration.html#parsersdcmp_dexoptimizestringconcatenation","text":"Description : AST optimization: Allow String concatenation Type and Default : Boolean(true)","title":".parsers.dcmp_dex.OptimizeStringConcatenation"},{"location":"engines-configuration.html#parsersdcmp_dexparsedebuginformation","text":"Description : Process debug information. If enabled, debug names can be used to name identifiers. Proceed with caution! DEX metadata is not reliable, it can be forged and/or obfuscated to mislead analysis. Type and Default : Boolean(true)","title":".parsers.dcmp_dex.ParseDebugInformation"},{"location":"engines-configuration.html#parsersdcmp_dexparseexceptionblocks","text":"Description : Parse exception blocks Type and Default : Boolean(true)","title":".parsers.dcmp_dex.ParseExceptionBlocks"},{"location":"engines-configuration.html#parsersdcmp_dextextdisplaymethodinternalsascomment","text":"Description : When rendering source, prepend method internals as a comment block before rendering the method (0: none, 1: original method signature, 2: signature + flattened AST rendering) Type and Default : Integer(0)","title":".parsers.dcmp_dex.text.DisplayMethodInternalsAsComment"},{"location":"engines-configuration.html#parsersdcmp_dextextdisplayprivatemethodslast","text":"Description : Output private methods last (after public, default and protected methods) Type and Default : Boolean(false)","title":".parsers.dcmp_dex.text.DisplayPrivateMethodsLast"},{"location":"engines-configuration.html#parsersdcmp_dextextgenerateannotations","text":"Description : Generate Java annotations Type and Default : Boolean(true)","title":".parsers.dcmp_dex.text.GenerateAnnotations"},{"location":"engines-configuration.html#parsersdcmp_dextextgenerateoverrideannotations","text":"Description : Geneate additional @Override annotations for methods for which super implementations or definitions were found Type and Default : Boolean(true)","title":".parsers.dcmp_dex.text.GenerateOverrideAnnotations"},{"location":"engines-configuration.html#parsersdcmp_dextextgeneratesyntheticfields","text":"Description : Explicitly generate all synthetic fields Type and Default : Boolean(false)","title":".parsers.dcmp_dex.text.GenerateSyntheticFields"},{"location":"engines-configuration.html#parsersdcmp_dextextgeneratesyntheticmethods","text":"Description : Explicitly generate all synthetic methods Type and Default : Boolean(false)","title":".parsers.dcmp_dex.text.GenerateSyntheticMethods"},{"location":"engines-configuration.html#parsersdcmp_dextextinsertblanklinesaftercompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.dcmp_dex.text.InsertBlankLinesAfterCompounds"},{"location":"engines-configuration.html#parsersdcmp_dextextresolvefieldaccesstargets","text":"Description : Resolve accesses to object and class fields Type and Default : Boolean(true)","title":".parsers.dcmp_dex.text.ResolveFieldAccessTargets"},{"location":"engines-configuration.html#parsersdcmp_dextextresolvemethodcalltargets","text":"Description : Resolve calls to virtual and static methods, possibly offering a list of candidates methods to client code Type and Default : Boolean(true)","title":".parsers.dcmp_dex.text.ResolveMethodCallTargets"},{"location":"engines-configuration.html#parsersdcmp_dextextsortitemsforrendering","text":"Description : Sort class, field and method source items before rendering them (0: no sort (rendered as they appear in native code), 1: alphabetically + access type) Type and Default : Integer(1)","title":".parsers.dcmp_dex.text.SortItemsForRendering"},{"location":"engines-configuration.html#parsersdcmp_dextextusedebuginfonames","text":"Description : Use names located in DEX debug information (if available) Type and Default : Boolean(true)","title":".parsers.dcmp_dex.text.UseDebugInfoNames"},{"location":"engines-configuration.html#parsersdcmp_evmbcastoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.dcmp_evmbc.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_evmbcfailonpipelineerror","text":"Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true)","title":".parsers.dcmp_evmbc.FailOnPipelineError"},{"location":"engines-configuration.html#parsersdcmp_evmbciroptimizerdisableaggressivepass","text":"Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false)","title":".parsers.dcmp_evmbc.IROptimizerDisableAggressivePass"},{"location":"engines-configuration.html#parsersdcmp_evmbciroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5)","title":".parsers.dcmp_evmbc.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_evmbcmemoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2)","title":".parsers.dcmp_evmbc.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersdcmp_evmbcreconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+}","title":".parsers.dcmp_evmbc.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersdcmp_evmbcstructureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3}","title":".parsers.dcmp_evmbc.StructurerUseVersion"},{"location":"engines-configuration.html#parsersdcmp_evmbcusefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(false)","title":".parsers.dcmp_evmbc.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersdcmp_evmbcusessaform","text":"Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false)","title":".parsers.dcmp_evmbc.UseSSAForm"},{"location":"engines-configuration.html#parsersdcmp_evmbctextmergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true)","title":".parsers.dcmp_evmbc.text.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersdcmp_evmbctextspaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.dcmp_evmbc.text.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersdcmp_libravm_bcastoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.dcmp_libravm_bc.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_libravm_bcfailonpipelineerror","text":"Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true)","title":".parsers.dcmp_libravm_bc.FailOnPipelineError"},{"location":"engines-configuration.html#parsersdcmp_libravm_bciroptimizerdisableaggressivepass","text":"Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false)","title":".parsers.dcmp_libravm_bc.IROptimizerDisableAggressivePass"},{"location":"engines-configuration.html#parsersdcmp_libravm_bciroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5)","title":".parsers.dcmp_libravm_bc.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_libravm_bcmemoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2)","title":".parsers.dcmp_libravm_bc.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersdcmp_libravm_bcreconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+}","title":".parsers.dcmp_libravm_bc.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersdcmp_libravm_bcstructureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3}","title":".parsers.dcmp_libravm_bc.StructurerUseVersion"},{"location":"engines-configuration.html#parsersdcmp_libravm_bcusefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(false)","title":".parsers.dcmp_libravm_bc.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersdcmp_libravm_bcusessaform","text":"Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false)","title":".parsers.dcmp_libravm_bc.UseSSAForm"},{"location":"engines-configuration.html#parsersdcmp_libravm_bctextmergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true)","title":".parsers.dcmp_libravm_bc.text.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersdcmp_libravm_bctextspaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.dcmp_libravm_bc.text.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersdcmp_mipsastoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.dcmp_mips.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_mipsfailonpipelineerror","text":"Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true)","title":".parsers.dcmp_mips.FailOnPipelineError"},{"location":"engines-configuration.html#parsersdcmp_mipsiroptimizerdisableaggressivepass","text":"Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false)","title":".parsers.dcmp_mips.IROptimizerDisableAggressivePass"},{"location":"engines-configuration.html#parsersdcmp_mipsiroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5)","title":".parsers.dcmp_mips.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_mipsmemoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2)","title":".parsers.dcmp_mips.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersdcmp_mipsreconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+}","title":".parsers.dcmp_mips.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersdcmp_mipsstructureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3}","title":".parsers.dcmp_mips.StructurerUseVersion"},{"location":"engines-configuration.html#parsersdcmp_mipsusefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true)","title":".parsers.dcmp_mips.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersdcmp_mipsusessaform","text":"Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false)","title":".parsers.dcmp_mips.UseSSAForm"},{"location":"engines-configuration.html#parsersdcmp_mipstextmergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true)","title":".parsers.dcmp_mips.text.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersdcmp_mipstextspaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.dcmp_mips.text.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersdcmp_mips64astoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.dcmp_mips64.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_mips64failonpipelineerror","text":"Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true)","title":".parsers.dcmp_mips64.FailOnPipelineError"},{"location":"engines-configuration.html#parsersdcmp_mips64iroptimizerdisableaggressivepass","text":"Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false)","title":".parsers.dcmp_mips64.IROptimizerDisableAggressivePass"},{"location":"engines-configuration.html#parsersdcmp_mips64iroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5)","title":".parsers.dcmp_mips64.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_mips64memoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2)","title":".parsers.dcmp_mips64.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersdcmp_mips64reconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+}","title":".parsers.dcmp_mips64.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersdcmp_mips64structureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3}","title":".parsers.dcmp_mips64.StructurerUseVersion"},{"location":"engines-configuration.html#parsersdcmp_mips64usefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true)","title":".parsers.dcmp_mips64.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersdcmp_mips64usessaform","text":"Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false)","title":".parsers.dcmp_mips64.UseSSAForm"},{"location":"engines-configuration.html#parsersdcmp_mips64textmergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true)","title":".parsers.dcmp_mips64.text.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersdcmp_mips64textspaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.dcmp_mips64.text.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersdcmp_wasmbcastoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.dcmp_wasmbc.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_wasmbcfailonpipelineerror","text":"Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true)","title":".parsers.dcmp_wasmbc.FailOnPipelineError"},{"location":"engines-configuration.html#parsersdcmp_wasmbciroptimizerdisableaggressivepass","text":"Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false)","title":".parsers.dcmp_wasmbc.IROptimizerDisableAggressivePass"},{"location":"engines-configuration.html#parsersdcmp_wasmbciroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5)","title":".parsers.dcmp_wasmbc.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_wasmbcmemoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2)","title":".parsers.dcmp_wasmbc.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersdcmp_wasmbcreconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+}","title":".parsers.dcmp_wasmbc.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersdcmp_wasmbcstructureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3}","title":".parsers.dcmp_wasmbc.StructurerUseVersion"},{"location":"engines-configuration.html#parsersdcmp_wasmbcusefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true)","title":".parsers.dcmp_wasmbc.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersdcmp_wasmbcusessaform","text":"Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false)","title":".parsers.dcmp_wasmbc.UseSSAForm"},{"location":"engines-configuration.html#parsersdcmp_wasmbctextmergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true)","title":".parsers.dcmp_wasmbc.text.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersdcmp_wasmbctextspaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.dcmp_wasmbc.text.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersdcmp_x86astoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.dcmp_x86.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_x86failonpipelineerror","text":"Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true)","title":".parsers.dcmp_x86.FailOnPipelineError"},{"location":"engines-configuration.html#parsersdcmp_x86iroptimizerdisableaggressivepass","text":"Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false)","title":".parsers.dcmp_x86.IROptimizerDisableAggressivePass"},{"location":"engines-configuration.html#parsersdcmp_x86iroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5)","title":".parsers.dcmp_x86.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_x86memoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2)","title":".parsers.dcmp_x86.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersdcmp_x86reconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+}","title":".parsers.dcmp_x86.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersdcmp_x86structureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3}","title":".parsers.dcmp_x86.StructurerUseVersion"},{"location":"engines-configuration.html#parsersdcmp_x86usefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true)","title":".parsers.dcmp_x86.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersdcmp_x86usessaform","text":"Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false)","title":".parsers.dcmp_x86.UseSSAForm"},{"location":"engines-configuration.html#parsersdcmp_x86textmergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true)","title":".parsers.dcmp_x86.text.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersdcmp_x86textspaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.dcmp_x86.text.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersdcmp_x86_64astoptimizermaxruncount","text":"Description : Determine how many passes the AST optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(20)","title":".parsers.dcmp_x86_64.ASTOptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_x86_64failonpipelineerror","text":"Description : Determine whether or not an exception should be thrown on decompilation error. If not, the error will be visible as a comment in the decompiled code output Type and Default : Boolean(true)","title":".parsers.dcmp_x86_64.FailOnPipelineError"},{"location":"engines-configuration.html#parsersdcmp_x86_64iroptimizerdisableaggressivepass","text":"Description : Disable aggressive IR optimization pass, normally scheduled to run in later IR lifting stages. This pass is used to remove unused out-reaching variables. Type and Default : Boolean(false)","title":".parsers.dcmp_x86_64.IROptimizerDisableAggressivePass"},{"location":"engines-configuration.html#parsersdcmp_x86_64iroptimizermaxruncount","text":"Description : Determine how many passes the IR optimizer may be allowed to run during an optimization task (0 means no limit) Type and Default : Integer(5)","title":".parsers.dcmp_x86_64.IROptimizerMaxRunCount"},{"location":"engines-configuration.html#parsersdcmp_x86_64memoryresolutionpolicy","text":"Description : A resolution policy guides the memory resolver in terms of what memory dereferences can be directly resolved. Supported policy values are: 0: forbidden (no resolution allowed) 1: allowed if reading takes place in read-only area, and points to a defined item 2: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) and points to a defined item 3: #1 + allowed if reading takes place from \"special\" code object areas (eg, ELF's global offset table) 100: allowed from any area and points to a defined item 200: allowed from any area Type and Default : Integer(2)","title":".parsers.dcmp_x86_64.MemoryResolutionPolicy"},{"location":"engines-configuration.html#parsersdcmp_x86_64reconversionmaxcount","text":"Description : Maximum decompilation pipeline restart (reconversion) allowed for a routine Type and Default : Integer(2){0+}","title":".parsers.dcmp_x86_64.ReconversionMaxCount"},{"location":"engines-configuration.html#parsersdcmp_x86_64structureruseversion","text":"Description : Version of the structurer to use (0 means use the default structuring algorithms - in release mode, default=newest) Type and Default : Integer(2){0-3}","title":".parsers.dcmp_x86_64.StructurerUseVersion"},{"location":"engines-configuration.html#parsersdcmp_x86_64usefriendlyvariablenames","text":"Description : Let the AST generate friendly identifier names (eg, based on types) instead of generic names Type and Default : Boolean(true)","title":".parsers.dcmp_x86_64.UseFriendlyVariableNames"},{"location":"engines-configuration.html#parsersdcmp_x86_64usessaform","text":"Description : Let the decompiler convert intermediate form CFG to SSA forms Type and Default : Boolean(false)","title":".parsers.dcmp_x86_64.UseSSAForm"},{"location":"engines-configuration.html#parsersdcmp_x86_64textmergeadjacentdefinitions","text":"Description : Merge same type definitions on a single line (eg, int i = 0, j = 1;) Type and Default : Boolean(true)","title":".parsers.dcmp_x86_64.text.MergeAdjacentDefinitions"},{"location":"engines-configuration.html#parsersdcmp_x86_64textspaceoutcompounds","text":"Description : Insert blank lines between compounds Type and Default : Boolean(true)","title":".parsers.dcmp_x86_64.text.SpaceOutCompounds"},{"location":"engines-configuration.html#parsersdexandroidjavadocroot","text":"Description : Location of Java/Android API documentation files; by default, local files stored in your Android SDK folder will be preferred over web-based API doc Type and Default : String(\"($ANDROID_HOME/docs|$ANDROID_SDK_HOME/docs|$ANDROID_SDK_ROOT/docs)/reference/;https://developer.android.com/reference/;($JAVA_HOME)/docs/api\")","title":".parsers.dex.AndroidJavadocRoot"},{"location":"engines-configuration.html#parsersdexdalvikparsermode","text":"Description : Dalvik parser mode: 0: Legacy DEX, including odex and extended opcodes (0xFFxx) - designed for DEX <=37 If DEX version >= 38 is detected, the mode will be bumped to 100, 110, or more, automatically 50: ART introduction 100: DEX version 38 (+invoke-polymorphic, +invoke-custom, and variants) 110: DEX version 39 (+const-method-handle, +const-method-type) 1000: Newest, including things that may not be supported in JEB yet Type and Default : Integer(50)","title":".parsers.dex.DalvikParserMode"},{"location":"engines-configuration.html#parsersdexparseextendedopcodes","text":"Description : Support parsing for the extended opcodes Type and Default : Boolean(true)","title":".parsers.dex.ParseExtendedOpcodes"},{"location":"engines-configuration.html#parsersdexparseoptimizedopcodes","text":"Description : Support parsing for the optimized opcodes Type and Default : Boolean(true)","title":".parsers.dex.ParseOptimizedOpcodes"},{"location":"engines-configuration.html#parsersdexverifyaccessflags","text":"Description : Fail parsing if the access flags of a class, method, or field appear to be illegal Type and Default : Boolean(false)","title":".parsers.dex.VerifyAccessFlags"},{"location":"engines-configuration.html#parsersdexverifyhashes","text":"Description : Fail parsing if the DEX Adler checksum is not the expected one Type and Default : Boolean(false)","title":".parsers.dex.VerifyHashes"},{"location":"engines-configuration.html#parsersdexverifyversion","text":"Description : Fail parsing if the DEX version number is not in the range [35, 39] Type and Default : Boolean(false)","title":".parsers.dex.VerifyVersion"},{"location":"engines-configuration.html#parsersdexwellknownlibrarypackages","text":"Description : CSL of well-known packages that may not be provided as fully-expanded in code hierarchy tree documents. Use * to prevent auto-expansion for all packages. In practice, the JEB UI client will not auto-expand those packages by default to avoid cluttering the code hierarchy fragment view. Type and Default : String(\"android,androidx,android_src,com.google,java,javax,org.acra,org.json,org.apache\")","title":".parsers.dex.WellKnownLibraryPackages"},{"location":"engines-configuration.html#parsersdextextclassseparatorlength","text":"Description : Length of the class separator line in characters Type and Default : Integer(0){0+}","title":".parsers.dex.text.ClassSeparatorLength"},{"location":"engines-configuration.html#parsersdextextmethodseparatorlength","text":"Description : Length of the method separator line in characters Type and Default : Integer(0){0+}","title":".parsers.dex.text.MethodSeparatorLength"},{"location":"engines-configuration.html#parsersdextextshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.dex.text.ShowAddresses"},{"location":"engines-configuration.html#parsersdextextshowannotations","text":"Description : Show the DEX annotations Type and Default : Boolean(true)","title":".parsers.dex.text.ShowAnnotations"},{"location":"engines-configuration.html#parsersdextextshowbytecode","text":"Description : Display the instruction bytecode Type and Default : Boolean(false)","title":".parsers.dex.text.ShowBytecode"},{"location":"engines-configuration.html#parsersdextextshowdebugdirectives","text":"Description : Show the debug directives (metadata) Type and Default : Boolean(false)","title":".parsers.dex.text.ShowDebugDirectives"},{"location":"engines-configuration.html#parsersdextextshowinstructionsingaps","text":"Description : Parse byte gaps (aka slack space, or unsued data bytes, that can be present of method's body) and display those bytes as Dalvik instructions Type and Default : Boolean(false)","title":".parsers.dex.text.ShowInstructionsInGaps"},{"location":"engines-configuration.html#parsersdextextshowlinenumbers","text":"Description : Show the source line numbers (metadata) Type and Default : Boolean(false)","title":".parsers.dex.text.ShowLineNumbers"},{"location":"engines-configuration.html#parsersdextextshowspacebetweenblocks","text":"Description : Insert a blank line between basic blocks Type and Default : Boolean(false)","title":".parsers.dex.text.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersdextextsmalicompatibility","text":"Description : Generate assembly code closer to (sometimes, compatible with) Smali, eg, using fully-qualified names everywhere Type and Default : Boolean(false)","title":".parsers.dex.text.SmaliCompatibility"},{"location":"engines-configuration.html#parsersdextextusepforparameters","text":"Description : Use p0,p1,... instead of v0,v1,... for variables Type and Default : Boolean(true)","title":".parsers.dex.text.UsePForParameters"},{"location":"engines-configuration.html#parsersevmbcadvancedanalysisroutinecountwarning","text":"Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+}","title":".parsers.evmbc.AdvancedAnalysisRoutineCountWarning"},{"location":"engines-configuration.html#parsersevmbcallowadvancedanalysis","text":"Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false)","title":".parsers.evmbc.AllowAdvancedAnalysis"},{"location":"engines-configuration.html#parsersevmbcanalysisstyle","text":"Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4}","title":".parsers.evmbc.AnalysisStyle"},{"location":"engines-configuration.html#parsersevmbcdebuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2}","title":".parsers.evmbc.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parsersevmbcdebuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2}","title":".parsers.evmbc.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parsersevmbcperformclassrecovery","text":"Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false)","title":".parsers.evmbc.PerformClassRecovery"},{"location":"engines-configuration.html#parsersevmbcperformglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.evmbc.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parsersevmbcprefersynchronousexecution","text":"Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false)","title":".parsers.evmbc.PreferSynchronousExecution"},{"location":"engines-configuration.html#parsersevmbcwantedendianness","text":"Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\")","title":".parsers.evmbc.WantedEndianness"},{"location":"engines-configuration.html#parsersevmbcwantedimagebase","text":"Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\")","title":".parsers.evmbc.WantedImageBase"},{"location":"engines-configuration.html#parsersevmbctextblockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.evmbc.text.BlockXrefsCount"},{"location":"engines-configuration.html#parsersevmbctextcharbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.evmbc.text.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parsersevmbctextgappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false)","title":".parsers.evmbc.text.GapPreferRawFormatting"},{"location":"engines-configuration.html#parsersevmbctextgaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.evmbc.text.GapRawBytesPerLine"},{"location":"engines-configuration.html#parsersevmbctextgaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.evmbc.text.GapRawIntegerSize"},{"location":"engines-configuration.html#parsersevmbctextinstructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.evmbc.text.InstructionAreaLength"},{"location":"engines-configuration.html#parsersevmbctextlabelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.evmbc.text.LabelAreaLength"},{"location":"engines-configuration.html#parsersevmbctextroutineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.evmbc.text.RoutineSeparatorLength"},{"location":"engines-configuration.html#parsersevmbctextshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.evmbc.text.ShowAddresses"},{"location":"engines-configuration.html#parsersevmbctextshowbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.evmbc.text.ShowBytesCount"},{"location":"engines-configuration.html#parsersevmbctextshowsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.evmbc.text.ShowSegmentHeaders"},{"location":"engines-configuration.html#parsersevmbctextshowspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.evmbc.text.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersihexbigendian","text":"Description : Set to true to specify big-endian. The default is little-endian, unless a specific processor setting overrides it. Type and Default : Boolean(false)","title":".parsers.ihex.BigEndian"},{"location":"engines-configuration.html#parsersihexprocessor","text":"Description : Target processor/microcontroller code: 'x86', 'x86_64', 'arm', 'arm64', 'mips', 'avr', etc. The default is x86 Type and Default : String(\"x86\")","title":".parsers.ihex.Processor"},{"location":"engines-configuration.html#parsersihexwantedimagebase","text":"Description : Base address hint. Leave empty to let the plugin decide Type and Default : String(\"\")","title":".parsers.ihex.WantedImageBase"},{"location":"engines-configuration.html#parsersihexwantedwordsize","text":"Description : Desired wordsize in bits: 8, 16, 32, etc. Leave empty to let the plugin decide by heuristics Type and Default : String(\"\")","title":".parsers.ihex.WantedWordsize"},{"location":"engines-configuration.html#parserslibravm_bcadvancedanalysisroutinecountwarning","text":"Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+}","title":".parsers.libravm_bc.AdvancedAnalysisRoutineCountWarning"},{"location":"engines-configuration.html#parserslibravm_bcallowadvancedanalysis","text":"Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false)","title":".parsers.libravm_bc.AllowAdvancedAnalysis"},{"location":"engines-configuration.html#parserslibravm_bcanalysisstyle","text":"Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4}","title":".parsers.libravm_bc.AnalysisStyle"},{"location":"engines-configuration.html#parserslibravm_bcdebuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2}","title":".parsers.libravm_bc.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parserslibravm_bcdebuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2}","title":".parsers.libravm_bc.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parserslibravm_bcperformclassrecovery","text":"Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false)","title":".parsers.libravm_bc.PerformClassRecovery"},{"location":"engines-configuration.html#parserslibravm_bcperformglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.libravm_bc.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parserslibravm_bcprefersynchronousexecution","text":"Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false)","title":".parsers.libravm_bc.PreferSynchronousExecution"},{"location":"engines-configuration.html#parserslibravm_bcwantedendianness","text":"Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\")","title":".parsers.libravm_bc.WantedEndianness"},{"location":"engines-configuration.html#parserslibravm_bcwantedimagebase","text":"Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\")","title":".parsers.libravm_bc.WantedImageBase"},{"location":"engines-configuration.html#parserslibravm_bctextblockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.libravm_bc.text.BlockXrefsCount"},{"location":"engines-configuration.html#parserslibravm_bctextcharbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.libravm_bc.text.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parserslibravm_bctextgappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false)","title":".parsers.libravm_bc.text.GapPreferRawFormatting"},{"location":"engines-configuration.html#parserslibravm_bctextgaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.libravm_bc.text.GapRawBytesPerLine"},{"location":"engines-configuration.html#parserslibravm_bctextgaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.libravm_bc.text.GapRawIntegerSize"},{"location":"engines-configuration.html#parserslibravm_bctextinstructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.libravm_bc.text.InstructionAreaLength"},{"location":"engines-configuration.html#parserslibravm_bctextlabelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.libravm_bc.text.LabelAreaLength"},{"location":"engines-configuration.html#parserslibravm_bctextroutineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.libravm_bc.text.RoutineSeparatorLength"},{"location":"engines-configuration.html#parserslibravm_bctextshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.libravm_bc.text.ShowAddresses"},{"location":"engines-configuration.html#parserslibravm_bctextshowbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.libravm_bc.text.ShowBytesCount"},{"location":"engines-configuration.html#parserslibravm_bctextshowsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.libravm_bc.text.ShowSegmentHeaders"},{"location":"engines-configuration.html#parserslibravm_bctextshowspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.libravm_bc.text.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersmipsadvancedanalysisroutinecountwarning","text":"Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+}","title":".parsers.mips.AdvancedAnalysisRoutineCountWarning"},{"location":"engines-configuration.html#parsersmipsallowadvancedanalysis","text":"Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false)","title":".parsers.mips.AllowAdvancedAnalysis"},{"location":"engines-configuration.html#parsersmipsanalysisstyle","text":"Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4}","title":".parsers.mips.AnalysisStyle"},{"location":"engines-configuration.html#parsersmipsdebuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2}","title":".parsers.mips.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parsersmipsdebuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2}","title":".parsers.mips.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parsersmipsperformclassrecovery","text":"Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false)","title":".parsers.mips.PerformClassRecovery"},{"location":"engines-configuration.html#parsersmipsperformglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.mips.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parsersmipsprefersynchronousexecution","text":"Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false)","title":".parsers.mips.PreferSynchronousExecution"},{"location":"engines-configuration.html#parsersmipswantedendianness","text":"Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\")","title":".parsers.mips.WantedEndianness"},{"location":"engines-configuration.html#parsersmipswantedimagebase","text":"Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\")","title":".parsers.mips.WantedImageBase"},{"location":"engines-configuration.html#parsersmipstextblockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.mips.text.BlockXrefsCount"},{"location":"engines-configuration.html#parsersmipstextcharbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.mips.text.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parsersmipstextgappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false)","title":".parsers.mips.text.GapPreferRawFormatting"},{"location":"engines-configuration.html#parsersmipstextgaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.mips.text.GapRawBytesPerLine"},{"location":"engines-configuration.html#parsersmipstextgaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.mips.text.GapRawIntegerSize"},{"location":"engines-configuration.html#parsersmipstextinstructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.mips.text.InstructionAreaLength"},{"location":"engines-configuration.html#parsersmipstextlabelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.mips.text.LabelAreaLength"},{"location":"engines-configuration.html#parsersmipstextroutineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.mips.text.RoutineSeparatorLength"},{"location":"engines-configuration.html#parsersmipstextshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.mips.text.ShowAddresses"},{"location":"engines-configuration.html#parsersmipstextshowbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.mips.text.ShowBytesCount"},{"location":"engines-configuration.html#parsersmipstextshowsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.mips.text.ShowSegmentHeaders"},{"location":"engines-configuration.html#parsersmipstextshowspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.mips.text.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersmips64advancedanalysisroutinecountwarning","text":"Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+}","title":".parsers.mips64.AdvancedAnalysisRoutineCountWarning"},{"location":"engines-configuration.html#parsersmips64allowadvancedanalysis","text":"Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false)","title":".parsers.mips64.AllowAdvancedAnalysis"},{"location":"engines-configuration.html#parsersmips64analysisstyle","text":"Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4}","title":".parsers.mips64.AnalysisStyle"},{"location":"engines-configuration.html#parsersmips64debuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2}","title":".parsers.mips64.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parsersmips64debuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2}","title":".parsers.mips64.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parsersmips64performclassrecovery","text":"Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false)","title":".parsers.mips64.PerformClassRecovery"},{"location":"engines-configuration.html#parsersmips64performglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.mips64.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parsersmips64prefersynchronousexecution","text":"Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false)","title":".parsers.mips64.PreferSynchronousExecution"},{"location":"engines-configuration.html#parsersmips64wantedendianness","text":"Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\")","title":".parsers.mips64.WantedEndianness"},{"location":"engines-configuration.html#parsersmips64wantedimagebase","text":"Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\")","title":".parsers.mips64.WantedImageBase"},{"location":"engines-configuration.html#parsersmips64textblockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.mips64.text.BlockXrefsCount"},{"location":"engines-configuration.html#parsersmips64textcharbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.mips64.text.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parsersmips64textgappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false)","title":".parsers.mips64.text.GapPreferRawFormatting"},{"location":"engines-configuration.html#parsersmips64textgaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.mips64.text.GapRawBytesPerLine"},{"location":"engines-configuration.html#parsersmips64textgaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.mips64.text.GapRawIntegerSize"},{"location":"engines-configuration.html#parsersmips64textinstructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.mips64.text.InstructionAreaLength"},{"location":"engines-configuration.html#parsersmips64textlabelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.mips64.text.LabelAreaLength"},{"location":"engines-configuration.html#parsersmips64textroutineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.mips64.text.RoutineSeparatorLength"},{"location":"engines-configuration.html#parsersmips64textshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.mips64.text.ShowAddresses"},{"location":"engines-configuration.html#parsersmips64textshowbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.mips64.text.ShowBytesCount"},{"location":"engines-configuration.html#parsersmips64textshowsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.mips64.text.ShowSegmentHeaders"},{"location":"engines-configuration.html#parsersmips64textshowspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.mips64.text.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parserswasmbcadvancedanalysisroutinecountwarning","text":"Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+}","title":".parsers.wasmbc.AdvancedAnalysisRoutineCountWarning"},{"location":"engines-configuration.html#parserswasmbcallowadvancedanalysis","text":"Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false)","title":".parsers.wasmbc.AllowAdvancedAnalysis"},{"location":"engines-configuration.html#parserswasmbcanalysisstyle","text":"Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4}","title":".parsers.wasmbc.AnalysisStyle"},{"location":"engines-configuration.html#parserswasmbcdebuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2}","title":".parsers.wasmbc.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parserswasmbcdebuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2}","title":".parsers.wasmbc.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parserswasmbcperformclassrecovery","text":"Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false)","title":".parsers.wasmbc.PerformClassRecovery"},{"location":"engines-configuration.html#parserswasmbcperformglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.wasmbc.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parserswasmbcprefersynchronousexecution","text":"Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false)","title":".parsers.wasmbc.PreferSynchronousExecution"},{"location":"engines-configuration.html#parserswasmbcwantedendianness","text":"Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\")","title":".parsers.wasmbc.WantedEndianness"},{"location":"engines-configuration.html#parserswasmbcwantedimagebase","text":"Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\")","title":".parsers.wasmbc.WantedImageBase"},{"location":"engines-configuration.html#parserswasmbctextblockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.wasmbc.text.BlockXrefsCount"},{"location":"engines-configuration.html#parserswasmbctextcharbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.wasmbc.text.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parserswasmbctextgappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false)","title":".parsers.wasmbc.text.GapPreferRawFormatting"},{"location":"engines-configuration.html#parserswasmbctextgaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.wasmbc.text.GapRawBytesPerLine"},{"location":"engines-configuration.html#parserswasmbctextgaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.wasmbc.text.GapRawIntegerSize"},{"location":"engines-configuration.html#parserswasmbctextinstructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.wasmbc.text.InstructionAreaLength"},{"location":"engines-configuration.html#parserswasmbctextlabelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.wasmbc.text.LabelAreaLength"},{"location":"engines-configuration.html#parserswasmbctextroutineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.wasmbc.text.RoutineSeparatorLength"},{"location":"engines-configuration.html#parserswasmbctextshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.wasmbc.text.ShowAddresses"},{"location":"engines-configuration.html#parserswasmbctextshowbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.wasmbc.text.ShowBytesCount"},{"location":"engines-configuration.html#parserswasmbctextshowsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.wasmbc.text.ShowSegmentHeaders"},{"location":"engines-configuration.html#parserswasmbctextshowspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.wasmbc.text.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersx86advancedanalysisroutinecountwarning","text":"Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+}","title":".parsers.x86.AdvancedAnalysisRoutineCountWarning"},{"location":"engines-configuration.html#parsersx86allowadvancedanalysis","text":"Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false)","title":".parsers.x86.AllowAdvancedAnalysis"},{"location":"engines-configuration.html#parsersx86analysisstyle","text":"Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4}","title":".parsers.x86.AnalysisStyle"},{"location":"engines-configuration.html#parsersx86debuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2}","title":".parsers.x86.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parsersx86debuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2}","title":".parsers.x86.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parsersx86performclassrecovery","text":"Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false)","title":".parsers.x86.PerformClassRecovery"},{"location":"engines-configuration.html#parsersx86performglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.x86.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parsersx86prefersynchronousexecution","text":"Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false)","title":".parsers.x86.PreferSynchronousExecution"},{"location":"engines-configuration.html#parsersx86wantedendianness","text":"Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\")","title":".parsers.x86.WantedEndianness"},{"location":"engines-configuration.html#parsersx86wantedimagebase","text":"Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\")","title":".parsers.x86.WantedImageBase"},{"location":"engines-configuration.html#parsersx86textblockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.x86.text.BlockXrefsCount"},{"location":"engines-configuration.html#parsersx86textcharbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.x86.text.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parsersx86textgappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false)","title":".parsers.x86.text.GapPreferRawFormatting"},{"location":"engines-configuration.html#parsersx86textgaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.x86.text.GapRawBytesPerLine"},{"location":"engines-configuration.html#parsersx86textgaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.x86.text.GapRawIntegerSize"},{"location":"engines-configuration.html#parsersx86textinstructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.x86.text.InstructionAreaLength"},{"location":"engines-configuration.html#parsersx86textlabelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.x86.text.LabelAreaLength"},{"location":"engines-configuration.html#parsersx86textroutineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.x86.text.RoutineSeparatorLength"},{"location":"engines-configuration.html#parsersx86textshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.x86.text.ShowAddresses"},{"location":"engines-configuration.html#parsersx86textshowbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.x86.text.ShowBytesCount"},{"location":"engines-configuration.html#parsersx86textshowsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.x86.text.ShowSegmentHeaders"},{"location":"engines-configuration.html#parsersx86textshowspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.x86.text.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#parsersx86_64advancedanalysisroutinecountwarning","text":"Description : If the standard analysis yields more routines that this provided threshold, then the user will be prompted for confirmation before starting the optional advanced analysis pass (and subsequent passes). Type and Default : Integer(200){0+}","title":".parsers.x86_64.AdvancedAnalysisRoutineCountWarning"},{"location":"engines-configuration.html#parsersx86_64allowadvancedanalysis","text":"Description : The advanced analysis is an optional analysis pass that comes after the initial standard analysis. It permits discovery of indirect dispatch, therefore providing better routine discovery coverage, and partial resolution of register values. Type and Default : Boolean(false)","title":".parsers.x86_64.AllowAdvancedAnalysis"},{"location":"engines-configuration.html#parsersx86_64analysisstyle","text":"Description : Native analysis style: 0 = forced conservative analysis 1 = automatic mode (depends on the file) 2 = forced aggressive analysis 3 = forced lazy analysis 4 = forced lazy no data analysis Type and Default : Integer(1){0-4}","title":".parsers.x86_64.AnalysisStyle"},{"location":"engines-configuration.html#parsersx86_64debuginformationretrievalpolicy","text":"Description : Policy regarding the retrieval of externally-stored debugging and symbolic information of code objects: 0 = never attempt 1 = retrieve locally stored external symbols 2 = attempt to retrieve locally and network-stored symbols Locations are architecture- and code object- dependent and may be customized via environment variables. Refer to the manual for additional documentation. Type and Default : Integer(2){0-2}","title":".parsers.x86_64.DebugInformationRetrievalPolicy"},{"location":"engines-configuration.html#parsersx86_64debuginformationusagepolicy","text":"Description : Apply and use debug information to improve analysis accuracy (on a best-effort basis): 0 = never use debug information 1 = use internal debug information only 2 = use all available (internal and external) debug information Type and Default : Integer(1){0-2}","title":".parsers.x86_64.DebugInformationUsagePolicy"},{"location":"engines-configuration.html#parsersx86_64performclassrecovery","text":"Description : Attempt C++ class discovery and rebuilding (limited to MSVC-compiled x86 executables for now) Type and Default : Boolean(false)","title":".parsers.x86_64.PerformClassRecovery"},{"location":"engines-configuration.html#parsersx86_64performglobalanalysis","text":"Description : Global analysis passes are optional passes provided by specific decompiler modules. They may allow recovery of complex artifacts, such as classes or modules. Type and Default : Boolean(false)","title":".parsers.x86_64.PerformGlobalAnalysis"},{"location":"engines-configuration.html#parsersx86_64prefersynchronousexecution","text":"Description : Synchronous analysis prevents access to the unit during a code analysis Type and Default : Boolean(false)","title":".parsers.x86_64.PreferSynchronousExecution"},{"location":"engines-configuration.html#parsersx86_64wantedendianness","text":"Description : Desired endianness for raw binaries: 'little'/'le', 'big'/'be'. May be overridden by the code parser. Type and Default : String(\"le\")","title":".parsers.x86_64.WantedEndianness"},{"location":"engines-configuration.html#parsersx86_64wantedimagebase","text":"Description : Desired memory base address for raw binaries. 0 by default. Type and Default : String(\"0\")","title":".parsers.x86_64.WantedImageBase"},{"location":"engines-configuration.html#parsersx86_64textblockxrefscount","text":"Description : Maximum number of cross-references displayed at any address Type and Default : Integer(50)","title":".parsers.x86_64.text.BlockXrefsCount"},{"location":"engines-configuration.html#parsersx86_64textcharbreak64bitaddresses","text":"Description : If not empty, the address column will display 64-bit addresses as two 8-hexdigit parts, separated by the provided character string Type and Default : String(\"'\")","title":".parsers.x86_64.text.CharBreak64BitAddresses"},{"location":"engines-configuration.html#parsersx86_64textgappreferrawformatting","text":"Description : Prefer raw formatting (dr XX, dr XXXX) for gaps and slack spaces instead of regular declarations (eg, db ??) Type and Default : Boolean(false)","title":".parsers.x86_64.text.GapPreferRawFormatting"},{"location":"engines-configuration.html#parsersx86_64textgaprawbytesperline","text":"Description : For raw formatting, determine the maximum number of bytes per line in gaps and slack spaces. Must be a power of 2, else reverts to the default. Type and Default : Integer(16){0+}","title":".parsers.x86_64.text.GapRawBytesPerLine"},{"location":"engines-configuration.html#parsersx86_64textgaprawintegersize","text":"Description : For raw formatting, determine the integer length (in bytes) used for rendering. Must be either 1, 2, 4, or 8, else reverts to the default Type and Default : Integer(1){0+}","title":".parsers.x86_64.text.GapRawIntegerSize"},{"location":"engines-configuration.html#parsersx86_64textinstructionarealength","text":"Description : Length in characters of the assembly column containing the instructions Type and Default : Integer(40){0+}","title":".parsers.x86_64.text.InstructionAreaLength"},{"location":"engines-configuration.html#parsersx86_64textlabelarealength","text":"Description : Length in characters of the assembly column containing the labels Type and Default : Integer(16){0+}","title":".parsers.x86_64.text.LabelAreaLength"},{"location":"engines-configuration.html#parsersx86_64textroutineseparatorlength","text":"Description : Number of characters used to build the line separating routines Type and Default : Integer(80){0+}","title":".parsers.x86_64.text.RoutineSeparatorLength"},{"location":"engines-configuration.html#parsersx86_64textshowaddresses","text":"Description : Display addresses of items Type and Default : Boolean(true)","title":".parsers.x86_64.text.ShowAddresses"},{"location":"engines-configuration.html#parsersx86_64textshowbytescount","text":"Description : Maximum count of instruction bytes to be displayed before the instruction Type and Default : Integer(0){0+}","title":".parsers.x86_64.text.ShowBytesCount"},{"location":"engines-configuration.html#parsersx86_64textshowsegmentheaders","text":"Description : Display the segment or section headers Type and Default : Boolean(true)","title":".parsers.x86_64.text.ShowSegmentHeaders"},{"location":"engines-configuration.html#parsersx86_64textshowspacebetweenblocks","text":"Description : Insert blank lines between basic blocks Type and Default : Boolean(false)","title":".parsers.x86_64.text.ShowSpaceBetweenBlocks"},{"location":"engines-configuration.html#projectalwaysprocessduplicateinputs","text":"Description : Always process binary inputs even if that input was seen earlier and processed as another unit already Type and Default : Boolean(false)","title":".project.AlwaysProcessDuplicateInputs"},{"location":"engines-configuration.html#projectartifactprocessingdepth","text":"Description : Determine the maximum depth an input artifact (eg, a file) will be explored to create units and sub-units representing analysis entities Type and Default : Integer(20){1+}","title":".project.ArtifactProcessingDepth"},{"location":"engines-configuration.html#projectcompresspersistedproject","text":"Description : Compress the JDB2 database (recommended) Type and Default : Boolean(true)","title":".project.CompressPersistedProject"},{"location":"engines-configuration.html#projectpersistencestrategy","text":"Description : Determine how a project will be saved to JDB2: 0: default (full save) 1: explicit full save 2: quick save Type and Default : Integer(0){0-2}","title":".project.PersistenceStrategy"},{"location":"ethereum.html","text":"Ethereum Smart Contracts \u00b6 This section describes how JEB Pro (v3.0-beta.8 or above) can be used to analyze and decompile Ethereum smart contracts compiled to EVM bytecode. The decompiler produces Solidity-like code. Please refer to this post on our blog: Ethereum Smart Contract Decompiler Section to be completed","title":"Ethereum Smart Contracts"},{"location":"ethereum.html#ethereum-smart-contracts","text":"This section describes how JEB Pro (v3.0-beta.8 or above) can be used to analyze and decompile Ethereum smart contracts compiled to EVM bytecode. The decompiler produces Solidity-like code. Please refer to this post on our blog: Ethereum Smart Contract Decompiler Section to be completed","title":"Ethereum Smart Contracts"},{"location":"faq.html","text":"JEB3 FAQ \u00b6 Frequently asked answers to common questions and issues regarding JEB3. (The last section answers questions regarding JEB2, and is kept for reference only. All users are encouraged to migrate to JEB3.) Licensing \u00b6 Where is the end-user license agreement? \u00b6 The up-to-date end-user license agreement for JEB can be found here . Can I generate license keys for additional machines? \u00b6 Yes, as long as the additional machines are operated by the licensee, they may install JEB on them. Contact licensing to request the ability to generate additional keys. We handle those requests promptly. Can I revoke license keys? \u00b6 Yes, JEB license keys can be deprecated. Contact licensing to request key revocation. We handle those requests promptly. How do I check my license type, license identifier, or license key? \u00b6 From the command-line: execute JEB with the -c --license switches, eg: $ jeb_wincon.bat -c --license From the UI client: open the menu entry Help, About . How do floating licenses work? \u00b6 Floating licenses work on a per-seat basis, as opposed to other license types that work on a per-user basis. Example: A floating build valid for 3 seats allow any 3 users within your organization concurrently. A non-floating build valid for 3 users allow 3 fixed, determined users to use JEB. No other user can use it. Therefore, floating builds provide great flexibility for organizations where many users are planning to use JEB irregularly and/or at different times (eg, teams split across various regions). Please refer to this Manual entry to learn about setting up floating Controller and Clients. What happens when my license subscription expires? \u00b6 JEB works on subscription. Past the expiration date, your software will continue to work and allow you to open and work on existing JDB2 projects, but you will not be able to create new projects. Do subscriptions renew automatically? \u00b6 No. We do not perform auto-payments or auto-renewals. Please email sales when you need to renew a subscription. Do you offer subscriptions valid for more than one year? \u00b6 Yes, we do offer custom subscriptions for up to 3 years. Email us at sales for details. Do you offer perpetual licenses? \u00b6 No, we do not offer perpetual licenses at this point. However, we recommend you email sales and let us know your specific needs: we always strive to accommodate our customer's needs. Do you provide professional support? \u00b6 We do offer an additional support plan for JEB Pro and JEB Pro Floating licenses. Refer to the Buy page for details. Do you offer large volume subscriptions? \u00b6 Yes, we do have plans for large enterprise and government. Those plans include the possibility to generate large amount of license keys. Reach out to sales for additional details. We developed internal tools built around JEB. Can other users in my organization use them without breaking the EULA? \u00b6 Yes. As long as your JEB subscription is valid, users in your organization may access and use data produced by JEB. Java \u00b6 Which version of Java shall I use to run JEB UI client? \u00b6 We recommend users to run the JEB3 client with Java 8.191 . You may use newer versions of Java (9/10/11/12+) as well. However, at the time of writing, the native launcher (jeb.exe on Windows, jeb on Linux, jeb.app/ on macOS) may not start as smoothly with those newer JDK. If that happens, you can bypass the native launcher by using the '-j' flag with your start-up script. Example, on Linux: jeb_linux.sh -j . If you have installed multiple versions of Java, we recommend you set the JAVA_HOME environment variable to point to your JDK version 8 folder. Finally, the JEB3 client can always be started directly by running jebc.jar on the command line: java -jar bin/app/jebc.jar Which version of Java shall I use to run non-UI clients? \u00b6 The back-end components of JEB3 (jeb.jar) work fine with with any version of Java 8.191 or above. JEB complains that it \"requires a Java runtime environment\", although I have one installed. \u00b6 Your java binary should be accessible from the PATH environment variable. It is also recommended to set a JAVA_HOME environment variable pointing to your Java installation folder (bin/). Make sure to install a 64-bit Java environment. A common source of problems are 64-bit systems having a 32-bit JRE accessible from the PATH or JAVA_HOME. You may have different versions of Java installed, but always make sure that paths refer to one that matches your system specifications. How can I increase the maximum amount of memory usable by JEB? \u00b6 Edit the jvmopt.txt file at the root of your JEB folder. To increase the maximum amount of memory usable by JEB, adjust the -Xmx value. Example: -Xmx8G : allow JEB to use up to 8 Gb of memory. The settings in jvmopt.txt must be on a single line. After modifying this file, restart JEB with the platform-specific start-up script. On startup, a message in the logger output will reflect the updated capability: Note: do not attempt to edit the jeb.cfg files buried in bin/app or bin/jeb.app folders. The memory settings in those files are automatically pulled from jvmopt.txt. Program \u00b6 On which platforms can I run JEB? \u00b6 The official JEB UI desktop client runs on 64-bit Windows, Linux, and macOS. The JEB back-end components, which can be used separately to build other clients or analysis pipelines, run on all systems (64-bit and 32-bit) for which a Java Runtime Environment version 8 or above is available. What do I need to run JEB? \u00b6 The only external dependency is a Java JRE or JDK. We strongly encourage users to install and use the Java JDK 8.191 to have a smooth JEB experience. How can I run multiple instances of JEB? \u00b6 Multiple instances of JEB3 can run natively without configuration changes. How can I redirect JEB logs to files on disk? \u00b6 Command-line runners, such as a floating license Controller or a script runner, can easily write log output to files. JEB version 3.1.1+ is required. (Note that other clients, such as the UI desktop client, can do that via scripting - refer to GlobalLog .) Use the --logfile=... flag. Consult the Usage info for additional details on that switch ( \"--help\" ) Example: Start a JEB Controller on Windows and log all INFO-level (or above) output to \"controller.log.N\" files (max. 5 rotating files, max. 2 Mb of log per file): jeb_wincon.bat -c --controller --logfiles=controller.log,INFO,5,2 UI \u00b6 JEB messages and strings are in my current (non-English) locale. How do I switch to English? \u00b6 By default, JEB does its best to display messages in the current user's language settings. You may change the locale to English (or another one of the 10 supported languages ) via the Edit, Language menu. See the Settings for details. I am trying to debug an Android application, but my device cannot be found. \u00b6 JEB relies on the Android Debug Bridge ( adb ) to debug Android applications. Make sure to: install the Android SDK (or at least have a stand-alone, working adb binary accessible from your PATH - some Linux distros ship adb and other SDK platform tools in separate, leaner packages) have the SDK path referenced in one of the following environment variables: ANDROID_SDK_ROOT (preferred) or ANDROID_HOME (legacy). To troubleshoot your system, you may enable Developer Mode in your JEB options and examine the logger output. You will see lines like the following indicating how and where JEB is attempting to find adb : [adb] ANDROID_HOME: Environment variable added to list of candidate Android SDK locations [adb] ANDROID_SDK_ROOT: Environment variable NOT found [adb] PATH: added to list of searched folders: (redacted) [adb] Searching for 'adb.exe' in folders, by order: (redacted) [adb] Found and using: C:\\Users\\nicol\\AppData\\Local\\Android\\sdk\\platform-tools\\adb.exe In JEB \"Find text\" or filter fields, why are my regular expressions invalid or not working? \u00b6 JEB uses Java-style regular expressions, not PCRE, Boost, or other type of regex. Although the differences are minimal and subtle, complex regular expressions need to be carefully crafted and abide by the Java Pattern standard (refer to the \"Comparison to Perl 5\" section specifically). Updating \u00b6 I work in a limited-connectivity environment, how can I update the software manually? \u00b6 If you are updating from JEB 2.2.5 or above, simply follow the prompt when JEB starts up or follow the procedure when executing the menu entry Help, Software Update . If you are updating from JEB 2.2.4 or below, the procedure is the following: Check your registered email address for a JEB update email ( \"JEB xxx is available...\" ) Download the software archive Copy the archive to the root of your JEB folder and rename the file to update.zip Create a text file named update.pwd Store the email-provided password inside this file Start JEB as normal; the update will be installed automatically I access Internet via a proxy. Can I still use JEB? \u00b6 First, make sure to use JEB 3.0.8 or above. Proxy settings can be stored at those two locations: The UI client's settings, stored in jeb-client.cfg . If you are using the UI desktop client, they can be modified via the Options panel. In headless mode, set the proxy settings in jeb-engines.cfg instead. In each aforementioned configuration file, the network proxy data is stored as a key-value pair having the following format: .NetworkProxy = type|hostname|port|<username>|<password>|<whitelist> Allowed types: http , socks . 'username'/'password' can be left blank if your proxy does not require authentication 'whitelist' is an optional, comma-separated list of wildcard hostnames/IPs to which JEB should always attempt to direct-connect (no proxy) A few examples of valid proxy strings: http|10.0.0.123|8080 http|10.0.0.123|8080|| http|10.0.0.123|8080||| http|10.0.0.123|8080|||*.pnfsoftware.com socks|proxy0.intranet.com|8088|user|pass|*.pnfsoftware.com Note: Do not forget the leading dot in .NetworkProxy! How do I update from JEB2 to JEB3? \u00b6 At the time of writing, you must install JEB3 Beta (version: 3.0-beta.X) in a separate location. The auto-updater in JEB2 will only notify you that a JEB3 build is available for you to install. Check your email to download and install JEB3. Can I update from the command-line? \u00b6 Yes, you can run: $ <jeb_startup_script> -c --check-update After the update is downloaded, execute JEB normally. JEB just auto-updated and I am now experiencing strange runtime issues. What can I do? \u00b6 If the issues you are experiencing are showing up after a software update, at seemingly random times during program execution, and involve error messages like \"Error invoking method\" or \"Failed to launch JVM\" , it is likely that your last JEB update did not fully complete. Try to execute your start-up script (eg, on Windows, jeb_wincon.bat ) instead of any native launcher you may have been previously using (such as an OS desktop taskbar shortcut). If the issue is still happening, please email Support . Scripting \u00b6 Can I execute a JEB Python script from the command line? \u00b6 Yes. Here's how to use the built-in script runner. You will need a Pro license. Make sure your JEB scripts/ folder contains the jython-xxx.jar . It should be the case if you are using JEB 3.1. Execute your JEB startup script with --srv2 and --script parameters, as well as optional script arguments after -- Example on Windows: $ jeb_wincon.bat -c --srv2 --script=SampleScript.py -- foo bar Use -c --help to learn about other options. Note : The command-line arguments (in the example above: foo, bar) can be retrieved via IClientContext . Note : Alternate ways exist to run scripts or plugins in headless contexts. Read through this guide and associated sample code if you want to know more about writing your own front-end clients. Can I write back-end extensions (plugins, contributions, etc.) in Python? \u00b6 Soon! If all goes according to plan, we open support for Python back-end extensions starting with JEB 2.3.6. Other \u00b6 Is there a public bug/feature tracker? \u00b6 Not at the moment. We are pretty responsive when it comes to answering users' queries though. Here's how to reach out: Send an email to Support Join us on Slack Ask your question on the JEB Google Groups Tweet or DM us @jebdec JEB2 (Legacy) \u00b6 (JEB2-only) Can I run the JEB2 desktop client on my 32-bit machine? \u00b6 Yes. Prior to JEB 3.0-beta.8, JEB UI can also run on Windows 32-bit and Linux 32-bit. (JEB2-only) Which version of Java shall I use to run JEB2? \u00b6 The JEB2 desktop client requires Java 8. The back-end components of JEB2 ( jeb.jar ) work fine with with Java 8, 9, and 10. (JEB2-only) How can I increase the maximum amount of memory usable by JEB2? \u00b6 If unspecified, the memory cap is automatically decided upon starting up - and it will almost certainly be lower than what your system can offer. In order to manually specify the maximum amount of memory usable by JEB, edit the file bin/jeb.ini located in your JEB folder. Add the following lines: -vmargs -Xmx????m Replace ???? by the size amount of your choice, in Mb; eg, 4096 to allow JEB to use up to 4Gb. Note that other Java Virtual Machine options may be provided after the -vmargs (one option per line). Refer to the JVM manual for a complete list of options. (JEB2-only) I just upgraded to Java 8u131 or above (or Java 7u131), and JEB2 close immediately after start-up. What can I do? \u00b6 The probable reason is that you must be using JEB 2.2.10 or below. Older versions of JEB are no compatible with the newer JDK/SDK. There are two ways to solve this problem: If you wish to stay on the JEB 2.2.x branch, install the latest update 2.2.11. You may use Java 7 or Java 8. We recommend you upgrade to the latest version of JEB, on the 2.3 or 3.0 branch. Make sure to use Java 8. (JEB2-only) How can I run multiple instances of JEB2? \u00b6 Start your second and more instances of the JEB2 UI client by using the -data @none command-line argument. Example on Windows: $ jeb_wincon.bat -data @none Note that the customization of your UI workspace will not be ported over to this new instance, and will not be persisted upon closing either. (JEB2-only) JEB2 closes unexpectedly at start-up. How do I troubleshoot potential issues? \u00b6 By default, console messages generated by JEB2 are logged to the workspace/*log or workspace/.metadata/.log file within your JEB directory. If you are using the UI client, adding those settings to your bin/jeb.ini file will instruct the UI framework to log debug messages to the console: -debug -consoleLog -noExit Make sure to add them before any -vmarg parameter! Restart JEB and examine the console log. If all else fails, please reach out to Support . (JEB2-only) How to execute a JEB Python script from the command line with JEB 2.3.4 (or older)? \u00b6 Here is how to run Python scripts in a headless environment with JEB 2.3.4 or older: Make sure to drop a copy of Jython stand-alone JAR into your scripts folder Navigate to your JEB folder, sub-folder bin/cl Execute jeb.jar with --script and --libdir parameters, as well as optional script arguments (preceded by -- ) Also remember to set up two Java properties, using -Dkey=value command-lines flags: jeb.engcfg : points to your jeb-engines.cfg file jeb.lickey : contains a valid JEB license key (such as the value referenced in .LicenseKey in your jeb-client.cfg file) Example: $ java -Djeb.engcfg=jeb-engines.cfg -Djeb.lickey=xxxxxxx -jar jeb.jar --script=1.py --libdir=xxxxx -- arg1 arg2 ... Note : The command-line arguments (arg1, arg2, ...) can be retrieved via IClientContext . (JEB2-only) I'm using JEB2 and cannot find menu entry [xxx] , where is it? \u00b6 You may need to reset the user interface state, via the Reset, UI State menu entry. A hard reset is to remove your workspace/ folder within your JEB installation folder. (JEB2-only) What are the views marked as \"Unbound\" in the JEB2 UI Client? \u00b6 Those entries are layout placeholders from previous JEB sessions. They help JEB determine the best location to display a unit of a given type. (Note that \"Unbound Views\" can be closed at any time.) In the example below, DEX views and Java Decompiled views would be opened in their corresponding placeholders before attempting to create additional views.","title":"FAQ"},{"location":"faq.html#jeb3-faq","text":"Frequently asked answers to common questions and issues regarding JEB3. (The last section answers questions regarding JEB2, and is kept for reference only. All users are encouraged to migrate to JEB3.)","title":"JEB3 FAQ"},{"location":"faq.html#licensing","text":"","title":"Licensing"},{"location":"faq.html#where-is-the-end-user-license-agreement","text":"The up-to-date end-user license agreement for JEB can be found here .","title":"Where is the end-user license agreement?"},{"location":"faq.html#can-i-generate-license-keys-for-additional-machines","text":"Yes, as long as the additional machines are operated by the licensee, they may install JEB on them. Contact licensing to request the ability to generate additional keys. We handle those requests promptly.","title":"Can I generate license keys for additional machines?"},{"location":"faq.html#can-i-revoke-license-keys","text":"Yes, JEB license keys can be deprecated. Contact licensing to request key revocation. We handle those requests promptly.","title":"Can I revoke license keys?"},{"location":"faq.html#how-do-i-check-my-license-type-license-identifier-or-license-key","text":"From the command-line: execute JEB with the -c --license switches, eg: $ jeb_wincon.bat -c --license From the UI client: open the menu entry Help, About .","title":"How do I check my license type, license identifier, or license key?"},{"location":"faq.html#how-do-floating-licenses-work","text":"Floating licenses work on a per-seat basis, as opposed to other license types that work on a per-user basis. Example: A floating build valid for 3 seats allow any 3 users within your organization concurrently. A non-floating build valid for 3 users allow 3 fixed, determined users to use JEB. No other user can use it. Therefore, floating builds provide great flexibility for organizations where many users are planning to use JEB irregularly and/or at different times (eg, teams split across various regions). Please refer to this Manual entry to learn about setting up floating Controller and Clients.","title":"How do floating licenses work?"},{"location":"faq.html#what-happens-when-my-license-subscription-expires","text":"JEB works on subscription. Past the expiration date, your software will continue to work and allow you to open and work on existing JDB2 projects, but you will not be able to create new projects.","title":"What happens when my license subscription expires?"},{"location":"faq.html#do-subscriptions-renew-automatically","text":"No. We do not perform auto-payments or auto-renewals. Please email sales when you need to renew a subscription.","title":"Do subscriptions renew automatically?"},{"location":"faq.html#do-you-offer-subscriptions-valid-for-more-than-one-year","text":"Yes, we do offer custom subscriptions for up to 3 years. Email us at sales for details.","title":"Do you offer subscriptions valid for more than one year?"},{"location":"faq.html#do-you-offer-perpetual-licenses","text":"No, we do not offer perpetual licenses at this point. However, we recommend you email sales and let us know your specific needs: we always strive to accommodate our customer's needs.","title":"Do you offer perpetual licenses?"},{"location":"faq.html#do-you-provide-professional-support","text":"We do offer an additional support plan for JEB Pro and JEB Pro Floating licenses. Refer to the Buy page for details.","title":"Do you provide professional support?"},{"location":"faq.html#do-you-offer-large-volume-subscriptions","text":"Yes, we do have plans for large enterprise and government. Those plans include the possibility to generate large amount of license keys. Reach out to sales for additional details.","title":"Do you offer large volume subscriptions?"},{"location":"faq.html#we-developed-internal-tools-built-around-jeb-can-other-users-in-my-organization-use-them-without-breaking-the-eula","text":"Yes. As long as your JEB subscription is valid, users in your organization may access and use data produced by JEB.","title":"We developed internal tools built around JEB. Can other users in my organization use them without breaking the EULA?"},{"location":"faq.html#java","text":"","title":"Java"},{"location":"faq.html#which-version-of-java-shall-i-use-to-run-jeb-ui-client","text":"We recommend users to run the JEB3 client with Java 8.191 . You may use newer versions of Java (9/10/11/12+) as well. However, at the time of writing, the native launcher (jeb.exe on Windows, jeb on Linux, jeb.app/ on macOS) may not start as smoothly with those newer JDK. If that happens, you can bypass the native launcher by using the '-j' flag with your start-up script. Example, on Linux: jeb_linux.sh -j . If you have installed multiple versions of Java, we recommend you set the JAVA_HOME environment variable to point to your JDK version 8 folder. Finally, the JEB3 client can always be started directly by running jebc.jar on the command line: java -jar bin/app/jebc.jar","title":"Which version of Java shall I use to run JEB UI client?"},{"location":"faq.html#which-version-of-java-shall-i-use-to-run-non-ui-clients","text":"The back-end components of JEB3 (jeb.jar) work fine with with any version of Java 8.191 or above.","title":"Which version of Java shall I use to run non-UI clients?"},{"location":"faq.html#jeb-complains-that-it-requires-a-java-runtime-environment-although-i-have-one-installed","text":"Your java binary should be accessible from the PATH environment variable. It is also recommended to set a JAVA_HOME environment variable pointing to your Java installation folder (bin/). Make sure to install a 64-bit Java environment. A common source of problems are 64-bit systems having a 32-bit JRE accessible from the PATH or JAVA_HOME. You may have different versions of Java installed, but always make sure that paths refer to one that matches your system specifications.","title":"JEB complains that it \"requires a Java runtime environment\", although I have one installed."},{"location":"faq.html#how-can-i-increase-the-maximum-amount-of-memory-usable-by-jeb","text":"Edit the jvmopt.txt file at the root of your JEB folder. To increase the maximum amount of memory usable by JEB, adjust the -Xmx value. Example: -Xmx8G : allow JEB to use up to 8 Gb of memory. The settings in jvmopt.txt must be on a single line. After modifying this file, restart JEB with the platform-specific start-up script. On startup, a message in the logger output will reflect the updated capability: Note: do not attempt to edit the jeb.cfg files buried in bin/app or bin/jeb.app folders. The memory settings in those files are automatically pulled from jvmopt.txt.","title":"How can I increase the maximum amount of memory usable by JEB?"},{"location":"faq.html#program","text":"","title":"Program"},{"location":"faq.html#on-which-platforms-can-i-run-jeb","text":"The official JEB UI desktop client runs on 64-bit Windows, Linux, and macOS. The JEB back-end components, which can be used separately to build other clients or analysis pipelines, run on all systems (64-bit and 32-bit) for which a Java Runtime Environment version 8 or above is available.","title":"On which platforms can I run JEB?"},{"location":"faq.html#what-do-i-need-to-run-jeb","text":"The only external dependency is a Java JRE or JDK. We strongly encourage users to install and use the Java JDK 8.191 to have a smooth JEB experience.","title":"What do I need to run JEB?"},{"location":"faq.html#how-can-i-run-multiple-instances-of-jeb","text":"Multiple instances of JEB3 can run natively without configuration changes.","title":"How can I run multiple instances of JEB?"},{"location":"faq.html#how-can-i-redirect-jeb-logs-to-files-on-disk","text":"Command-line runners, such as a floating license Controller or a script runner, can easily write log output to files. JEB version 3.1.1+ is required. (Note that other clients, such as the UI desktop client, can do that via scripting - refer to GlobalLog .) Use the --logfile=... flag. Consult the Usage info for additional details on that switch ( \"--help\" ) Example: Start a JEB Controller on Windows and log all INFO-level (or above) output to \"controller.log.N\" files (max. 5 rotating files, max. 2 Mb of log per file): jeb_wincon.bat -c --controller --logfiles=controller.log,INFO,5,2","title":"How can I redirect JEB logs to files on disk?"},{"location":"faq.html#ui","text":"","title":"UI"},{"location":"faq.html#jeb-messages-and-strings-are-in-my-current-non-english-locale-how-do-i-switch-to-english","text":"By default, JEB does its best to display messages in the current user's language settings. You may change the locale to English (or another one of the 10 supported languages ) via the Edit, Language menu. See the Settings for details.","title":"JEB messages and strings are in my current (non-English) locale. How do I switch to English?"},{"location":"faq.html#i-am-trying-to-debug-an-android-application-but-my-device-cannot-be-found","text":"JEB relies on the Android Debug Bridge ( adb ) to debug Android applications. Make sure to: install the Android SDK (or at least have a stand-alone, working adb binary accessible from your PATH - some Linux distros ship adb and other SDK platform tools in separate, leaner packages) have the SDK path referenced in one of the following environment variables: ANDROID_SDK_ROOT (preferred) or ANDROID_HOME (legacy). To troubleshoot your system, you may enable Developer Mode in your JEB options and examine the logger output. You will see lines like the following indicating how and where JEB is attempting to find adb : [adb] ANDROID_HOME: Environment variable added to list of candidate Android SDK locations [adb] ANDROID_SDK_ROOT: Environment variable NOT found [adb] PATH: added to list of searched folders: (redacted) [adb] Searching for 'adb.exe' in folders, by order: (redacted) [adb] Found and using: C:\\Users\\nicol\\AppData\\Local\\Android\\sdk\\platform-tools\\adb.exe","title":"I am trying to debug an Android application, but my device cannot be found."},{"location":"faq.html#in-jeb-find-text-or-filter-fields-why-are-my-regular-expressions-invalid-or-not-working","text":"JEB uses Java-style regular expressions, not PCRE, Boost, or other type of regex. Although the differences are minimal and subtle, complex regular expressions need to be carefully crafted and abide by the Java Pattern standard (refer to the \"Comparison to Perl 5\" section specifically).","title":"In JEB \"Find text\" or filter fields, why are my regular expressions invalid or not working?"},{"location":"faq.html#updating","text":"","title":"Updating"},{"location":"faq.html#i-work-in-a-limited-connectivity-environment-how-can-i-update-the-software-manually","text":"If you are updating from JEB 2.2.5 or above, simply follow the prompt when JEB starts up or follow the procedure when executing the menu entry Help, Software Update . If you are updating from JEB 2.2.4 or below, the procedure is the following: Check your registered email address for a JEB update email ( \"JEB xxx is available...\" ) Download the software archive Copy the archive to the root of your JEB folder and rename the file to update.zip Create a text file named update.pwd Store the email-provided password inside this file Start JEB as normal; the update will be installed automatically","title":"I work in a limited-connectivity environment, how can I update the software manually?"},{"location":"faq.html#i-access-internet-via-a-proxy-can-i-still-use-jeb","text":"First, make sure to use JEB 3.0.8 or above. Proxy settings can be stored at those two locations: The UI client's settings, stored in jeb-client.cfg . If you are using the UI desktop client, they can be modified via the Options panel. In headless mode, set the proxy settings in jeb-engines.cfg instead. In each aforementioned configuration file, the network proxy data is stored as a key-value pair having the following format: .NetworkProxy = type|hostname|port|<username>|<password>|<whitelist> Allowed types: http , socks . 'username'/'password' can be left blank if your proxy does not require authentication 'whitelist' is an optional, comma-separated list of wildcard hostnames/IPs to which JEB should always attempt to direct-connect (no proxy) A few examples of valid proxy strings: http|10.0.0.123|8080 http|10.0.0.123|8080|| http|10.0.0.123|8080||| http|10.0.0.123|8080|||*.pnfsoftware.com socks|proxy0.intranet.com|8088|user|pass|*.pnfsoftware.com Note: Do not forget the leading dot in .NetworkProxy!","title":"I access Internet via a proxy. Can I still use JEB?"},{"location":"faq.html#how-do-i-update-from-jeb2-to-jeb3","text":"At the time of writing, you must install JEB3 Beta (version: 3.0-beta.X) in a separate location. The auto-updater in JEB2 will only notify you that a JEB3 build is available for you to install. Check your email to download and install JEB3.","title":"How do I update from JEB2 to JEB3?"},{"location":"faq.html#can-i-update-from-the-command-line","text":"Yes, you can run: $ <jeb_startup_script> -c --check-update After the update is downloaded, execute JEB normally.","title":"Can I update from the command-line?"},{"location":"faq.html#jeb-just-auto-updated-and-i-am-now-experiencing-strange-runtime-issues-what-can-i-do","text":"If the issues you are experiencing are showing up after a software update, at seemingly random times during program execution, and involve error messages like \"Error invoking method\" or \"Failed to launch JVM\" , it is likely that your last JEB update did not fully complete. Try to execute your start-up script (eg, on Windows, jeb_wincon.bat ) instead of any native launcher you may have been previously using (such as an OS desktop taskbar shortcut). If the issue is still happening, please email Support .","title":"JEB just auto-updated and I am now experiencing strange runtime issues. What can I do?"},{"location":"faq.html#scripting","text":"","title":"Scripting"},{"location":"faq.html#can-i-execute-a-jeb-python-script-from-the-command-line","text":"Yes. Here's how to use the built-in script runner. You will need a Pro license. Make sure your JEB scripts/ folder contains the jython-xxx.jar . It should be the case if you are using JEB 3.1. Execute your JEB startup script with --srv2 and --script parameters, as well as optional script arguments after -- Example on Windows: $ jeb_wincon.bat -c --srv2 --script=SampleScript.py -- foo bar Use -c --help to learn about other options. Note : The command-line arguments (in the example above: foo, bar) can be retrieved via IClientContext . Note : Alternate ways exist to run scripts or plugins in headless contexts. Read through this guide and associated sample code if you want to know more about writing your own front-end clients.","title":"Can I execute a JEB Python script from the command line?"},{"location":"faq.html#can-i-write-back-end-extensions-plugins-contributions-etc-in-python","text":"Soon! If all goes according to plan, we open support for Python back-end extensions starting with JEB 2.3.6.","title":"Can I write back-end extensions (plugins, contributions, etc.) in Python?"},{"location":"faq.html#other","text":"","title":"Other"},{"location":"faq.html#is-there-a-public-bugfeature-tracker","text":"Not at the moment. We are pretty responsive when it comes to answering users' queries though. Here's how to reach out: Send an email to Support Join us on Slack Ask your question on the JEB Google Groups Tweet or DM us @jebdec","title":"Is there a public bug/feature tracker?"},{"location":"faq.html#jeb2-legacy","text":"","title":"JEB2 (Legacy)"},{"location":"faq.html#jeb2-only-can-i-run-the-jeb2-desktop-client-on-my-32-bit-machine","text":"Yes. Prior to JEB 3.0-beta.8, JEB UI can also run on Windows 32-bit and Linux 32-bit.","title":"(JEB2-only) Can I run the JEB2 desktop client on my 32-bit machine?"},{"location":"faq.html#jeb2-only-which-version-of-java-shall-i-use-to-run-jeb2","text":"The JEB2 desktop client requires Java 8. The back-end components of JEB2 ( jeb.jar ) work fine with with Java 8, 9, and 10.","title":"(JEB2-only) Which version of Java shall I use to run JEB2?"},{"location":"faq.html#jeb2-only-how-can-i-increase-the-maximum-amount-of-memory-usable-by-jeb2","text":"If unspecified, the memory cap is automatically decided upon starting up - and it will almost certainly be lower than what your system can offer. In order to manually specify the maximum amount of memory usable by JEB, edit the file bin/jeb.ini located in your JEB folder. Add the following lines: -vmargs -Xmx????m Replace ???? by the size amount of your choice, in Mb; eg, 4096 to allow JEB to use up to 4Gb. Note that other Java Virtual Machine options may be provided after the -vmargs (one option per line). Refer to the JVM manual for a complete list of options.","title":"(JEB2-only) How can I increase the maximum amount of memory usable by JEB2?"},{"location":"faq.html#jeb2-only-i-just-upgraded-to-java-8u131-or-above-or-java-7u131-and-jeb2-close-immediately-after-start-up-what-can-i-do","text":"The probable reason is that you must be using JEB 2.2.10 or below. Older versions of JEB are no compatible with the newer JDK/SDK. There are two ways to solve this problem: If you wish to stay on the JEB 2.2.x branch, install the latest update 2.2.11. You may use Java 7 or Java 8. We recommend you upgrade to the latest version of JEB, on the 2.3 or 3.0 branch. Make sure to use Java 8.","title":"(JEB2-only) I just upgraded to Java 8u131 or above (or Java 7u131), and JEB2 close immediately after start-up. What can I do?"},{"location":"faq.html#jeb2-only-how-can-i-run-multiple-instances-of-jeb2","text":"Start your second and more instances of the JEB2 UI client by using the -data @none command-line argument. Example on Windows: $ jeb_wincon.bat -data @none Note that the customization of your UI workspace will not be ported over to this new instance, and will not be persisted upon closing either.","title":"(JEB2-only) How can I run multiple instances of JEB2?"},{"location":"faq.html#jeb2-only-jeb2-closes-unexpectedly-at-start-up-how-do-i-troubleshoot-potential-issues","text":"By default, console messages generated by JEB2 are logged to the workspace/*log or workspace/.metadata/.log file within your JEB directory. If you are using the UI client, adding those settings to your bin/jeb.ini file will instruct the UI framework to log debug messages to the console: -debug -consoleLog -noExit Make sure to add them before any -vmarg parameter! Restart JEB and examine the console log. If all else fails, please reach out to Support .","title":"(JEB2-only) JEB2 closes unexpectedly at start-up. How do I troubleshoot potential issues?"},{"location":"faq.html#jeb2-only-how-to-execute-a-jeb-python-script-from-the-command-line-with-jeb-234-or-older","text":"Here is how to run Python scripts in a headless environment with JEB 2.3.4 or older: Make sure to drop a copy of Jython stand-alone JAR into your scripts folder Navigate to your JEB folder, sub-folder bin/cl Execute jeb.jar with --script and --libdir parameters, as well as optional script arguments (preceded by -- ) Also remember to set up two Java properties, using -Dkey=value command-lines flags: jeb.engcfg : points to your jeb-engines.cfg file jeb.lickey : contains a valid JEB license key (such as the value referenced in .LicenseKey in your jeb-client.cfg file) Example: $ java -Djeb.engcfg=jeb-engines.cfg -Djeb.lickey=xxxxxxx -jar jeb.jar --script=1.py --libdir=xxxxx -- arg1 arg2 ... Note : The command-line arguments (arg1, arg2, ...) can be retrieved via IClientContext .","title":"(JEB2-only) How to execute a JEB Python script from the command line with JEB 2.3.4 (or older)?"},{"location":"faq.html#jeb2-only-im-using-jeb2-and-cannot-find-menu-entry-xxx-where-is-it","text":"You may need to reset the user interface state, via the Reset, UI State menu entry. A hard reset is to remove your workspace/ folder within your JEB installation folder.","title":"(JEB2-only) I'm using JEB2 and cannot find menu entry [xxx], where is it?"},{"location":"faq.html#jeb2-only-what-are-the-views-marked-as-unbound-in-the-jeb2-ui-client","text":"Those entries are layout placeholders from previous JEB sessions. They help JEB determine the best location to display a unit of a given type. (Note that \"Unbound Views\" can be closed at any time.) In the example below, DEX views and Java Decompiled views would be opened in their corresponding placeholders before attempting to create additional views.","title":"(JEB2-only) What are the views marked as \"Unbound\" in the JEB2 UI Client?"},{"location":"floating.html","text":"Floating Controllers \u00b6 Getting Started \u00b6 JEB Pro Floating provide more flexibility than individual builds, and can be distributed to many users within an organization. A floating build licensed for N seats will allow N clients to connect to it concurrently. When a client leaves, its seat is vacated, allowing another JEB client to start by connecting to the Controller. JEB Clients regularly probe the Controller to determine whether or not they are allowed to run. The check is based on the number of seats available in your licensed build: for example, a floating license for 5 seats allows 5 different users to run JEB concurrently. In order to start the Controller, use the --controller flag along with the -c flag. Example on a Linux machine: $ jeb_linux.sh -c --controller Additional Controller-specific command-line flags ( --interface , --port , --protocol ) are detailed later. After starting the Controller, follow the prompt: You will asked to input your password, accept the license agreement, and generate a license key. Sample log output: C:\\jeb>jeb_wincon.bat -c --controller JEB decryption password: *************** ... <EULA> ... Write \"yes\" to agree, then press enter: yes Hello Nicolas Falliere. Set up your JEB controller by generating a license key. This one-time operation will only take a few seconds. Please visit https://www.pnfsoftware.com/genlk, and use the following \"license data\" blob to generate a key License data: ............................................. Input your license key: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Mode: Controller for floating clients Note: X client(s) may simultaneously connect to this controller instance Listening on 0.0.0.0/0.0.0.0:23477... If you need to customize the Controller's address or protocol, you may now stop it with the Ctrl+C keyboard command. Controller Settings \u00b6 After the first step is completed successfully, executing the controller should display something like the following: C:\\jeb>jeb_wincon.bat -c --controller Mode: Controller for floating clients Note: X client(s) may simultaneously connect to this controller instance Listening on 0.0.0.0/0.0.0.0:23477... As can be seen, by default, the controller is listening on port 23477 on all interfaces, and uses the HTTP protocol. This can be changed by editing the configuration file bin/jeb-client.cfg and adding entries: .ControllerInterface , .ControllerPort , and .ControllerProtocol . Protocols currently supported are HTTP (0, the default) and HTTPS (1). Example 1: the Controller listens exclusively on localhost, port 30000: .ControllerInterface = localhost .ControllerPort = 35000 Example 2: the Controller listens on 10.0.0.25, port 8443, and uses HTTPS instead of HTTP: .ControllerInterface = 10.0.0.25 .ControllerPort = 8443 .ControllerProtocol = 1 Client Settings \u00b6 Start your desktop client using one of the standard start-up scripts. For example, on a Windows machine: $ jeb_wincon.bat Your JEB Client settings should mirror your Controller settings: specify the controller hostname/interface, port, and protocol, in your client's jeb-client.cfg. The first time you start your JEB Desktop client, a dialog box will request you to specify your Controller's location. You will also have the opportunity to configure your proxy settings, if you are using one. Technical Notes \u00b6 JEB Clients as well as JEB Controller are the same binary file: there is no separate package for the Controller. The --controller flag is only available for Floating builds. The Controller should be started before Clients. Clients regularly contact the Controller. Therefore, the Controller should always be reachable by running instances of JEB. In order to minimize potential problems due to network latency, it is recommended to run JEB and the Controller within the same local network. By default, the Controller listens on all interfaces, on port 23477. This can be changed by setting the .ControllerInterface and .ControllerPort values in your configuration file. By default, the Controller and Clients use HTTP for communication. In order to use HTTPS, make sure to set the .ControllerProtocol value in your configuration file to 1. (HTTPS is only available for JEB 3.0.6 and above.) JEB Client instance and the Controller may be run in different environments (eg, a Controller on Linux, Clients on Windows or macOS, etc.) The controller property '.ControllerMessage' is used to provide messages, visible by clients on the Controller portal. Updating the Controller \u00b6 There is no auto-update feature in the controller. The update procedure is: Check your registered email address for a JEB update email ( \"JEB xxx is available...\" ) Download the software archive Copy the archive to the root of your JEB folder and rename the file to update.zip Create a text file named update.pwd Store the email-provided password inside this file Start your controller as normal (eg, ... -c --controller ); the update will be installed automatically","title":"Floating Controller"},{"location":"floating.html#floating-controllers","text":"","title":"Floating Controllers"},{"location":"floating.html#getting-started","text":"JEB Pro Floating provide more flexibility than individual builds, and can be distributed to many users within an organization. A floating build licensed for N seats will allow N clients to connect to it concurrently. When a client leaves, its seat is vacated, allowing another JEB client to start by connecting to the Controller. JEB Clients regularly probe the Controller to determine whether or not they are allowed to run. The check is based on the number of seats available in your licensed build: for example, a floating license for 5 seats allows 5 different users to run JEB concurrently. In order to start the Controller, use the --controller flag along with the -c flag. Example on a Linux machine: $ jeb_linux.sh -c --controller Additional Controller-specific command-line flags ( --interface , --port , --protocol ) are detailed later. After starting the Controller, follow the prompt: You will asked to input your password, accept the license agreement, and generate a license key. Sample log output: C:\\jeb>jeb_wincon.bat -c --controller JEB decryption password: *************** ... <EULA> ... Write \"yes\" to agree, then press enter: yes Hello Nicolas Falliere. Set up your JEB controller by generating a license key. This one-time operation will only take a few seconds. Please visit https://www.pnfsoftware.com/genlk, and use the following \"license data\" blob to generate a key License data: ............................................. Input your license key: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Mode: Controller for floating clients Note: X client(s) may simultaneously connect to this controller instance Listening on 0.0.0.0/0.0.0.0:23477... If you need to customize the Controller's address or protocol, you may now stop it with the Ctrl+C keyboard command.","title":"Getting Started"},{"location":"floating.html#controller-settings","text":"After the first step is completed successfully, executing the controller should display something like the following: C:\\jeb>jeb_wincon.bat -c --controller Mode: Controller for floating clients Note: X client(s) may simultaneously connect to this controller instance Listening on 0.0.0.0/0.0.0.0:23477... As can be seen, by default, the controller is listening on port 23477 on all interfaces, and uses the HTTP protocol. This can be changed by editing the configuration file bin/jeb-client.cfg and adding entries: .ControllerInterface , .ControllerPort , and .ControllerProtocol . Protocols currently supported are HTTP (0, the default) and HTTPS (1). Example 1: the Controller listens exclusively on localhost, port 30000: .ControllerInterface = localhost .ControllerPort = 35000 Example 2: the Controller listens on 10.0.0.25, port 8443, and uses HTTPS instead of HTTP: .ControllerInterface = 10.0.0.25 .ControllerPort = 8443 .ControllerProtocol = 1","title":"Controller Settings"},{"location":"floating.html#client-settings","text":"Start your desktop client using one of the standard start-up scripts. For example, on a Windows machine: $ jeb_wincon.bat Your JEB Client settings should mirror your Controller settings: specify the controller hostname/interface, port, and protocol, in your client's jeb-client.cfg. The first time you start your JEB Desktop client, a dialog box will request you to specify your Controller's location. You will also have the opportunity to configure your proxy settings, if you are using one.","title":"Client Settings"},{"location":"floating.html#technical-notes","text":"JEB Clients as well as JEB Controller are the same binary file: there is no separate package for the Controller. The --controller flag is only available for Floating builds. The Controller should be started before Clients. Clients regularly contact the Controller. Therefore, the Controller should always be reachable by running instances of JEB. In order to minimize potential problems due to network latency, it is recommended to run JEB and the Controller within the same local network. By default, the Controller listens on all interfaces, on port 23477. This can be changed by setting the .ControllerInterface and .ControllerPort values in your configuration file. By default, the Controller and Clients use HTTP for communication. In order to use HTTPS, make sure to set the .ControllerProtocol value in your configuration file to 1. (HTTPS is only available for JEB 3.0.6 and above.) JEB Client instance and the Controller may be run in different environments (eg, a Controller on Linux, Clients on Windows or macOS, etc.) The controller property '.ControllerMessage' is used to provide messages, visible by clients on the Controller portal.","title":"Technical Notes"},{"location":"floating.html#updating-the-controller","text":"There is no auto-update feature in the controller. The update procedure is: Check your registered email address for a JEB update email ( \"JEB xxx is available...\" ) Download the software archive Copy the archive to the root of your JEB folder and rename the file to update.zip Create a text file named update.pwd Store the email-provided password inside this file Start your controller as normal (eg, ... -c --controller ); the update will be installed automatically","title":"Updating the Controller"},{"location":"misc.html","text":"Miscellaneous \u00b6 This section describes miscellaneous features offered by the UI client. Saving and Loading \u00b6 A JEB project can be persisted to a file on disk called a JEB Database file. They have a .jdb2 extension. JDB2 files can be shared among users, and reloaded later on. They can grow significantly larger than the original artifact(s), as they contain the analysis results for all - or most of all, see below - units in your project. They are encrypted and compressed . Make sure to load a JDB2 with a version of JEB equal or newer than the one that generated that JDB2. Each JEB plugin/module is responsible for providing persistence of their result units. All PNF Software modules support persistence. Caution : Quick Save \u00b6 The analysis of large artifacts, yielding potentially hundreds or thousands of units, can translate into very large JDB2. For such projects, the UI client may offer the user to \"quick-save\" instead of performing a \"regular (full) save\". Quick saves are almost instantaneous, and generate lean JDB2 files. However, not all data is persisted in QuickSave JDB2. At the time of writing, QuickSave is supported for APK/DEX units and Native Code analysis units. The data items saved in a QuickSave JDB2 are: comments labels renamed items (packages, classes, methods, fields, etc.) identifier names See the back-end property .project.PersistenceStrategy to customize this behavior. Notifications \u00b6 Notifications are generated by modules when they encounter areas of interest during analysis of their input data. The menu entry File, Unit notifications allows the user to view notifications for all units produced in the currently opened project. In the example below, the Android DEX plugin has generated a notification indicating that the analyzed Android app contained multiple DEX files, and that those were merged successfully: Notifications are generated at the discretion of the analysis modules. They can be classified in one of nine levels: Type Description AREA_OF_INTEREST A generic type to signify an area of interest within a unit. CORRUPTION Input corruption has been detected. DEPRECATED_FEATURE The unit has detected features that have been deprecated. ERROR A generic type to signify an error in the unit. INFO A generic type similar to AREA_OF_INTEREST. MALICIOUS The intent is malicious. POTENTIALLY_HARMFUL This type indicates usage of a feature not recommended by guidelines due to its potential dangerousness. UNSUPPORTED_FEATURE Some input cannot be parsed because of a limitation within the unit itself. WARNING A generic type to signify a warning in the unit. Note : See this reference page for additional details. Exporting Output \u00b6 Users may export analyzed data via one the sub-commands in the File, Export menu entries: Export some or all decompilations. Export all binary units to multiple files on disk Export the active fragment to raw text or html (with coloration similar to JEB's text views). Make sure to focus a code view or a decompiled code view before attempting to run this command. This command is accessible via the File, Export menu entry. Project Properties \u00b6 The properties of a project can be examined by right-clicking the project node in the Project Explorer view, via the File menu, or by using the Alt+Enter key combo when the project node is selected. The name is customizable. The default name is always derived from the primary artifact, with a JDB2 extension. This extension stands for \"JEB Database Version 2\", and represent a serialized version of your project which users can save and load on their JEB version 2 software. The creation and modification timestamps are read-only. The user-notes are obviously writeable and saved with the JDB2. Artifact Properties \u00b6 Similarly to Project properties, the properties of an artifact can be examined by right-clicking the artifact node in the Project Explorer view, via the File menu, or by using the Alt+Enter key combo when the artifact node is selected. Unit Properties \u00b6 Similar to Project and Artifact properties, the properties of a unit can be examined by right-clicking the corresponding unit node in the Project Explorer view, via the File menu, or by using the Alt+Enter key combo when the unit node is selected. The unit name is customizable, however, we recommend users to not change unit names . The unit type corresponds to the module type that created the unit (in this example, 'apk') The creation timestamp is the time at which the unit was created from its parent artifact or unit The status field indicates potential problems: N/A means the unit was processed properly, and its contents can be examined; other string messages can be reported by modules to indicate processing error, or simply, lack of processing in the case of lazy processing. Listing Parsers \u00b6 The full list of input processor plugins (whose term was simplified to parsers in the UI) loaded within your JEB instance context can be seen by running the File, Engines, Parsers command. Parsers can be selectively disabled if you would like JEB. For example, if you would like JEB to not process ZIP files as such (ie, treat them as plain binary files), you may disable the zip parser. Note : technically speaking, parsers are JEB plugins that implement the IUnitIdentifier interface. Refer to the \"Developing with JEB\" section of this guide for more information. Adding Artififacts \u00b6 Commonly, most projects will contain a single artifact file, such as a binary executable or an application file. However, you may add as many artifacts as you want to a project Select the menu entry File, Add an Artifact to add an artifact to an existing project. The newly added artifact will be processed, and added to the current project tree: Reparsing Data \u00b6 This advanced feature is available by right-clicking a unit in the Project Explorer view, and selecting Parse at... : Reparsing allows a user to (re)parse a unit or parts of a unit by specifying explicitly what the input data should be parsed as. For instance, you may have input data identified as XML data, and initially parsed as such - therefore yielding an XML unit. However, you may discover that this XML data contains bytes that would correspond to a ZIP file (eg, starting with PK... ). By reparsing the XML data at the given ZIP header offset using the ZIP module, you ask JEB to process that data as ZIP and create a ZIP unit out of it: Reparsing can be helpful when dealing with complicated, obfuscated, or multi-layered files.","title":"Miscellaneous"},{"location":"misc.html#miscellaneous","text":"This section describes miscellaneous features offered by the UI client.","title":"Miscellaneous"},{"location":"misc.html#saving-and-loading","text":"A JEB project can be persisted to a file on disk called a JEB Database file. They have a .jdb2 extension. JDB2 files can be shared among users, and reloaded later on. They can grow significantly larger than the original artifact(s), as they contain the analysis results for all - or most of all, see below - units in your project. They are encrypted and compressed . Make sure to load a JDB2 with a version of JEB equal or newer than the one that generated that JDB2. Each JEB plugin/module is responsible for providing persistence of their result units. All PNF Software modules support persistence. Caution :","title":"Saving and Loading"},{"location":"misc.html#quick-save","text":"The analysis of large artifacts, yielding potentially hundreds or thousands of units, can translate into very large JDB2. For such projects, the UI client may offer the user to \"quick-save\" instead of performing a \"regular (full) save\". Quick saves are almost instantaneous, and generate lean JDB2 files. However, not all data is persisted in QuickSave JDB2. At the time of writing, QuickSave is supported for APK/DEX units and Native Code analysis units. The data items saved in a QuickSave JDB2 are: comments labels renamed items (packages, classes, methods, fields, etc.) identifier names See the back-end property .project.PersistenceStrategy to customize this behavior.","title":"Quick Save"},{"location":"misc.html#notifications","text":"Notifications are generated by modules when they encounter areas of interest during analysis of their input data. The menu entry File, Unit notifications allows the user to view notifications for all units produced in the currently opened project. In the example below, the Android DEX plugin has generated a notification indicating that the analyzed Android app contained multiple DEX files, and that those were merged successfully: Notifications are generated at the discretion of the analysis modules. They can be classified in one of nine levels: Type Description AREA_OF_INTEREST A generic type to signify an area of interest within a unit. CORRUPTION Input corruption has been detected. DEPRECATED_FEATURE The unit has detected features that have been deprecated. ERROR A generic type to signify an error in the unit. INFO A generic type similar to AREA_OF_INTEREST. MALICIOUS The intent is malicious. POTENTIALLY_HARMFUL This type indicates usage of a feature not recommended by guidelines due to its potential dangerousness. UNSUPPORTED_FEATURE Some input cannot be parsed because of a limitation within the unit itself. WARNING A generic type to signify a warning in the unit. Note : See this reference page for additional details.","title":"Notifications"},{"location":"misc.html#exporting-output","text":"Users may export analyzed data via one the sub-commands in the File, Export menu entries: Export some or all decompilations. Export all binary units to multiple files on disk Export the active fragment to raw text or html (with coloration similar to JEB's text views). Make sure to focus a code view or a decompiled code view before attempting to run this command. This command is accessible via the File, Export menu entry.","title":"Exporting Output"},{"location":"misc.html#project-properties","text":"The properties of a project can be examined by right-clicking the project node in the Project Explorer view, via the File menu, or by using the Alt+Enter key combo when the project node is selected. The name is customizable. The default name is always derived from the primary artifact, with a JDB2 extension. This extension stands for \"JEB Database Version 2\", and represent a serialized version of your project which users can save and load on their JEB version 2 software. The creation and modification timestamps are read-only. The user-notes are obviously writeable and saved with the JDB2.","title":"Project Properties"},{"location":"misc.html#artifact-properties","text":"Similarly to Project properties, the properties of an artifact can be examined by right-clicking the artifact node in the Project Explorer view, via the File menu, or by using the Alt+Enter key combo when the artifact node is selected.","title":"Artifact Properties"},{"location":"misc.html#unit-properties","text":"Similar to Project and Artifact properties, the properties of a unit can be examined by right-clicking the corresponding unit node in the Project Explorer view, via the File menu, or by using the Alt+Enter key combo when the unit node is selected. The unit name is customizable, however, we recommend users to not change unit names . The unit type corresponds to the module type that created the unit (in this example, 'apk') The creation timestamp is the time at which the unit was created from its parent artifact or unit The status field indicates potential problems: N/A means the unit was processed properly, and its contents can be examined; other string messages can be reported by modules to indicate processing error, or simply, lack of processing in the case of lazy processing.","title":"Unit Properties"},{"location":"misc.html#listing-parsers","text":"The full list of input processor plugins (whose term was simplified to parsers in the UI) loaded within your JEB instance context can be seen by running the File, Engines, Parsers command. Parsers can be selectively disabled if you would like JEB. For example, if you would like JEB to not process ZIP files as such (ie, treat them as plain binary files), you may disable the zip parser. Note : technically speaking, parsers are JEB plugins that implement the IUnitIdentifier interface. Refer to the \"Developing with JEB\" section of this guide for more information.","title":"Listing Parsers"},{"location":"misc.html#adding-artififacts","text":"Commonly, most projects will contain a single artifact file, such as a binary executable or an application file. However, you may add as many artifacts as you want to a project Select the menu entry File, Add an Artifact to add an artifact to an existing project. The newly added artifact will be processed, and added to the current project tree:","title":"Adding Artififacts"},{"location":"misc.html#reparsing-data","text":"This advanced feature is available by right-clicking a unit in the Project Explorer view, and selecting Parse at... : Reparsing allows a user to (re)parse a unit or parts of a unit by specifying explicitly what the input data should be parsed as. For instance, you may have input data identified as XML data, and initially parsed as such - therefore yielding an XML unit. However, you may discover that this XML data contains bytes that would correspond to a ZIP file (eg, starting with PK... ). By reparsing the XML data at the given ZIP header offset using the ZIP module, you ask JEB to process that data as ZIP and create a ZIP unit out of it: Reparsing can be helpful when dealing with complicated, obfuscated, or multi-layered files.","title":"Reparsing Data"},{"location":"native-debugging.html","text":"Native Code Debugging \u00b6 Currently, JEB supports native ELF file debugging by attaching to a target controlled by gdbserver or lldb-server. First, make sure to read the Generic debugging page. Section under construction.","title":"Native Code Debugging"},{"location":"native-debugging.html#native-code-debugging","text":"Currently, JEB supports native ELF file debugging by attaching to a target controlled by gdbserver or lldb-server. First, make sure to read the Generic debugging page. Section under construction.","title":"Native Code Debugging"},{"location":"native.html","text":"Native Code Analysis \u00b6 JEB is fully-equipped to perform native code analysis of binary files compiled for Windows (PE), Linux and variants (ELF), or most other platforms, including headless firmware files. Decompilers \u00b6 JEB Pro ships with analysis modules, including decompilers, for: Intel x86 32-bit (all x86 - SSE/AVX support coming in JEB 3.1) Intel x86 64-bit (all x86 - SSE/AVX support coming in JEB 3.1) ARM 32-bit (and common ISA extensions) ARM 64-bit (v8 / aarch64) MIPS 32-bit Also provided is a disassembler for Atmel AVR, although we are not shipping an AVR decompiler at the moment. Siglibs \u00b6 JEB supports the creation of signature libraries ( siglibs ) for library code recognition. JEB Pro includes complete library signature sets for: Android NDK libraries. Common libraries (libc, libc++, zlib, etc.) are signed from from NDK v11 up to the latest version (v17 as of 08/18). Visual Studio compiled binaries. This system allows the recognition of statically linked library code in binaries compiled for x86 and x86-64 architectures. Read more: Android NDK Library Signatures (blog) ; Auto-signing (blog) Typelibs \u00b6 JEB supports the creation of type libraries ( typelibs ) for common Windows and Linux subsystems, including: Android NDK on ARM 32-bit Android NDK on ARM 64-bit Android NDK on x86 32-bit Android NDK on x86 64-bit Windows win32 on Intel x86 32-bit Windows win32 on Intel x86 64-bit Windows win32 on ARM 32-bit Windows win32 on ARM 64-bit Windows DDK on Intel x86 32-bit Windows DDK on Intel x86 64-bit Linux glibc on Intel x86 32-bit Linux glibc on ARM 32-bit Linux glibc on MIPS 32-bit Read more: Users can generate their own type libraries: Native Types and Typelibs (blog) Native Code Actions \u00b6 Common native code actions can Be found in the Native menu: Section to be completed Blogs \u00b6 Link: All PNF Software blog posts tagged Native Code.","title":"Native Code Analysis"},{"location":"native.html#native-code-analysis","text":"JEB is fully-equipped to perform native code analysis of binary files compiled for Windows (PE), Linux and variants (ELF), or most other platforms, including headless firmware files.","title":"Native Code Analysis"},{"location":"native.html#decompilers","text":"JEB Pro ships with analysis modules, including decompilers, for: Intel x86 32-bit (all x86 - SSE/AVX support coming in JEB 3.1) Intel x86 64-bit (all x86 - SSE/AVX support coming in JEB 3.1) ARM 32-bit (and common ISA extensions) ARM 64-bit (v8 / aarch64) MIPS 32-bit Also provided is a disassembler for Atmel AVR, although we are not shipping an AVR decompiler at the moment.","title":"Decompilers"},{"location":"native.html#siglibs","text":"JEB supports the creation of signature libraries ( siglibs ) for library code recognition. JEB Pro includes complete library signature sets for: Android NDK libraries. Common libraries (libc, libc++, zlib, etc.) are signed from from NDK v11 up to the latest version (v17 as of 08/18). Visual Studio compiled binaries. This system allows the recognition of statically linked library code in binaries compiled for x86 and x86-64 architectures. Read more: Android NDK Library Signatures (blog) ; Auto-signing (blog)","title":"Siglibs"},{"location":"native.html#typelibs","text":"JEB supports the creation of type libraries ( typelibs ) for common Windows and Linux subsystems, including: Android NDK on ARM 32-bit Android NDK on ARM 64-bit Android NDK on x86 32-bit Android NDK on x86 64-bit Windows win32 on Intel x86 32-bit Windows win32 on Intel x86 64-bit Windows win32 on ARM 32-bit Windows win32 on ARM 64-bit Windows DDK on Intel x86 32-bit Windows DDK on Intel x86 64-bit Linux glibc on Intel x86 32-bit Linux glibc on ARM 32-bit Linux glibc on MIPS 32-bit Read more: Users can generate their own type libraries: Native Types and Typelibs (blog)","title":"Typelibs"},{"location":"native.html#native-code-actions","text":"Common native code actions can Be found in the Native menu: Section to be completed","title":"Native Code Actions"},{"location":"native.html#blogs","text":"Link: All PNF Software blog posts tagged Native Code.","title":"Blogs"},{"location":"settings.html","text":"Settings \u00b6 This section describes settings and additional configuration panels offered by the UI client. Theme \u00b6 JEB ships with a default (clear) theme and a Dark theme. Toggle from default to Dark, and vice-versa, via the Edit, Theme command (or the Ctrl+Shift+Alt+T keyboard shortcut). Styles and Fonts \u00b6 The Edit menu (or the Application menu on Mac) allows users to customize the styles of interactive item as well as the code font used by most JEB views. Make sure to select a fixed font. JEB tries its best to select the most appropriate font on your system; if that fails, and you wish to select a font manually, we recommend Consolas on Windows, Menlo/Monaco on Mac, or DejaVu Sans Mono on Linux. Unicode : JEB supports Unicode. While the aforementioned fonts have good support for a variery of common non-ASCII planes (CJK, Russian, etc.), you might need to use a different fonts to properly examine strings written in exotic locales. Keyboard Shortcuts \u00b6 Most JEB handlers can be triggered by keyboard shortcuts. The default shortcuts are visible when visualizing menu items. To customize keyboard shortcuts: in JEB's bin/ folder, copy jeb-shortcuts.cfg.TEMPLATE to jeb-shortcuts.cfg edit jeb-shortcuts.cfg : uncomment the command lines for which you wish to use custom keyboard shortcuts Refer to the jeb-shortcuts.cfg.TEMPLATE file in your bin/ folder for details: #------------------------------------------------------------------------------ # JEB Custom Keyboard Shortcuts #------------------------------------------------------------------------------ # 1) Rename or copy this file to jeb-shortcuts.cfg # 2) Uncomment and add your own keyboard shortcuts for the actions for which you'd like to override the default shortcuts # Example: by default, Jump is mapped to the 'G' key; the following line (minus the # character) can be used to remap the action to CTRL+J: #jump=Ctrl+J # *** CUSTOMIZABLE HANDLERS *** #runScript= #runLastScript= #share= ... Locale \u00b6 The UI client front-end is available in English as well as 10 additional languages. Select your preferred language via the Edit menu: Note : the back-end components (modules and plugins) are not localized at the moment. Localization is for front-end components only. Non-English locales having partial support at the moment are: Language Support as of JEB3 English default French 80% Chinese 80% Japanese 80% Korean 80% Russian 80% German 60% Italian 60% Portuguese 60% Spanish 60% Turkish 60% Simple Options \u00b6 Simple options are accessible via the Edit or Application menu. Two panels, General and Development , offer a partial view of JEB's configuration files, described in upcoming sections. General options \u00b6 Set-up your packaged plugins directory. Packaged plugins are third-party Jar modules that add functionality to JEB: they can be parsers, disassemblers, decompilers, debuggers, code analyzers, etc. Third-party plugins can be loaded on Pro builds only. Customize your auto-update options. Proxy (http and socks) are supported. Development options \u00b6 The Development mode enables verbose logging for increased insight into the program. The plugin classpath and classname widgets allow setting up non-packaged Java plugins, which makes developing them easier.","title":"Settings"},{"location":"settings.html#settings","text":"This section describes settings and additional configuration panels offered by the UI client.","title":"Settings"},{"location":"settings.html#theme","text":"JEB ships with a default (clear) theme and a Dark theme. Toggle from default to Dark, and vice-versa, via the Edit, Theme command (or the Ctrl+Shift+Alt+T keyboard shortcut).","title":"Theme"},{"location":"settings.html#styles-and-fonts","text":"The Edit menu (or the Application menu on Mac) allows users to customize the styles of interactive item as well as the code font used by most JEB views. Make sure to select a fixed font. JEB tries its best to select the most appropriate font on your system; if that fails, and you wish to select a font manually, we recommend Consolas on Windows, Menlo/Monaco on Mac, or DejaVu Sans Mono on Linux. Unicode : JEB supports Unicode. While the aforementioned fonts have good support for a variery of common non-ASCII planes (CJK, Russian, etc.), you might need to use a different fonts to properly examine strings written in exotic locales.","title":"Styles and Fonts"},{"location":"settings.html#keyboard-shortcuts","text":"Most JEB handlers can be triggered by keyboard shortcuts. The default shortcuts are visible when visualizing menu items. To customize keyboard shortcuts: in JEB's bin/ folder, copy jeb-shortcuts.cfg.TEMPLATE to jeb-shortcuts.cfg edit jeb-shortcuts.cfg : uncomment the command lines for which you wish to use custom keyboard shortcuts Refer to the jeb-shortcuts.cfg.TEMPLATE file in your bin/ folder for details: #------------------------------------------------------------------------------ # JEB Custom Keyboard Shortcuts #------------------------------------------------------------------------------ # 1) Rename or copy this file to jeb-shortcuts.cfg # 2) Uncomment and add your own keyboard shortcuts for the actions for which you'd like to override the default shortcuts # Example: by default, Jump is mapped to the 'G' key; the following line (minus the # character) can be used to remap the action to CTRL+J: #jump=Ctrl+J # *** CUSTOMIZABLE HANDLERS *** #runScript= #runLastScript= #share= ...","title":"Keyboard Shortcuts"},{"location":"settings.html#locale","text":"The UI client front-end is available in English as well as 10 additional languages. Select your preferred language via the Edit menu: Note : the back-end components (modules and plugins) are not localized at the moment. Localization is for front-end components only. Non-English locales having partial support at the moment are: Language Support as of JEB3 English default French 80% Chinese 80% Japanese 80% Korean 80% Russian 80% German 60% Italian 60% Portuguese 60% Spanish 60% Turkish 60%","title":"Locale"},{"location":"settings.html#simple-options","text":"Simple options are accessible via the Edit or Application menu. Two panels, General and Development , offer a partial view of JEB's configuration files, described in upcoming sections.","title":"Simple Options"},{"location":"settings.html#general-options","text":"Set-up your packaged plugins directory. Packaged plugins are third-party Jar modules that add functionality to JEB: they can be parsers, disassemblers, decompilers, debuggers, code analyzers, etc. Third-party plugins can be loaded on Pro builds only. Customize your auto-update options. Proxy (http and socks) are supported.","title":"General options"},{"location":"settings.html#development-options","text":"The Development mode enables verbose logging for increased insight into the program. The plugin classpath and classname widgets allow setting up non-packaged Java plugins, which makes developing them easier.","title":"Development options"},{"location":"views.html","text":"Common Views \u00b6 To visualize a unit, double-click on its node in the Project Explorer panel, or right-click and select Open, View . The view for a unit is a placeholder for one or more fragments , representing unit documents . For example, a DEX unit (which is the analysis result of an Android DEX file) is visually rendered by several fragments, including: A Description static text view A Hex Dump view An Assembly interactive text view A Strings interactive table view A Code Hierarchy interactive tree view Note : Some types of documents provide addressing support. Addressing support is a necessary requirement to enable interactive actions such as navigation and cross-referencing, as will be discussed later. The following sub-sections provide examples of common fragments and views encountered when analyzing binary files: Description Documents \u00b6 The Description document is a standard buffer of text provided by all units. It contains a small body of text presenting various characteristics of the unit, including whether or not it contains children units. Hex Dump Documents \u00b6 The Hex Dump document is a hexadecimal representation of the input artifact. This document can efficiently represent artifacts of a size up to 2^63 bytes. Helper widgets are provided for easy visualization of unpacked byte sequences. Text Documents \u00b6 Units commonly provide interactive text documents to represent their contents. Text documents are addressable. Those views can efficiently represent extremely large bodies of text - up to billions of lines if necessary. The navigation bar, vertically positioned on the right-hand side of the document by default, allows navigating the document. Examples include: assembly documents, xml documents, decompiled code documents, etc. Navigation bar \u00b6 TODO: document the bar features. Table Documents \u00b6 Units may provide table documents to represent their contents. Table documents are addressable. Tree Documents \u00b6 Units may provide tree documents to represent their contents. Tree documents are addressable. Example: Interactive Simple Tree: Code Hierarchy \u00b6 Code hierarchies are interactive trees that allow navigation to code items, such as methods or routines. Example: Static Table Tree: Digital Certificate Data \u00b6 Parsed certificate can be represented as static table tree documents. For example, the APK module produces such documents. Another example of a table tree (for which each node is a row within a table) is the global structure of a PDF document produced by the PDF plugin. Mime-typed Documents \u00b6 A unit may issue mime-typed documents. It is up to front-end clients to implement rendering engines for some of those types. For example, the official UI client render various image types. Custom Documents \u00b6 Specialized units, such as debugger or native code units, offer access to specific data that does not fit in standard document categories. It is up to the front-end to render whatever is deemed necessary. For example, the UI client produces 6 or 7 specialized views to represent debugger units (such as breakpoints, threads, locals, memory, ..). Specialized views are described in sections dealing with specialized units, eg debuggers or native disassemblers .","title":"Common Views"},{"location":"views.html#common-views","text":"To visualize a unit, double-click on its node in the Project Explorer panel, or right-click and select Open, View . The view for a unit is a placeholder for one or more fragments , representing unit documents . For example, a DEX unit (which is the analysis result of an Android DEX file) is visually rendered by several fragments, including: A Description static text view A Hex Dump view An Assembly interactive text view A Strings interactive table view A Code Hierarchy interactive tree view Note : Some types of documents provide addressing support. Addressing support is a necessary requirement to enable interactive actions such as navigation and cross-referencing, as will be discussed later. The following sub-sections provide examples of common fragments and views encountered when analyzing binary files:","title":"Common Views"},{"location":"views.html#description-documents","text":"The Description document is a standard buffer of text provided by all units. It contains a small body of text presenting various characteristics of the unit, including whether or not it contains children units.","title":"Description Documents"},{"location":"views.html#hex-dump-documents","text":"The Hex Dump document is a hexadecimal representation of the input artifact. This document can efficiently represent artifacts of a size up to 2^63 bytes. Helper widgets are provided for easy visualization of unpacked byte sequences.","title":"Hex Dump Documents"},{"location":"views.html#text-documents","text":"Units commonly provide interactive text documents to represent their contents. Text documents are addressable. Those views can efficiently represent extremely large bodies of text - up to billions of lines if necessary. The navigation bar, vertically positioned on the right-hand side of the document by default, allows navigating the document. Examples include: assembly documents, xml documents, decompiled code documents, etc.","title":"Text Documents"},{"location":"views.html#navigation-bar","text":"TODO: document the bar features.","title":"Navigation bar"},{"location":"views.html#table-documents","text":"Units may provide table documents to represent their contents. Table documents are addressable.","title":"Table Documents"},{"location":"views.html#tree-documents","text":"Units may provide tree documents to represent their contents. Tree documents are addressable.","title":"Tree Documents"},{"location":"views.html#example-interactive-simple-tree-code-hierarchy","text":"Code hierarchies are interactive trees that allow navigation to code items, such as methods or routines.","title":"Example: Interactive Simple Tree: Code Hierarchy"},{"location":"views.html#example-static-table-tree-digital-certificate-data","text":"Parsed certificate can be represented as static table tree documents. For example, the APK module produces such documents. Another example of a table tree (for which each node is a row within a table) is the global structure of a PDF document produced by the PDF plugin.","title":"Example: Static Table Tree: Digital Certificate Data"},{"location":"views.html#mime-typed-documents","text":"A unit may issue mime-typed documents. It is up to front-end clients to implement rendering engines for some of those types. For example, the official UI client render various image types.","title":"Mime-typed Documents"},{"location":"views.html#custom-documents","text":"Specialized units, such as debugger or native code units, offer access to specific data that does not fit in standard document categories. It is up to the front-end to render whatever is deemed necessary. For example, the UI client produces 6 or 7 specialized views to represent debugger units (such as breakpoints, threads, locals, memory, ..). Specialized views are described in sections dealing with specialized units, eg debuggers or native disassemblers .","title":"Custom Documents"},{"location":"webassembly.html","text":"WebAssembly (wasm) \u00b6 This section describes how JEB Pro can be used to analyze and decompile WebAssembly binary modules (wasm). The decompiler produces C-like code. Please refer to our technical paper: Reversing WebAssembly Section to be completed","title":"WebAssembly Modules"},{"location":"webassembly.html#webassembly-wasm","text":"This section describes how JEB Pro can be used to analyze and decompile WebAssembly binary modules (wasm). The decompiler produces C-like code. Please refer to our technical paper: Reversing WebAssembly Section to be completed","title":"WebAssembly (wasm)"},{"location":"dev/1-getting-started-with-parsers.html","text":"JEB Plugin Development Tutorial part 1/8 Getting Started with Parsers \u00b6 The JEB API provides the ability to develop parser plugins (referred to as parsers ) for any file type. All native JEB plugins use that same API. A parser can process binary data, textual data, or even the output of other parsers, which is the case for debugger or decompiler plugins. This series of tutorials will help developers understand the major features and organization of the JEB API, and will guide them through the development of their own parsers and plugins. We will use the official front-end - the UI client - throughout this series, although extensions development is in no way constricted to the use of a particular front-end. Load a parser \u00b6 There are two ways to load plugins. Release model \u00b6 Copy the jar plugin to your plugins folder. You can configure your plugins folder via the Edit, Options menu (or Preferences on Mac). Refer to that section for additional details. If you are using third-party (aka, non native) plugins, the release model is easy to use. For example, head over to our GitHub account. You will find a few open-source parsers, such as an Android OAT parser . Instead of compiling them from source, you may decide to use the pre-compiled jars, available in the release section. With the release model, the classname is defined in the Jar manifest. There is nothing to configure in the options. If you have a jar plugin that you would like to use, simply drop it in the plugins folder . Then, restart JEB. Your plugin will be automatically loaded. Development model \u00b6 In that case, you need to specify the classpath of your plugin, as well as its classname (that is, the fully-qualified name of the plugin class, as we will describe later). You can modify these options in the same dialog box, in the Development tab: The development model is ideal when actively developing a plugin, and dealing with compiled Java classfiles that have not been packaged yet. Check if a parser is loaded \u00b6 As we explained earlier in this guide , You can check if your parser is loaded by opening the parsers dialog: Note that you may also disable parsers, by ticking or unticking the checkbox in front of the parser type. Develop a new parser \u00b6 JEB plugins are developed in Java. We recommend you to use the Eclipse IDE for plugins development. Create a new Java project In Eclipse: File, New, Java Project - use the default settings Add the API to your project. The API can be included by adding the Jar reference to your build path In Eclipse: right click on your project, select Build path, Add external archives . The API file is contained in the JEB application under bin/cl/jeb.jar . Link the javadoc to jeb.jar: it is located in doc/apidoc.zip In Eclipse: right click on your project and select Build path, configure build path. Expand jeb.jar and edit the javadoc location Set the Archive path textbobx to point to your apidoc.zip file Set the Path within Archive textbox to reference Create a new class that implements IPlugin : it will be the entry point of your project. In Eclipse: the project is automatically compiled in a bin/ directory For example: package com.jeb.sample; import com.pnfsoftware.jeb.core.IPlugin; // simplest plugin type public class SamplePlugin implements IPlugin { @Override public IPluginInformation getPluginInformation() { return new PluginInformation(\"Sample\", \"Description\", \"PNF Software\", Version.create(1, 0)); } } Open JEB and add your project bin folder to the Plugin Classpath entries and add the classname: com.jeb.sample.SamplePlugin . Restart JEB, you should see a message in the Logger panel: Development plugin loaded: class com.jeb.sample.SamplePlugin This means that your project is correctly configured and that you can start the development of your plugin! Next: Part 2","title":"Part 1: Getting Started with Parsers"},{"location":"dev/1-getting-started-with-parsers.html#getting-started-with-parsers","text":"The JEB API provides the ability to develop parser plugins (referred to as parsers ) for any file type. All native JEB plugins use that same API. A parser can process binary data, textual data, or even the output of other parsers, which is the case for debugger or decompiler plugins. This series of tutorials will help developers understand the major features and organization of the JEB API, and will guide them through the development of their own parsers and plugins. We will use the official front-end - the UI client - throughout this series, although extensions development is in no way constricted to the use of a particular front-end.","title":"Getting Started with Parsers"},{"location":"dev/1-getting-started-with-parsers.html#load-a-parser","text":"There are two ways to load plugins.","title":"Load a parser"},{"location":"dev/1-getting-started-with-parsers.html#release-model","text":"Copy the jar plugin to your plugins folder. You can configure your plugins folder via the Edit, Options menu (or Preferences on Mac). Refer to that section for additional details. If you are using third-party (aka, non native) plugins, the release model is easy to use. For example, head over to our GitHub account. You will find a few open-source parsers, such as an Android OAT parser . Instead of compiling them from source, you may decide to use the pre-compiled jars, available in the release section. With the release model, the classname is defined in the Jar manifest. There is nothing to configure in the options. If you have a jar plugin that you would like to use, simply drop it in the plugins folder . Then, restart JEB. Your plugin will be automatically loaded.","title":"Release model"},{"location":"dev/1-getting-started-with-parsers.html#development-model","text":"In that case, you need to specify the classpath of your plugin, as well as its classname (that is, the fully-qualified name of the plugin class, as we will describe later). You can modify these options in the same dialog box, in the Development tab: The development model is ideal when actively developing a plugin, and dealing with compiled Java classfiles that have not been packaged yet.","title":"Development model"},{"location":"dev/1-getting-started-with-parsers.html#check-if-a-parser-is-loaded","text":"As we explained earlier in this guide , You can check if your parser is loaded by opening the parsers dialog: Note that you may also disable parsers, by ticking or unticking the checkbox in front of the parser type.","title":"Check if a parser is loaded"},{"location":"dev/1-getting-started-with-parsers.html#develop-a-new-parser","text":"JEB plugins are developed in Java. We recommend you to use the Eclipse IDE for plugins development. Create a new Java project In Eclipse: File, New, Java Project - use the default settings Add the API to your project. The API can be included by adding the Jar reference to your build path In Eclipse: right click on your project, select Build path, Add external archives . The API file is contained in the JEB application under bin/cl/jeb.jar . Link the javadoc to jeb.jar: it is located in doc/apidoc.zip In Eclipse: right click on your project and select Build path, configure build path. Expand jeb.jar and edit the javadoc location Set the Archive path textbobx to point to your apidoc.zip file Set the Path within Archive textbox to reference Create a new class that implements IPlugin : it will be the entry point of your project. In Eclipse: the project is automatically compiled in a bin/ directory For example: package com.jeb.sample; import com.pnfsoftware.jeb.core.IPlugin; // simplest plugin type public class SamplePlugin implements IPlugin { @Override public IPluginInformation getPluginInformation() { return new PluginInformation(\"Sample\", \"Description\", \"PNF Software\", Version.create(1, 0)); } } Open JEB and add your project bin folder to the Plugin Classpath entries and add the classname: com.jeb.sample.SamplePlugin . Restart JEB, you should see a message in the Logger panel: Development plugin loaded: class com.jeb.sample.SamplePlugin This means that your project is correctly configured and that you can start the development of your plugin! Next: Part 2","title":"Develop a new parser"},{"location":"dev/2-creating-simple-parser.html","text":"JEB Plugin Development Tutorial part 2/8 Creating a Simple Parser \u00b6 The source code for part 2 of this sample plugin is located on GitHub: Clone this repo : git clone https://github.com/pnfsoftware/jeb2-plugindemo-js.git Switch to the tutorial2 branch: git checkout tutorial2 Sample file \u00b6 In this parser development tutorial, we will consider a simple Javascript parser. Let's start with a definition of a test file: #Javascript function a() { alert(\"a called\"); } function b() { var b = \"b called\"; alert(b); } Parser Objective \u00b6 Our parser will split the input JavaScript file into several parts, one for each JavaScript function(). Defined variables will will be displayed in a supplementary tab in a table. This initial goal is to detect and display the contents of the file. The secondary goal is to define and manage several views, and show how to use the delegation mechanism. Generic Parser \u00b6 First, let's open this js file without modifying anything in JEB. JEB analyzes the input artifact and built the project as following: The top-level project represents your current workspace. The artifact represents the file that was opened. (If you choose \"File, Add an Artifact...\" from the menu, a new artifact will be added at the same level.) The children of the artifact are the units . Their icon can be specified, if none, you will see the default one . JEB provides a default generic parser that displays any file. It contains two fragments: a Description panel with generic information related to unit an Hex Dump view which displays the content of the object as hexadecimal. Detect the js file \u00b6 Upon loading a file, the first step JEB takes is ask all parsers if they are able to handle the input artifact (in our case, a file). So, the first step is to add the detection for this JavaScript (js) file. For the sake of making this tutorial simple, we will suppose that all our js files start with a \"#Javascript\" tag. In part 1 , we learned that IPlugin is the entry point of the plugin; however, it only defines a getPluginInformation() method. Let's start to check all classes/interfaces that extend IPlugin (in Eclipse, right click on IPlugin, Open Type Hierarchy ). What we have here: our own plugin SamplePlugin class IEnginesPlugin for Engines plugins (refer to separate tutorial) IUnitIdentifier for Parser plugins. To free developers from the task of implementing all methods of IUnitIdentifier, the abstract class AbstractUnitIdentifier is provided. Let's extend it instead of IPlugin or IUnitIdentifier. We see that only two methods are not implemented: canIdentify : used to detect if the parser should to be used (the one we were looking for!) prepare : used to create an IUnit that will perform the processing Let's check canIdentify parameters in the API: IInput is a reference to the input file or stream, we can read data from here. IUnitCreator is the parent that created this unit (parsers are producing units or type IUnit). We will use this parameter in the tutorial explaining how delegation works. canIdentify could use IInput.getHeader, IInput.getStream or other method to detect specific file type. Here, we will use AbstractUnitIdentifier.checkBytes which provides an easy way to check header as you can see: private final static byte[] JS_HEADER = \"#Javascript\".getBytes(); @Override public boolean canIdentify(IInput input, IUnitCreator parent) { return checkBytes(input, 0, JS_HEADER); } We are now ready, let's start JEB. Note: you may see the following error in the logger: Unit plugin class com.jeb.sample.SamplePlugin must have a public no-argument constructor This means that you did not provide a default constructor without argument. Let's use this one: public SamplePlugin() { super(\"Javascript\", 0); } Open test.js. You should see this: The default parser did not create the generic unit for js file! That's because there is nothing defined in the prepare method. Keep on reading. Build a unit \u00b6 Look back at the prepare method. It should return an IUnit . The IUnit will be the main processing class, so it is recommended to build a dedicated class. Just like we did for IPlugin, we will use one of the default convenience abstract classes provided: AbstractUnit . public class SampleUnit extends AbstractUnit { public SampleUnit(String name, IInput input, IUnitProcessor unitProcessor, IUnitCreator parent, IPropertyDefinitionManager pdm) { super(\"js\", name, unitProcessor, parent, pdm); } @Override public boolean process() { // indicates that the processing is already done: process won't be called again in future setProcessed(true); // default is false. True indicates that processing is successful. return true; } } and the code of the caller: @Override public IUnit prepare(String name, IInput input, IUnitProcessor unitProcessor, IUnitCreator parent) { return new SampleUnit(name, input, unitProcessor, parent, pdm); } You can test your parser: Not very exciting. The content of the file is not even displayed. AbstractUnit is a simple unit with the description panel. Its constructor does not use the IInput. Let's try something else: what are all available subclasses that we have: Let's use another default implementation: AbstractBinaryUnit . public class SampleUnit extends AbstractBinaryUnit { public SampleUnit(String name, IInput input, IUnitProcessor unitProcessor, IUnitCreator parent, IPropertyDefinitionManager pdm) { super(null, input, \"js\", name, unitProcessor, parent, pdm); } } So, now we have 2 tabs for a single unit. Each tab is a representation of a JEB Document. Default documents for a Binary Unit are Description and Hex Dump. They both display text. Note: the description Document is a default document that is always attached to a unit. You can modify its content by overriding IUnit.getDescription. Add a Document \u00b6 JEB provides the ability for units to produce all sorts of documents to be represented by clients. There are three types of documents, and default implementations are provided: Text buffers (for arbitrary long line-based documents) Tables Trees and table trees Let's start with the simplest document: a text document. We will use the provided AsciiDocument implementation. The display is delegated to an IUnitFormatter. This display can be modified by overriding the IUnit.getFormatter method. @Override public IUnitFormatter getFormatter() { return new UnitFormatterAdapter(new AbstractUnitRepresentation(\"javascript raw code\", true) { @Override public IGenericDocument getDocument() { return new AsciiDocument(getInput()); } }); } The result is what we expected: Next: Part 3","title":"Part 2: Creating a Simple Parser"},{"location":"dev/2-creating-simple-parser.html#creating-a-simple-parser","text":"The source code for part 2 of this sample plugin is located on GitHub: Clone this repo : git clone https://github.com/pnfsoftware/jeb2-plugindemo-js.git Switch to the tutorial2 branch: git checkout tutorial2","title":"Creating a Simple Parser"},{"location":"dev/2-creating-simple-parser.html#sample-file","text":"In this parser development tutorial, we will consider a simple Javascript parser. Let's start with a definition of a test file: #Javascript function a() { alert(\"a called\"); } function b() { var b = \"b called\"; alert(b); }","title":"Sample file"},{"location":"dev/2-creating-simple-parser.html#parser-objective","text":"Our parser will split the input JavaScript file into several parts, one for each JavaScript function(). Defined variables will will be displayed in a supplementary tab in a table. This initial goal is to detect and display the contents of the file. The secondary goal is to define and manage several views, and show how to use the delegation mechanism.","title":"Parser Objective"},{"location":"dev/2-creating-simple-parser.html#generic-parser","text":"First, let's open this js file without modifying anything in JEB. JEB analyzes the input artifact and built the project as following: The top-level project represents your current workspace. The artifact represents the file that was opened. (If you choose \"File, Add an Artifact...\" from the menu, a new artifact will be added at the same level.) The children of the artifact are the units . Their icon can be specified, if none, you will see the default one . JEB provides a default generic parser that displays any file. It contains two fragments: a Description panel with generic information related to unit an Hex Dump view which displays the content of the object as hexadecimal.","title":"Generic Parser"},{"location":"dev/2-creating-simple-parser.html#detect-the-js-file","text":"Upon loading a file, the first step JEB takes is ask all parsers if they are able to handle the input artifact (in our case, a file). So, the first step is to add the detection for this JavaScript (js) file. For the sake of making this tutorial simple, we will suppose that all our js files start with a \"#Javascript\" tag. In part 1 , we learned that IPlugin is the entry point of the plugin; however, it only defines a getPluginInformation() method. Let's start to check all classes/interfaces that extend IPlugin (in Eclipse, right click on IPlugin, Open Type Hierarchy ). What we have here: our own plugin SamplePlugin class IEnginesPlugin for Engines plugins (refer to separate tutorial) IUnitIdentifier for Parser plugins. To free developers from the task of implementing all methods of IUnitIdentifier, the abstract class AbstractUnitIdentifier is provided. Let's extend it instead of IPlugin or IUnitIdentifier. We see that only two methods are not implemented: canIdentify : used to detect if the parser should to be used (the one we were looking for!) prepare : used to create an IUnit that will perform the processing Let's check canIdentify parameters in the API: IInput is a reference to the input file or stream, we can read data from here. IUnitCreator is the parent that created this unit (parsers are producing units or type IUnit). We will use this parameter in the tutorial explaining how delegation works. canIdentify could use IInput.getHeader, IInput.getStream or other method to detect specific file type. Here, we will use AbstractUnitIdentifier.checkBytes which provides an easy way to check header as you can see: private final static byte[] JS_HEADER = \"#Javascript\".getBytes(); @Override public boolean canIdentify(IInput input, IUnitCreator parent) { return checkBytes(input, 0, JS_HEADER); } We are now ready, let's start JEB. Note: you may see the following error in the logger: Unit plugin class com.jeb.sample.SamplePlugin must have a public no-argument constructor This means that you did not provide a default constructor without argument. Let's use this one: public SamplePlugin() { super(\"Javascript\", 0); } Open test.js. You should see this: The default parser did not create the generic unit for js file! That's because there is nothing defined in the prepare method. Keep on reading.","title":"Detect the js file"},{"location":"dev/2-creating-simple-parser.html#build-a-unit","text":"Look back at the prepare method. It should return an IUnit . The IUnit will be the main processing class, so it is recommended to build a dedicated class. Just like we did for IPlugin, we will use one of the default convenience abstract classes provided: AbstractUnit . public class SampleUnit extends AbstractUnit { public SampleUnit(String name, IInput input, IUnitProcessor unitProcessor, IUnitCreator parent, IPropertyDefinitionManager pdm) { super(\"js\", name, unitProcessor, parent, pdm); } @Override public boolean process() { // indicates that the processing is already done: process won't be called again in future setProcessed(true); // default is false. True indicates that processing is successful. return true; } } and the code of the caller: @Override public IUnit prepare(String name, IInput input, IUnitProcessor unitProcessor, IUnitCreator parent) { return new SampleUnit(name, input, unitProcessor, parent, pdm); } You can test your parser: Not very exciting. The content of the file is not even displayed. AbstractUnit is a simple unit with the description panel. Its constructor does not use the IInput. Let's try something else: what are all available subclasses that we have: Let's use another default implementation: AbstractBinaryUnit . public class SampleUnit extends AbstractBinaryUnit { public SampleUnit(String name, IInput input, IUnitProcessor unitProcessor, IUnitCreator parent, IPropertyDefinitionManager pdm) { super(null, input, \"js\", name, unitProcessor, parent, pdm); } } So, now we have 2 tabs for a single unit. Each tab is a representation of a JEB Document. Default documents for a Binary Unit are Description and Hex Dump. They both display text. Note: the description Document is a default document that is always attached to a unit. You can modify its content by overriding IUnit.getDescription.","title":"Build a unit"},{"location":"dev/2-creating-simple-parser.html#add-a-document","text":"JEB provides the ability for units to produce all sorts of documents to be represented by clients. There are three types of documents, and default implementations are provided: Text buffers (for arbitrary long line-based documents) Tables Trees and table trees Let's start with the simplest document: a text document. We will use the provided AsciiDocument implementation. The display is delegated to an IUnitFormatter. This display can be modified by overriding the IUnit.getFormatter method. @Override public IUnitFormatter getFormatter() { return new UnitFormatterAdapter(new AbstractUnitRepresentation(\"javascript raw code\", true) { @Override public IGenericDocument getDocument() { return new AsciiDocument(getInput()); } }); } The result is what we expected: Next: Part 3","title":"Add a Document"},{"location":"dev/3-documents-delegation.html","text":"JEB Plugin Development Tutorial part 3/8 Documents and Delegation \u00b6 The source code for part 3 of this sample plugin is located on GitHub: Clone this repo : git clone https://github.com/pnfsoftware/jeb2-plugindemo-js.git Switch to the tutorial3 branch: git checkout tutorial3 Process the input \u00b6 In the previous part, we built a single document that displays the whole JavaScript file. Imagine we have large functions that we would like to split using the following simple rule: one function per document . Let's detail the flow of execution around IUnit : When opening a new file, all the IPlugin.canIdentify methods are called. If identified, the method IPlugin.prepare is called, which will create a new unit. When opening the unit, if the unit was not previously processed, the method IUnit.process method will be called. At last, IUnit.getFormatter is used to display the result of processing. The process method is where the heavy-lifting of your parser should be located. If you need to pre-process data, you may call the process method in IUnitIdentifier.prepare . Since we don't need it for now, we won't do it. So let's start with implementing process() . First, we need to extract the JavaScript and split this test block into two functions. For the sake of this tutorial, we will use Mozilla Rhino to deal with JavaScript lexing and parsing. You can download it here . First, add rhino-*.jar to your eclipse project (you can attach the javadoc to this .jar, the process is like adding javadoc to jeb.jar). Then, use the following snippet to extract the Functions from Javascript: private static final ILogger logger = GlobalLog.getLogger(SampleUnit.class); private AstRoot root = null; private List<FunctionNode> functions = new ArrayList<FunctionNode>(); @Override public boolean process() { // parse the javascript IRFactory factory = new IRFactory(); try { BufferedReader reader = new BufferedReader(new InputStreamReader(getInput().getStream())); reader.readLine(); // ignore first line with #Javascript root = factory.parse(reader, null, 0); } catch(IOException e) { logger.catching(e); return false; } // save functions List<AstNode> statements = root.getStatements(); for(AstNode statement: statements) { if(statement.getType() == Token.FUNCTION) { functions.add((FunctionNode)statement); } } // done setProcessed(true); return true; } As you can see here, process() is only extracting data: FunctionNode objects are saved in the functions list. Note: JEB provides global logging facility that you can use anytime to send messages in the Logger panel. Do not hesitate to use it to investigate your code. We also recommend you enable the Development Mode in the Options panel: this will allow logging of debug and trace messages. import com.pnfsoftware.jeb.util.logging.GlobalLog; import com.pnfsoftware.jeb.util.logging.ILogger; public class Xxx { private static final ILogger logger = GlobalLog.getLogger(Xxx.class); ... Add a Document per function \u00b6 Now, let's modify the getFormatter method to change rendering, adding as many tabs (documents) as defined functions. @Override public IUnitFormatter getFormatter() { UnitFormatterAdapter adapter = new UnitFormatterAdapter(new AbstractUnitRepresentation(\"javascript raw code\", true) { @Override public IGenericDocument getDocument() { return new AsciiDocument(getInput()); } }); if(functions != null) { for(final FunctionNode function: functions) { adapter.addDocumentPresentation(new AbstractUnitRepresentation(function.getName()) { @Override public IGenericDocument getDocument() { return new AsciiDocument(new BytesInput(function.toSource().getBytes())); } }); } } return adapter; } We called the method UnitFormatterAdapter.addDocumentPresentation to add more documents. Note: since AsciiDocument requires an IInput as entry, we used the most appropriate implementation: Now, start JEB. Note: You will probably see this exception: java.lang.NoClassDefFoundError: org/mozilla/javascript/IRFactory . Remember that js.jar was not added to JEB classpath. Add it to your plugin classpath (in the Options panel - refer to Part 1 of this tutorial). If all works well, you shall to see two additional tabs: Delegate to another Unit \u00b6 These new documents are great but what if we have lots of functions? We will have lots of tabs and it will become unreadable. One solution would be to add these FunctionNodes as children unit of the test.js unit node. We can delegate the creation of those units to the unit processor. Here is a short explanation of delegation: assume have a zip file containing pdf, apk, js... You do not want to write a single parser that manages all those file types. A better approach is to have a Zip parser that will delegate parsing of its contents. That puts the Unit Processor in charge of finding the best Unit that match the file type: DEX Unit, Pdf Unit... and even our new Javascript Unit. More on delegation here . So how to do it? You need to slightly modify process(): // save functions List<AstNode> statements = root.getStatements(); for(AstNode statement: statements) { if(statement.getType() == Token.FUNCTION) { FunctionNode function = (FunctionNode)statement; functions.add(function); IUnit jsUnit = getUnitProcessor().process(function.getName(), new BytesInput(function.toSource().getBytes()), this); if(jsUnit != null) { addChildUnit(jsUnit); } } } You should be able to see a generic binary output for a and b . Exercice \u00b6 Build a simple JavascriptPlugin that takes advantage of the delegation. The solution lies in branch tutorial3 of this sample plugin repository. Do not forget to register the parser plugin's classname in the options panel. You should obtain something like this: Next: Part 4","title":"Part 3: Documents and Delegation"},{"location":"dev/3-documents-delegation.html#documents-and-delegation","text":"The source code for part 3 of this sample plugin is located on GitHub: Clone this repo : git clone https://github.com/pnfsoftware/jeb2-plugindemo-js.git Switch to the tutorial3 branch: git checkout tutorial3","title":"Documents and Delegation"},{"location":"dev/3-documents-delegation.html#process-the-input","text":"In the previous part, we built a single document that displays the whole JavaScript file. Imagine we have large functions that we would like to split using the following simple rule: one function per document . Let's detail the flow of execution around IUnit : When opening a new file, all the IPlugin.canIdentify methods are called. If identified, the method IPlugin.prepare is called, which will create a new unit. When opening the unit, if the unit was not previously processed, the method IUnit.process method will be called. At last, IUnit.getFormatter is used to display the result of processing. The process method is where the heavy-lifting of your parser should be located. If you need to pre-process data, you may call the process method in IUnitIdentifier.prepare . Since we don't need it for now, we won't do it. So let's start with implementing process() . First, we need to extract the JavaScript and split this test block into two functions. For the sake of this tutorial, we will use Mozilla Rhino to deal with JavaScript lexing and parsing. You can download it here . First, add rhino-*.jar to your eclipse project (you can attach the javadoc to this .jar, the process is like adding javadoc to jeb.jar). Then, use the following snippet to extract the Functions from Javascript: private static final ILogger logger = GlobalLog.getLogger(SampleUnit.class); private AstRoot root = null; private List<FunctionNode> functions = new ArrayList<FunctionNode>(); @Override public boolean process() { // parse the javascript IRFactory factory = new IRFactory(); try { BufferedReader reader = new BufferedReader(new InputStreamReader(getInput().getStream())); reader.readLine(); // ignore first line with #Javascript root = factory.parse(reader, null, 0); } catch(IOException e) { logger.catching(e); return false; } // save functions List<AstNode> statements = root.getStatements(); for(AstNode statement: statements) { if(statement.getType() == Token.FUNCTION) { functions.add((FunctionNode)statement); } } // done setProcessed(true); return true; } As you can see here, process() is only extracting data: FunctionNode objects are saved in the functions list. Note: JEB provides global logging facility that you can use anytime to send messages in the Logger panel. Do not hesitate to use it to investigate your code. We also recommend you enable the Development Mode in the Options panel: this will allow logging of debug and trace messages. import com.pnfsoftware.jeb.util.logging.GlobalLog; import com.pnfsoftware.jeb.util.logging.ILogger; public class Xxx { private static final ILogger logger = GlobalLog.getLogger(Xxx.class); ...","title":"Process the input"},{"location":"dev/3-documents-delegation.html#add-a-document-per-function","text":"Now, let's modify the getFormatter method to change rendering, adding as many tabs (documents) as defined functions. @Override public IUnitFormatter getFormatter() { UnitFormatterAdapter adapter = new UnitFormatterAdapter(new AbstractUnitRepresentation(\"javascript raw code\", true) { @Override public IGenericDocument getDocument() { return new AsciiDocument(getInput()); } }); if(functions != null) { for(final FunctionNode function: functions) { adapter.addDocumentPresentation(new AbstractUnitRepresentation(function.getName()) { @Override public IGenericDocument getDocument() { return new AsciiDocument(new BytesInput(function.toSource().getBytes())); } }); } } return adapter; } We called the method UnitFormatterAdapter.addDocumentPresentation to add more documents. Note: since AsciiDocument requires an IInput as entry, we used the most appropriate implementation: Now, start JEB. Note: You will probably see this exception: java.lang.NoClassDefFoundError: org/mozilla/javascript/IRFactory . Remember that js.jar was not added to JEB classpath. Add it to your plugin classpath (in the Options panel - refer to Part 1 of this tutorial). If all works well, you shall to see two additional tabs:","title":"Add a Document per function"},{"location":"dev/3-documents-delegation.html#delegate-to-another-unit","text":"These new documents are great but what if we have lots of functions? We will have lots of tabs and it will become unreadable. One solution would be to add these FunctionNodes as children unit of the test.js unit node. We can delegate the creation of those units to the unit processor. Here is a short explanation of delegation: assume have a zip file containing pdf, apk, js... You do not want to write a single parser that manages all those file types. A better approach is to have a Zip parser that will delegate parsing of its contents. That puts the Unit Processor in charge of finding the best Unit that match the file type: DEX Unit, Pdf Unit... and even our new Javascript Unit. More on delegation here . So how to do it? You need to slightly modify process(): // save functions List<AstNode> statements = root.getStatements(); for(AstNode statement: statements) { if(statement.getType() == Token.FUNCTION) { FunctionNode function = (FunctionNode)statement; functions.add(function); IUnit jsUnit = getUnitProcessor().process(function.getName(), new BytesInput(function.toSource().getBytes()), this); if(jsUnit != null) { addChildUnit(jsUnit); } } } You should be able to see a generic binary output for a and b .","title":"Delegate to another Unit"},{"location":"dev/3-documents-delegation.html#exercice","text":"Build a simple JavascriptPlugin that takes advantage of the delegation. The solution lies in branch tutorial3 of this sample plugin repository. Do not forget to register the parser plugin's classname in the options panel. You should obtain something like this: Next: Part 4","title":"Exercice"},{"location":"dev/4-tables-trees.html","text":"JEB Plugin Development Tutorial part 4/8 Tables and Trees \u00b6 The interfaces ITextDocument , ITableDocument and ITreeDocument are designed to provide buffered data: data is not generated nor displayed entirely (which could lead to performance/memory problem). It is split into Parts (eg, ITableDocumentPart ). When implementing an IXxxDocument , you can choose to render the full model (for instance if the model is relatively small) or just one or more parts. A client requests as many parts as they see fit. Those indications are hints; ultimately, your plugin has the final say in how many parts it decides to return. Now, let's check two types of documents that we haven't seen yet: Table and Tree . Table \u00b6 For simple tables, you can use StaticTableDocument . See below an example of a Table having 2 columns, and containing 2 rows. private ITableDocument getStatisticsTable() { List<TableRow> rows = new ArrayList<>(); rows.add(new TableRow(new Cell(\"Length\"), new Cell(Integer.toString(root.getLength())))); rows.add(new TableRow(new Cell(\"Type\"), new Cell(Integer.toString(root.getType())))); return new StaticTableDocument(Arrays.asList(\"Property\", \"Value\"), rows); } Exercice: Update the getFormatter() method accordingly to include new Documents (use the IUnitFormatter.addPresentation() method). The result should look like: Tree \u00b6 For simple trees, you can use StaticTreeDocument . See below an example of a Tree that displays all function parameters. private ITreeDocument getFunctionsTree() { List<Node> treeRoot = new ArrayList<>(); try { if(functions != null) { for(FunctionNode function: functions) { treeRoot.add(buildFunctionNode(function)); } } } catch(Exception e) { logger.catching(e); } return new StaticTreeDocument(treeRoot); } private Node buildFunctionNode(FunctionNode function) { Node functionNode = new Node(function.getName()); if(function.getParamCount() > 0) { for(AstNode var: function.getParams()) { functionNode.addChild(new Node(((Name)var).getIdentifier())); } } return functionNode; } Next: Part 5","title":"Part 4: Tables and Trees"},{"location":"dev/4-tables-trees.html#tables-and-trees","text":"The interfaces ITextDocument , ITableDocument and ITreeDocument are designed to provide buffered data: data is not generated nor displayed entirely (which could lead to performance/memory problem). It is split into Parts (eg, ITableDocumentPart ). When implementing an IXxxDocument , you can choose to render the full model (for instance if the model is relatively small) or just one or more parts. A client requests as many parts as they see fit. Those indications are hints; ultimately, your plugin has the final say in how many parts it decides to return. Now, let's check two types of documents that we haven't seen yet: Table and Tree .","title":"Tables and Trees"},{"location":"dev/4-tables-trees.html#table","text":"For simple tables, you can use StaticTableDocument . See below an example of a Table having 2 columns, and containing 2 rows. private ITableDocument getStatisticsTable() { List<TableRow> rows = new ArrayList<>(); rows.add(new TableRow(new Cell(\"Length\"), new Cell(Integer.toString(root.getLength())))); rows.add(new TableRow(new Cell(\"Type\"), new Cell(Integer.toString(root.getType())))); return new StaticTableDocument(Arrays.asList(\"Property\", \"Value\"), rows); } Exercice: Update the getFormatter() method accordingly to include new Documents (use the IUnitFormatter.addPresentation() method). The result should look like:","title":"Table"},{"location":"dev/4-tables-trees.html#tree","text":"For simple trees, you can use StaticTreeDocument . See below an example of a Tree that displays all function parameters. private ITreeDocument getFunctionsTree() { List<Node> treeRoot = new ArrayList<>(); try { if(functions != null) { for(FunctionNode function: functions) { treeRoot.add(buildFunctionNode(function)); } } } catch(Exception e) { logger.catching(e); } return new StaticTreeDocument(treeRoot); } private Node buildFunctionNode(FunctionNode function) { Node functionNode = new Node(function.getName()); if(function.getParamCount() > 0) { for(AstNode var: function.getParams()) { functionNode.addChild(new Node(((Name)var).getIdentifier())); } } return functionNode; } Next: Part 5","title":"Tree"},{"location":"dev/5-development-tips.html","text":"JEB Plugin Development Tutorial part 5/8 Development Tips \u00b6 This tutorial aggregates a collection of tips that can help you during plugin development. Logging \u00b6 Creating Loggers \u00b6 Creating a new logger with the JEB API is simple: private static final ILogger logger = GlobalLog.getLogger(MyClass.class); It is good practice to create one logger per class. Loggers can be customized one by one, or globally via the GlobalLog factory. Using Loggers \u00b6 There are several level of logs (error, warning, info, ...) and the logger methods use 2 parameters: the message to display the parameters of the message, as it is done for String.format() method. logger.info(\"Hello %s\", \"World\"); Enabling Debug and Trace levels \u00b6 By default, debug and trace logs are not displayed. You can activate them by ticking the Development mode in the Options menu: Logging destinations \u00b6 By default, JEB sends log data to the Logger view in the UI client. Additional sinks can be added, such as buffers or output streams. For instance, if you would like to collect all logs to a file named jeb-test-output.log in your TEMP folder, your plugin could execute the following: String foldername = System.getProperty(\"java.io.tmpdir\"); File folder = foldername != null ? new File(foldername): TestData.getTestDataRoot(); File file = new File(folder, \"jeb-test-output.log\"); GlobalLog.addDestinationStream(new PrintStream(file)); Be careful, GlobalLog is a global factory object, that impacts the entire application. Debugging \u00b6 If you are familiar with Eclipse and development tools in general, you know how useful proper debugging facility are: the program can be stopped and paused, current variables can be examined, etc. It is especially handy when troubleshooting a corner-case problem in your plugin. JEB can be debugged using a method called remote debugging . What you need to do is: Configure JEB to listen for debug connections Connect Eclipse to JEB Debugging setup: step-by-step \u00b6 Start JEB using the following command-line from your JEB base directory: On Windows/Linux: java -Xdebug -Xrunjdwp:transport=dt_socket,address=8001,server=y,suspend=y -jar bin/plugins/org.eclipse.equinox.launcher_XXXXXXXXXXXX.jar On macOS: java -XstartOnFirstThread -Xdebug -Xrunjdwp:transport=dt_socket,address=8001,server=y,suspend=y -jar bin/plugins/org.eclipse.equinox.launcher_XXXXXXXXXXXX.jar Don't forget to replace XXXXXXXXXXXX by your current Equinox package version. JEB is not started yet: it is waiting for a debugger connection on port 8001 Go to Eclipse: Select Run, Debug Configuration... Create a new entry in Remote Java Application and change the port to 8001 (keep the host as localhost ) Select Debug JEB should be launched and you may be able to stop when putting breakpoints in code. In practice, the true entry-point of a plugin is its no-argument constructor. You may decide to place a breakpoint there. You may also choose to stop in the canIdentify() method, which is appropriate for processor plugins such as this sample JavaScript parser. Launching several instances \u00b6 JEB provides a fully customizable workspace area. Panels can be adjusted, stacked, minimized, expanded, etc. That data is persisted into a workspace folder. You may have a need to to launch several instances of JEB, for instance because you have long processing on a first instance, and would like to continue investigating another task. If you try to launch a second instance, you are likely to see this error message: This indicates a workspace conflict. It is possible to launch a second (or more) instances of the JEB client by appending the -data @none parameters to the command line. Here, @none indicates that no workspace data shall be used or saved. (You may decide to persist that secondary workspace by providing a folder instead of @none.) If you wish to modify your startup scripts to never record workspace layout data, and therefore have the ability to conveniently start as many instances of JEB as you'd like, here are the modifications to do: On Linux/Mac OS: $JAVA -jar $SCRIPTDIR/bin/cl/jeb.jar $@ to $JAVA -data @none -jar $SCRIPTDIR/bin/cl/jeb.jar $@ On Windows: %JAVA% -jar \"%~dp0bin\\cl\\jeb.jar\" %* to %JAVA% -data @none -jar \"%~dp0bin\\cl\\jeb.jar\" %* Next: Part 6","title":"Part 5: Development Tips"},{"location":"dev/5-development-tips.html#development-tips","text":"This tutorial aggregates a collection of tips that can help you during plugin development.","title":"Development Tips"},{"location":"dev/5-development-tips.html#logging","text":"","title":"Logging"},{"location":"dev/5-development-tips.html#creating-loggers","text":"Creating a new logger with the JEB API is simple: private static final ILogger logger = GlobalLog.getLogger(MyClass.class); It is good practice to create one logger per class. Loggers can be customized one by one, or globally via the GlobalLog factory.","title":"Creating Loggers"},{"location":"dev/5-development-tips.html#using-loggers","text":"There are several level of logs (error, warning, info, ...) and the logger methods use 2 parameters: the message to display the parameters of the message, as it is done for String.format() method. logger.info(\"Hello %s\", \"World\");","title":"Using Loggers"},{"location":"dev/5-development-tips.html#enabling-debug-and-trace-levels","text":"By default, debug and trace logs are not displayed. You can activate them by ticking the Development mode in the Options menu:","title":"Enabling Debug and Trace levels"},{"location":"dev/5-development-tips.html#logging-destinations","text":"By default, JEB sends log data to the Logger view in the UI client. Additional sinks can be added, such as buffers or output streams. For instance, if you would like to collect all logs to a file named jeb-test-output.log in your TEMP folder, your plugin could execute the following: String foldername = System.getProperty(\"java.io.tmpdir\"); File folder = foldername != null ? new File(foldername): TestData.getTestDataRoot(); File file = new File(folder, \"jeb-test-output.log\"); GlobalLog.addDestinationStream(new PrintStream(file)); Be careful, GlobalLog is a global factory object, that impacts the entire application.","title":"Logging destinations"},{"location":"dev/5-development-tips.html#debugging","text":"If you are familiar with Eclipse and development tools in general, you know how useful proper debugging facility are: the program can be stopped and paused, current variables can be examined, etc. It is especially handy when troubleshooting a corner-case problem in your plugin. JEB can be debugged using a method called remote debugging . What you need to do is: Configure JEB to listen for debug connections Connect Eclipse to JEB","title":"Debugging"},{"location":"dev/5-development-tips.html#debugging-setup-step-by-step","text":"Start JEB using the following command-line from your JEB base directory: On Windows/Linux: java -Xdebug -Xrunjdwp:transport=dt_socket,address=8001,server=y,suspend=y -jar bin/plugins/org.eclipse.equinox.launcher_XXXXXXXXXXXX.jar On macOS: java -XstartOnFirstThread -Xdebug -Xrunjdwp:transport=dt_socket,address=8001,server=y,suspend=y -jar bin/plugins/org.eclipse.equinox.launcher_XXXXXXXXXXXX.jar Don't forget to replace XXXXXXXXXXXX by your current Equinox package version. JEB is not started yet: it is waiting for a debugger connection on port 8001 Go to Eclipse: Select Run, Debug Configuration... Create a new entry in Remote Java Application and change the port to 8001 (keep the host as localhost ) Select Debug JEB should be launched and you may be able to stop when putting breakpoints in code. In practice, the true entry-point of a plugin is its no-argument constructor. You may decide to place a breakpoint there. You may also choose to stop in the canIdentify() method, which is appropriate for processor plugins such as this sample JavaScript parser.","title":"Debugging setup: step-by-step"},{"location":"dev/5-development-tips.html#launching-several-instances","text":"JEB provides a fully customizable workspace area. Panels can be adjusted, stacked, minimized, expanded, etc. That data is persisted into a workspace folder. You may have a need to to launch several instances of JEB, for instance because you have long processing on a first instance, and would like to continue investigating another task. If you try to launch a second instance, you are likely to see this error message: This indicates a workspace conflict. It is possible to launch a second (or more) instances of the JEB client by appending the -data @none parameters to the command line. Here, @none indicates that no workspace data shall be used or saved. (You may decide to persist that secondary workspace by providing a folder instead of @none.) If you wish to modify your startup scripts to never record workspace layout data, and therefore have the ability to conveniently start as many instances of JEB as you'd like, here are the modifications to do: On Linux/Mac OS: $JAVA -jar $SCRIPTDIR/bin/cl/jeb.jar $@ to $JAVA -data @none -jar $SCRIPTDIR/bin/cl/jeb.jar $@ On Windows: %JAVA% -jar \"%~dp0bin\\cl\\jeb.jar\" %* to %JAVA% -data @none -jar \"%~dp0bin\\cl\\jeb.jar\" %* Next: Part 6","title":"Launching several instances"},{"location":"dev/6-releasing-plugin.html","text":"JEB Plugin Development Tutorial part 6/8 Releasing a Plugin \u00b6 When your plugin is ready, you may be looking into some way to share it. It is not convenient to hand out classfiles, not to mention changing Classpath and Classnames in the JEB Options panel. The solution is to package your plugin: this page shows you how to build a jar file containing your JEB plugin. Ant Build File \u00b6 First, make sure to have a JEB_HOME environment variable pointing to your JEB directory. Then, use the following Ant build.xml file to build the sample JavaScript plugin. <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?> <project basedir=\".\" default=\"build\" name=\"jebplugin\"> <property name=\"jebjar\" value=\"${env.JEB_HOME}/bin/cl/jeb.jar\"/> <property name=\"jebpath\" value=\"/home/clucas/jeb-2.0.6.201508260620/bin/cl/jeb.jar\"/> <property name=\"outfile\" value=\"out/JebJavascriptPlugin.jar\"/> <property name=\"entryclass\" value=\"com.jeb.sample.JavascriptPlugin\"/> <property name=\"extcp_build\" value=\"lib/js.jar\"/> <property name=\"extcp_manifest\" value=\"lib/js.jar\"/> <target name=\"build\" depends=\"compile,package\"/> <target name=\"compile\"> <delete dir=\"bin\"/> <mkdir dir=\"bin\"/> <javac debug=\"true\" debuglevel=\"source,lines,vars\" destdir=\"bin\" includeantruntime=\"false\" source=\"1.7\" target=\"1.7\"> <src path=\"src\"/> <classpath> <pathelement location=\"${jebpath}\"/> <pathelement path=\"${extcp_build}\"/> </classpath> </javac> </target> <target name=\"package\"> <delete file=\"${outfile}\"/> <jar destfile=\"${outfile}\"> <manifest> <attribute name=\"Class-Path\" value=\"${extcp_manifest}\"/> <attribute name=\"JebPlugin-entryclass\" value=\"${entryclass}\"/> </manifest> <fileset dir=\"bin\"/> <fileset dir=\".\" includes=\"README.md\"/> </jar> </target> </project> Building the Plugin \u00b6 You can run the build.xml directly from eclipse or execute the Ant command. It will generate a jar which has 2 specific entries in the manifest: Class-Path to indicate the required external libraries. JebPlugin-entryclass to indicate the classname, ie your plugin entry-point Copy both JebJavascriptPlugin.jar and js.jar to your plugin folder. You can remove the classpath and classnames entries related to JavascriptPlugin and js.jar. Note : the best approach is to have one project per plugin. Exercice: Split the project and generate JavascriptPlugin.jar and HashJavascriptPlugin.jar. Remove all classpaths and classnames to check that it works. Generic Build Template \u00b6 The following Ant template can be customized for your own plugins needs: <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?> <!-- Sample Ant build file used to build and package a JEB plugin. - Requirements: set up the JEB_HOME environment variable to point to your JEB installation folder. - Customize the outfile, entryclass, extcp_build, and extcp_manifest properties. --> <project basedir=\".\" default=\"build\" name=\"jebplugin\"> <fail message=\"Set the plugin version number: ant -Dversion=x.y.z\"> <condition> <not> <isset property=\"version\"/> </not> </condition> </fail> <echo message=\"Plugin version: ${version}\"/> <property environment=\"env\"/> <echo message=\"JEB_HOME: ${env.JEB_HOME}\"/> <property name=\"jebjar\" value=\"${env.JEB_HOME}/bin/cl/jeb.jar\"/> <echo message=\"JEB Core expected at location: ${jebjar}\"/> <fail message=\"Please set JEB_HOME environment variable to point to your JEB installation folder\"> <condition> <not> <available file=\"${jebjar}\"/> </not> </condition> </fail> <property name=\"debuglevel\" value=\"source,lines,vars\"/> <property name=\"target\" value=\"1.7\"/> <property name=\"source\" value=\"1.7\"/> <!-- Mandatory properties --> <property name=\"outfile\" value=\"CUSTOMIZE\"/> <property name=\"entryclass\" value=\"CUSTOMIZE\"/> <!-- External libraries, for build process (semi-colon separated) --> <property name=\"extcp_build\" value=\"\"/> <!-- External libraries, for Manifest (space separated) --> <property name=\"extcp_manifest\" value=\"\"/> <target name=\"build\" depends=\"clean,compile,package\"/> <target name=\"audit\" depends=\"clean,compile-audit\"/> <target name=\"clean\"> <delete dir=\"bin\"/> <mkdir dir=\"bin\"/> </target> <target name=\"compile\"> <delete dir=\"bin\"/> <mkdir dir=\"bin\"/> <javac debug=\"true\" debuglevel=\"${debuglevel}\" destdir=\"bin\" includeantruntime=\"false\" source=\"${source}\" target=\"${target}\" encoding=\"UTF-8\"> <src path=\"src/main/java\"/> <classpath> <pathelement location=\"${jebjar}\"/> <pathelement path=\"${extcp_build}\"/> </classpath> </javac> </target> <target name=\"package\"> <delete file=\"${outfile}\"/> <jar destfile=\"${outfile}\"> <manifest> <attribute name=\"Class-Path\" value=\"${extcp_manifest}\"/> <attribute name=\"JebPlugin-entryclass\" value=\"${entryclass}\"/> <attribute name=\"JebPlugin-version\" value=\"${version}\"/> </manifest> <fileset dir=\"bin\"/> <!-- copy resources --> <fileset dir=\"src/main/java\" excludes=\"**/*.java\"/> <fileset dir=\".\" includes=\"README.md\"/> </jar> </target> </project> Next: Part 7","title":"Part 6: Releasing a Plugin"},{"location":"dev/6-releasing-plugin.html#releasing-a-plugin","text":"When your plugin is ready, you may be looking into some way to share it. It is not convenient to hand out classfiles, not to mention changing Classpath and Classnames in the JEB Options panel. The solution is to package your plugin: this page shows you how to build a jar file containing your JEB plugin.","title":"Releasing a Plugin"},{"location":"dev/6-releasing-plugin.html#ant-build-file","text":"First, make sure to have a JEB_HOME environment variable pointing to your JEB directory. Then, use the following Ant build.xml file to build the sample JavaScript plugin. <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?> <project basedir=\".\" default=\"build\" name=\"jebplugin\"> <property name=\"jebjar\" value=\"${env.JEB_HOME}/bin/cl/jeb.jar\"/> <property name=\"jebpath\" value=\"/home/clucas/jeb-2.0.6.201508260620/bin/cl/jeb.jar\"/> <property name=\"outfile\" value=\"out/JebJavascriptPlugin.jar\"/> <property name=\"entryclass\" value=\"com.jeb.sample.JavascriptPlugin\"/> <property name=\"extcp_build\" value=\"lib/js.jar\"/> <property name=\"extcp_manifest\" value=\"lib/js.jar\"/> <target name=\"build\" depends=\"compile,package\"/> <target name=\"compile\"> <delete dir=\"bin\"/> <mkdir dir=\"bin\"/> <javac debug=\"true\" debuglevel=\"source,lines,vars\" destdir=\"bin\" includeantruntime=\"false\" source=\"1.7\" target=\"1.7\"> <src path=\"src\"/> <classpath> <pathelement location=\"${jebpath}\"/> <pathelement path=\"${extcp_build}\"/> </classpath> </javac> </target> <target name=\"package\"> <delete file=\"${outfile}\"/> <jar destfile=\"${outfile}\"> <manifest> <attribute name=\"Class-Path\" value=\"${extcp_manifest}\"/> <attribute name=\"JebPlugin-entryclass\" value=\"${entryclass}\"/> </manifest> <fileset dir=\"bin\"/> <fileset dir=\".\" includes=\"README.md\"/> </jar> </target> </project>","title":"Ant Build File"},{"location":"dev/6-releasing-plugin.html#building-the-plugin","text":"You can run the build.xml directly from eclipse or execute the Ant command. It will generate a jar which has 2 specific entries in the manifest: Class-Path to indicate the required external libraries. JebPlugin-entryclass to indicate the classname, ie your plugin entry-point Copy both JebJavascriptPlugin.jar and js.jar to your plugin folder. You can remove the classpath and classnames entries related to JavascriptPlugin and js.jar. Note : the best approach is to have one project per plugin. Exercice: Split the project and generate JavascriptPlugin.jar and HashJavascriptPlugin.jar. Remove all classpaths and classnames to check that it works.","title":"Building the Plugin"},{"location":"dev/6-releasing-plugin.html#generic-build-template","text":"The following Ant template can be customized for your own plugins needs: <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?> <!-- Sample Ant build file used to build and package a JEB plugin. - Requirements: set up the JEB_HOME environment variable to point to your JEB installation folder. - Customize the outfile, entryclass, extcp_build, and extcp_manifest properties. --> <project basedir=\".\" default=\"build\" name=\"jebplugin\"> <fail message=\"Set the plugin version number: ant -Dversion=x.y.z\"> <condition> <not> <isset property=\"version\"/> </not> </condition> </fail> <echo message=\"Plugin version: ${version}\"/> <property environment=\"env\"/> <echo message=\"JEB_HOME: ${env.JEB_HOME}\"/> <property name=\"jebjar\" value=\"${env.JEB_HOME}/bin/cl/jeb.jar\"/> <echo message=\"JEB Core expected at location: ${jebjar}\"/> <fail message=\"Please set JEB_HOME environment variable to point to your JEB installation folder\"> <condition> <not> <available file=\"${jebjar}\"/> </not> </condition> </fail> <property name=\"debuglevel\" value=\"source,lines,vars\"/> <property name=\"target\" value=\"1.7\"/> <property name=\"source\" value=\"1.7\"/> <!-- Mandatory properties --> <property name=\"outfile\" value=\"CUSTOMIZE\"/> <property name=\"entryclass\" value=\"CUSTOMIZE\"/> <!-- External libraries, for build process (semi-colon separated) --> <property name=\"extcp_build\" value=\"\"/> <!-- External libraries, for Manifest (space separated) --> <property name=\"extcp_manifest\" value=\"\"/> <target name=\"build\" depends=\"clean,compile,package\"/> <target name=\"audit\" depends=\"clean,compile-audit\"/> <target name=\"clean\"> <delete dir=\"bin\"/> <mkdir dir=\"bin\"/> </target> <target name=\"compile\"> <delete dir=\"bin\"/> <mkdir dir=\"bin\"/> <javac debug=\"true\" debuglevel=\"${debuglevel}\" destdir=\"bin\" includeantruntime=\"false\" source=\"${source}\" target=\"${target}\" encoding=\"UTF-8\"> <src path=\"src/main/java\"/> <classpath> <pathelement location=\"${jebjar}\"/> <pathelement path=\"${extcp_build}\"/> </classpath> </javac> </target> <target name=\"package\"> <delete file=\"${outfile}\"/> <jar destfile=\"${outfile}\"> <manifest> <attribute name=\"Class-Path\" value=\"${extcp_manifest}\"/> <attribute name=\"JebPlugin-entryclass\" value=\"${entryclass}\"/> <attribute name=\"JebPlugin-version\" value=\"${version}\"/> </manifest> <fileset dir=\"bin\"/> <!-- copy resources --> <fileset dir=\"src/main/java\" excludes=\"**/*.java\"/> <fileset dir=\".\" includes=\"README.md\"/> </jar> </target> </project> Next: Part 7","title":"Generic Build Template"},{"location":"dev/7-unit-interactivity.html","text":"JEB Plugin Development Tutorial part 7/8 Unit Interactivity \u00b6 The source code for part 7 of this sample plugin is located on GitHub: Clone this repo : git clone https://github.com/pnfsoftware/jeb2-plugindemo-js.git Switch to the tutorial7 branch: git checkout tutorial7 Syntax Highlighting \u00b6 Let's dive deeper and implement the first thing we want to get from an editor: syntax highlighting. This will allow us to uncover more corners of the JEB API. We will need to add item highlights on some parts of the text. Remember our sample, we will use only a single part: function a() { alert(\"a called\"); } A standard editor highlights keywords: they are specific words (reserved, most of the time) that are related to a language. In JavaScript, they are \"function\", \"var\", \"if\", \"else\"... Other interesting artifacts that could be highlighted are strings. In this tutorial, we will highlight functions, variables and strings surrounded by double-quotes. We want to modify only the display, not interact with the model (eg, renaming, formatting), so we will only look at ITextDocument . It has two important features: it builds ITextDocumentPart it has a coordinate to/from address conversion system. We will see this later. Let's concentrate on the ITextDocumentPart . The interface defines two methods: one returns a list of ILine objects: the part is split into lines. the other one returns a list of IAnchor objects. Anchors act the same as chapters for a book: an anchor indicates the beginning of a new section. If you don't need it, you can use a single anchor for the entire document. Remember that a part represents a part of the document (for buffered document) or can include the whole document. So the list of lines can be all the lines or just the lines of a part. We won't treat buffered document in this tutorial to keep things simple. Once again, let's check only the most important object, ILine . It contains: a CharSequence : the text line a List of ITextItem . As said in the API: A text item is used to identify a particular sequence of characters. This looks like what we were looking for. We will need to add ITextItem to our current model. The TextItem default implementation can be used. It takes as argument: the start offset of the keyword the length of the keyword an ItemClassIdentifiers identifier to apply a specific semantic and eventually, style, to your element. You can configure the display of these styles in the Edit, Fonts and Style... panel. Assignment 1 : Clone the sample code and checkout the tutorial7 branch. It already displays functions using a special ItemClassIdentifiers. Try to do the same for the var keyword and string constants. Notifications \u00b6 JEB is a security-oriented product: its aim is to help you analyze malicious code and pin-point potential areas of interest. Notifications can be used to show areas that are noteworthy; styles can be attached to notifications to highlight their corresponding elements on rendering. Notifications are global to a unit, they should be generated whe the processor plugin process() -es the input. For the sake of this tutorial, we want to highlight the usage of function \"alert\" because it can block the UI unreasonably. The AbstractUnit interface exposes the following method: public addtNotifications(IUnitNotification unit); We will use the default implementation: UnitNotification . In the process() method of your JavaScript plugin, add the following snippet: root.visit(new NodeVisitor() { @Override public boolean visit(AstNode node) { switch(node.getType()) { case Token.EXPR_VOID: case Token.EXPR_RESULT: break; case Token.CALL: visitTarget(((FunctionCall)node).getTarget()); break; default: break; } return true; } private void visitTarget(AstNode target) { if(target.getType() == Token.NAME) { if(((Name)target).getIdentifier().equals(\"alert\")) { // Add notification addNotification(new UnitNotification(NotificationType.POTENTIALLY_HARMFUL, String.format(\"alert is detected at position %d\", target.getAbsolutePosition()))); } } } }); The visit() method recursively process all the elements. When we have a JavaScript function call, we check the name and add a notification if the function is \"alert\". Now, you should see something new in the UI: If you want to see all notifications as soon as the file is opened in JEB, you will need to slightly modify your code. Since the process() method is only called on opening an IUnit, the best is to call it directly after IUnit creation: public IUnit prepare(String name, IInput input, IUnitProcessor unitProcessor, IUnitCreator parent) { IUnit sampleUnit = new SampleUnit(name, input, unitProcessor, parent, pdm); sampleUnit.process(); // forces children calculation return sampleUnit; } Always be careful to add this line somewhere in the process() method to indicate that the processing should not be done once again: setProcessed(true); Now, we see something interesting on the screenshot: there is an address column that is blank. IUnitNotification defines an address binding which can be used to jump to the related section. Let's see how to use it. Addressing \u00b6 To be able to jump to a correct Address , we need to define a binding from Unit addressing (address) to a position in a Document (coordinates). ITextDocument uses ICoordinates : it contains the anchor id, a line number relative to the anchor, and the position (column offset) in the line. Addresses, however, are user-defined (in this context, the user is the plugin developer): it is up to user to define them and their granularity. For instance, you can choose to support addresses: at function level/ element level. For example: \"function a\", \"function a / statement 1\" at byte level. For example, using absolute byte address in file: \"0x1A\", \"0x89\" at any other level. For example, at each line, each character for that line, etc. The important aspect of addresses is that an address must not be directly tied to a Document (your implementation of Document can change: if you add a beautifier, if you decide to format your document on a single line, if you use a tree/table for your representation, etc.). Of course, there should still be a way to make the link between the two addressing systems: Refer to the technical draft \"Positioning within inputs, units, and documents\" for additional details on addressing. At last, an address must identify an object/position in a unique way. Otherwise, you wouldn't know where to jump. For our sample JavaScript plugin, we will use the addressing using AstNode.getAbsolutePosition() . When jumping from Notification Panel, we have the current address (Absolute position), and we will jump to an ICoordinates in the ITextDocument. So the main method to implement is: public ICoordinates addressToCoordinates(String address); Assignment 2 : Try to implement this method. There is also another column in the Notification Panel called \"Label\": it represents the label of the address. You can indicate here a human readable label: for example, the name of the function. To display label, we need to inherit from IInteractiveUnit and implement String getAddressLabel(String address) to see changes in the Notification Panel. Assignment 3 (hard) : Try to implement the getAddressLabel() method. A solution to the assignments can be found by checking out the branch tutorial7_solution of the sample code . You may have noticed that IInteractiveUnit provides a lot of methods. We will focus on it in the next part! Next: Part 8","title":"Part 7: Interactivity"},{"location":"dev/7-unit-interactivity.html#unit-interactivity","text":"The source code for part 7 of this sample plugin is located on GitHub: Clone this repo : git clone https://github.com/pnfsoftware/jeb2-plugindemo-js.git Switch to the tutorial7 branch: git checkout tutorial7","title":"Unit Interactivity"},{"location":"dev/7-unit-interactivity.html#syntax-highlighting","text":"Let's dive deeper and implement the first thing we want to get from an editor: syntax highlighting. This will allow us to uncover more corners of the JEB API. We will need to add item highlights on some parts of the text. Remember our sample, we will use only a single part: function a() { alert(\"a called\"); } A standard editor highlights keywords: they are specific words (reserved, most of the time) that are related to a language. In JavaScript, they are \"function\", \"var\", \"if\", \"else\"... Other interesting artifacts that could be highlighted are strings. In this tutorial, we will highlight functions, variables and strings surrounded by double-quotes. We want to modify only the display, not interact with the model (eg, renaming, formatting), so we will only look at ITextDocument . It has two important features: it builds ITextDocumentPart it has a coordinate to/from address conversion system. We will see this later. Let's concentrate on the ITextDocumentPart . The interface defines two methods: one returns a list of ILine objects: the part is split into lines. the other one returns a list of IAnchor objects. Anchors act the same as chapters for a book: an anchor indicates the beginning of a new section. If you don't need it, you can use a single anchor for the entire document. Remember that a part represents a part of the document (for buffered document) or can include the whole document. So the list of lines can be all the lines or just the lines of a part. We won't treat buffered document in this tutorial to keep things simple. Once again, let's check only the most important object, ILine . It contains: a CharSequence : the text line a List of ITextItem . As said in the API: A text item is used to identify a particular sequence of characters. This looks like what we were looking for. We will need to add ITextItem to our current model. The TextItem default implementation can be used. It takes as argument: the start offset of the keyword the length of the keyword an ItemClassIdentifiers identifier to apply a specific semantic and eventually, style, to your element. You can configure the display of these styles in the Edit, Fonts and Style... panel. Assignment 1 : Clone the sample code and checkout the tutorial7 branch. It already displays functions using a special ItemClassIdentifiers. Try to do the same for the var keyword and string constants.","title":"Syntax Highlighting"},{"location":"dev/7-unit-interactivity.html#notifications","text":"JEB is a security-oriented product: its aim is to help you analyze malicious code and pin-point potential areas of interest. Notifications can be used to show areas that are noteworthy; styles can be attached to notifications to highlight their corresponding elements on rendering. Notifications are global to a unit, they should be generated whe the processor plugin process() -es the input. For the sake of this tutorial, we want to highlight the usage of function \"alert\" because it can block the UI unreasonably. The AbstractUnit interface exposes the following method: public addtNotifications(IUnitNotification unit); We will use the default implementation: UnitNotification . In the process() method of your JavaScript plugin, add the following snippet: root.visit(new NodeVisitor() { @Override public boolean visit(AstNode node) { switch(node.getType()) { case Token.EXPR_VOID: case Token.EXPR_RESULT: break; case Token.CALL: visitTarget(((FunctionCall)node).getTarget()); break; default: break; } return true; } private void visitTarget(AstNode target) { if(target.getType() == Token.NAME) { if(((Name)target).getIdentifier().equals(\"alert\")) { // Add notification addNotification(new UnitNotification(NotificationType.POTENTIALLY_HARMFUL, String.format(\"alert is detected at position %d\", target.getAbsolutePosition()))); } } } }); The visit() method recursively process all the elements. When we have a JavaScript function call, we check the name and add a notification if the function is \"alert\". Now, you should see something new in the UI: If you want to see all notifications as soon as the file is opened in JEB, you will need to slightly modify your code. Since the process() method is only called on opening an IUnit, the best is to call it directly after IUnit creation: public IUnit prepare(String name, IInput input, IUnitProcessor unitProcessor, IUnitCreator parent) { IUnit sampleUnit = new SampleUnit(name, input, unitProcessor, parent, pdm); sampleUnit.process(); // forces children calculation return sampleUnit; } Always be careful to add this line somewhere in the process() method to indicate that the processing should not be done once again: setProcessed(true); Now, we see something interesting on the screenshot: there is an address column that is blank. IUnitNotification defines an address binding which can be used to jump to the related section. Let's see how to use it.","title":"Notifications"},{"location":"dev/7-unit-interactivity.html#addressing","text":"To be able to jump to a correct Address , we need to define a binding from Unit addressing (address) to a position in a Document (coordinates). ITextDocument uses ICoordinates : it contains the anchor id, a line number relative to the anchor, and the position (column offset) in the line. Addresses, however, are user-defined (in this context, the user is the plugin developer): it is up to user to define them and their granularity. For instance, you can choose to support addresses: at function level/ element level. For example: \"function a\", \"function a / statement 1\" at byte level. For example, using absolute byte address in file: \"0x1A\", \"0x89\" at any other level. For example, at each line, each character for that line, etc. The important aspect of addresses is that an address must not be directly tied to a Document (your implementation of Document can change: if you add a beautifier, if you decide to format your document on a single line, if you use a tree/table for your representation, etc.). Of course, there should still be a way to make the link between the two addressing systems: Refer to the technical draft \"Positioning within inputs, units, and documents\" for additional details on addressing. At last, an address must identify an object/position in a unique way. Otherwise, you wouldn't know where to jump. For our sample JavaScript plugin, we will use the addressing using AstNode.getAbsolutePosition() . When jumping from Notification Panel, we have the current address (Absolute position), and we will jump to an ICoordinates in the ITextDocument. So the main method to implement is: public ICoordinates addressToCoordinates(String address); Assignment 2 : Try to implement this method. There is also another column in the Notification Panel called \"Label\": it represents the label of the address. You can indicate here a human readable label: for example, the name of the function. To display label, we need to inherit from IInteractiveUnit and implement String getAddressLabel(String address) to see changes in the Notification Panel. Assignment 3 (hard) : Try to implement the getAddressLabel() method. A solution to the assignments can be found by checking out the branch tutorial7_solution of the sample code . You may have noticed that IInteractiveUnit provides a lot of methods. We will focus on it in the next part! Next: Part 8","title":"Addressing"},{"location":"dev/8-more-interactivity.html","text":"JEB Plugin Development Tutorial part 8/8 More on Interactivity \u00b6 The source code for part 8 of this sample plugin is located on GitHub: Clone this repo : git clone https://github.com/pnfsoftware/jeb2-plugindemo-js.git Switch to the tutorial8 branch: git checkout tutorial8 User Actions \u00b6 CanExecute \u00b6 JEB provides the ability to interact with the units. Those units are called interactive units . The simplest way to interact with units is through well-known actions . The actions have to be implemented by the plugin developer. An action has an ActionContext as a parameter, which allows the plugin to retrieve: the action id: one defined in the Actions class. It indicates which action is involved (Comment, Rename...) the address: the current position in the document the item id: we will discuss it later. First, why are all these actions grayed out? Because canExecuteAction() does not return true - yet. public boolean canExecuteAction(ActionContext actionContext) { logger.info(\"%s called with address %s and actionId %d\", \"canExecuteAction\", actionContext.getAddress(), actionContext.getActionId()); return false; } As you can see in the logs, this method is called each time you move the caret in the document. What if we try to return true instead of false? As expected, all actions become clickable. Note that you can also use the toolbar icons or, even better, the keyboard shortcuts. Nothing happens when you click on any action: it is up to the plugin developer to implement the desired feature. We will implement a simple action: renaming of a String . (Note: we could as well rename functions, methods, variables... but we need to check in the model where they are used to replace all occurrences, consistently. The added complexity is out-of-scope in this API introduction tutorial.) First, we need to activate the rename feature when we are on a String: Assignment 1 : Save the string references and test if the caret in on a String. PrepareExecution \u00b6 When clicking on the \"Rename\" action button, the method IInteractiveUnit.prepareExecution() is called. Its goal is to prepare the execution of the code and, in the case of renaming, it also provides the initial value that we want to edit: it is called before displaying the following pop up: You need to return true in the prepareExecution method to indicate that the processing should continue. The prepareExecution method has one more parameter of type IActionData . To fill up the name field, we need to retrieve the correct Action Data type: Use ActionRenameData to prefill the rename field with its current value. public boolean prepareExecution(ActionContext actionContext, IActionData actionData) { if(actionContext.getActionId() == Actions.RENAME) { StringLiteral string = getElementAt(actionContext.getAddress(), strings); if(string != null) { ((ActionRenameData)actionData).setCurrentName(string.getValue()); return true; } } return false; } Note that IActionData embeds a generic map to pass discretionary objects from prepareExecution to executeAction method. ExecuteAction \u00b6 The executeAction method is the last step: it performs the action and modifies the model. What should we modify now? IInput : this is a pointer to original file, it makes no sense. AstRoot : this is our kind-of model, but there is no way to retrieve the input data (the toString() method has a specific implementation and the toSource() auto-formats and remove comments. IUnit is the central part of your plugin: it is responsible for updating the model and keep coherence regarding all its document. But there is something wrong with the initial design: we don't save a reference Document in the Unit. Documents shall at least work with the same object as IUnit, and at least have a reference on their IUnit in order to retrieve the data (this is a good practice in JEB). Therefore, we will now modify our unit to keep references of all lines (using a List ). One problem that will remain is the mandatory conversion at the ITextDocumentPart level: public List<? extends ILine> getLines The getLines method is called each time you scroll/move around the document, so it would be too costly to recalculate the list of ILines each time it is called. It must be buffered and refreshed on changes: the unit must notify its Documents when the model changes. To make notifications work, you must: Register the notified element: public class JavascriptDocument extends EventSource implements ITextDocument, IEventListener { public JavascriptDocument(JavascriptUnit unit) { this.unit = unit; unit.addListener(this); refreshPart(); } // ... public void onEvent(IEvent e) { if(e.getType() == J.UnitChange) { refreshPart(); this.notifyListeners(e); } } } Call the notify method in the executeAction method (on success): notifyListeners(new JebEvent(J.UnitChange)); Refer to the technical draft \"Staying informed of unit changes\" for more details about unit changes tracking within documents. Assignment 2 : Finish the renaming implementation. Navigation \u00b6 JEB natively manages navigation feature with four predefined actions selectable from menu or directly with shortcuts: Jump To : move caret to a specific address. It uses the ITextDocument.addressToCoordinates() that we already implemented for Notifications. Navigate Forward / Navigate Backward : move caret to the previous/next position (caret position history is saved each time you jump) Follow : jump to an address bound to the current element. The best example is on a function call: you can jump to its definition Assignment 3 : Implement Jump To for function names Now, let's look at Follow. We can see that it is active only when we set the caret on strings, var, function... this is because the Follow feature is bound to Items, more precisely, the IActionableItem . When clicking on Follow , if the caret is positioned on an Item, the function IInteractiveUnit.getAddressOfItem() is called. Assignment 4 : Implement Follow for function name (it should work on the latest b();) A solution to the assignments can be found by checking out the branch tutorial8 of the sample code . Back to Part 1","title":"Part 8: More on Interactivity"},{"location":"dev/8-more-interactivity.html#more-on-interactivity","text":"The source code for part 8 of this sample plugin is located on GitHub: Clone this repo : git clone https://github.com/pnfsoftware/jeb2-plugindemo-js.git Switch to the tutorial8 branch: git checkout tutorial8","title":"More on Interactivity"},{"location":"dev/8-more-interactivity.html#user-actions","text":"","title":"User Actions"},{"location":"dev/8-more-interactivity.html#canexecute","text":"JEB provides the ability to interact with the units. Those units are called interactive units . The simplest way to interact with units is through well-known actions . The actions have to be implemented by the plugin developer. An action has an ActionContext as a parameter, which allows the plugin to retrieve: the action id: one defined in the Actions class. It indicates which action is involved (Comment, Rename...) the address: the current position in the document the item id: we will discuss it later. First, why are all these actions grayed out? Because canExecuteAction() does not return true - yet. public boolean canExecuteAction(ActionContext actionContext) { logger.info(\"%s called with address %s and actionId %d\", \"canExecuteAction\", actionContext.getAddress(), actionContext.getActionId()); return false; } As you can see in the logs, this method is called each time you move the caret in the document. What if we try to return true instead of false? As expected, all actions become clickable. Note that you can also use the toolbar icons or, even better, the keyboard shortcuts. Nothing happens when you click on any action: it is up to the plugin developer to implement the desired feature. We will implement a simple action: renaming of a String . (Note: we could as well rename functions, methods, variables... but we need to check in the model where they are used to replace all occurrences, consistently. The added complexity is out-of-scope in this API introduction tutorial.) First, we need to activate the rename feature when we are on a String: Assignment 1 : Save the string references and test if the caret in on a String.","title":"CanExecute"},{"location":"dev/8-more-interactivity.html#prepareexecution","text":"When clicking on the \"Rename\" action button, the method IInteractiveUnit.prepareExecution() is called. Its goal is to prepare the execution of the code and, in the case of renaming, it also provides the initial value that we want to edit: it is called before displaying the following pop up: You need to return true in the prepareExecution method to indicate that the processing should continue. The prepareExecution method has one more parameter of type IActionData . To fill up the name field, we need to retrieve the correct Action Data type: Use ActionRenameData to prefill the rename field with its current value. public boolean prepareExecution(ActionContext actionContext, IActionData actionData) { if(actionContext.getActionId() == Actions.RENAME) { StringLiteral string = getElementAt(actionContext.getAddress(), strings); if(string != null) { ((ActionRenameData)actionData).setCurrentName(string.getValue()); return true; } } return false; } Note that IActionData embeds a generic map to pass discretionary objects from prepareExecution to executeAction method.","title":"PrepareExecution"},{"location":"dev/8-more-interactivity.html#executeaction","text":"The executeAction method is the last step: it performs the action and modifies the model. What should we modify now? IInput : this is a pointer to original file, it makes no sense. AstRoot : this is our kind-of model, but there is no way to retrieve the input data (the toString() method has a specific implementation and the toSource() auto-formats and remove comments. IUnit is the central part of your plugin: it is responsible for updating the model and keep coherence regarding all its document. But there is something wrong with the initial design: we don't save a reference Document in the Unit. Documents shall at least work with the same object as IUnit, and at least have a reference on their IUnit in order to retrieve the data (this is a good practice in JEB). Therefore, we will now modify our unit to keep references of all lines (using a List ). One problem that will remain is the mandatory conversion at the ITextDocumentPart level: public List<? extends ILine> getLines The getLines method is called each time you scroll/move around the document, so it would be too costly to recalculate the list of ILines each time it is called. It must be buffered and refreshed on changes: the unit must notify its Documents when the model changes. To make notifications work, you must: Register the notified element: public class JavascriptDocument extends EventSource implements ITextDocument, IEventListener { public JavascriptDocument(JavascriptUnit unit) { this.unit = unit; unit.addListener(this); refreshPart(); } // ... public void onEvent(IEvent e) { if(e.getType() == J.UnitChange) { refreshPart(); this.notifyListeners(e); } } } Call the notify method in the executeAction method (on success): notifyListeners(new JebEvent(J.UnitChange)); Refer to the technical draft \"Staying informed of unit changes\" for more details about unit changes tracking within documents. Assignment 2 : Finish the renaming implementation.","title":"ExecuteAction"},{"location":"dev/8-more-interactivity.html#navigation","text":"JEB natively manages navigation feature with four predefined actions selectable from menu or directly with shortcuts: Jump To : move caret to a specific address. It uses the ITextDocument.addressToCoordinates() that we already implemented for Notifications. Navigate Forward / Navigate Backward : move caret to the previous/next position (caret position history is saved each time you jump) Follow : jump to an address bound to the current element. The best example is on a function call: you can jump to its definition Assignment 3 : Implement Jump To for function names Now, let's look at Follow. We can see that it is active only when we set the caret on strings, var, function... this is because the Follow feature is bound to Items, more precisely, the IActionableItem . When clicking on Follow , if the caret is positioned on an Item, the function IInteractiveUnit.getAddressOfItem() is called. Assignment 4 : Implement Follow for function name (it should work on the latest b();) A solution to the assignments can be found by checking out the branch tutorial8 of the sample code . Back to Part 1","title":"Navigation"},{"location":"dev/introducing-jeb-extensions.html","text":"Introducing JEB Extensions \u00b6 JEB offers a rich API that can be used to develop: Front-end clients , such as: The official UI client Headless clients for automation pipelines Plugins (aka back-end modules ): Processor plugins such as disassemblers, decompilers, debuggers, or any other type of analyzer Many processor plugins fall in the category of parsers and are sometimes referred as such Engines plugins such as second-pass code analyzers, working on results produced by other plugins, or helpers Scripts : Python scripts for automating simple tasks Python scripts that can interact with graphical clients that implement the UI-API (the UI client does) Note: the Developing with JEB area of this guide is superseding our Developer Portal . This is a work-in-progress as old pages are being ported over, and new contents is being added. Capabilities \u00b6 Only professional licenses offer full API access. However, all licenses allow script execution from within the UI client: Licenses Type UI client Other Clients (incl. command-line) Non-Pro UI scripts no Pro UI scripts + plugins scripts + plugins High-level Architecture \u00b6 Grasping the high-level concepts of how pieces fit together within JEB will make you a more efficient extensions developer. At the highest-level, JEB is separated into back-end and front-end components: The back-end components are responsible for processing input artifacts. They provide an execution environment for native and third-party plugins, including input artifact processor plugins, such as file parsers. The front-end components are responsible for processing input commands and rendering back-end results. A variety of front-ends may be created using the API exposed by the back-end. Note: As said earlier, all JEB distributions ship with the UI client front-end that runs on all major desktop operating systems. The diagram below shows the relationship between back-end and front-end components: Depending on their license type, users may be able to develop third-party plugins and instruct the back-end to load them. This enables power users to craft input processors that cater to their specific needs (eg, a disassembler for an exotic or virtual CPU). You may verify your API usage capabilities by starting JEB with the -c --license command line flag. API \u00b6 The JEB Application Programming Interface offers power-users ways to: write clients such as command-line processors (headless) write extensions, from simple scripts in Python to advanced analysis modules in Java The JEB API reference documentation is available online as well as offline, within your JEB software package (file doc/apidoc.zip ). A exhaustive discussion of the API components is outside the scope of this guide. Scripts vs Plugins \u00b6 Scripts... Implement IScript Are called by users to achieve small tasks Example: modify some code, navigate somewhere, display some info, etc. Have to to be written in Python (and are run within a Jython VM) Ideal for rapid development and prototyping Are executed by JEB on-demand In UI client, can be executed via the File menu Plugins... Implement IPlugin ( IUnitIdentifier for processor plugins, IEnginesPlugin for engines plugins) Are designed to process input (for processor plugins) or do other tasks (for engines plugins) Example: disassemble or decompile code, do complex file parsing, etc. Must be written in Java Ideal for complex, large code bases Are loaded by JEB at start-up time List of loaded plugins can be seen in the File menu Future : we may allow plugins to be written in Python soon, stay tuned! Executing Scripts \u00b6 Note : All versions of JEB can execute client scripts inside the UI client. Scripts should be dropped in your scripts/ directory (or any other directory specified in your .ScriptsFolder client option ). Use the File, Script, Run Script... menu command to execute a script. The last run script can be executed again by pressing the F2 key. Client scripts are written in Python, and are executed within a Jython (a Java implementation of the Python VM) You will need to drop a copy of the Jython JAR runtime in your JEB scripts/ in order to execute scripts Scripts, like any extension, use the JEB API. Visit the reference documentation for details. Client scripts executed inside the UI client also have access to the UI-API (package com.pnfsoftware.jeb.client.ui ). Classes of the UI-API allow graphical manipulation of views, fragments, items, etc. (This sub-API is accessible only to clients that implement it; the UI client does.) You will find a large collection of sample scripts on our public Github repository . Executing Engines Plugins \u00b6 All third-party plugins must be dropped in your coreplugins/ directory (or any other directory specified in your .PluginsFolder back-end option ). Use the File, Engines, Execute, ... menu command to execute an engines plugin . Note : technically speaking, engines plugins are JEB plugins that implement the IEnginesPlugin interface. The full list of engines plugins loaded within your JEB instance context can be seen by running the File, Engines, Plugins command. (You may double-click a plugin to execute it.) A collection of open-source plugins can be found on our public Github repository .","title":"Introducing JEB Extensions"},{"location":"dev/introducing-jeb-extensions.html#introducing-jeb-extensions","text":"JEB offers a rich API that can be used to develop: Front-end clients , such as: The official UI client Headless clients for automation pipelines Plugins (aka back-end modules ): Processor plugins such as disassemblers, decompilers, debuggers, or any other type of analyzer Many processor plugins fall in the category of parsers and are sometimes referred as such Engines plugins such as second-pass code analyzers, working on results produced by other plugins, or helpers Scripts : Python scripts for automating simple tasks Python scripts that can interact with graphical clients that implement the UI-API (the UI client does) Note: the Developing with JEB area of this guide is superseding our Developer Portal . This is a work-in-progress as old pages are being ported over, and new contents is being added.","title":"Introducing JEB Extensions"},{"location":"dev/introducing-jeb-extensions.html#capabilities","text":"Only professional licenses offer full API access. However, all licenses allow script execution from within the UI client: Licenses Type UI client Other Clients (incl. command-line) Non-Pro UI scripts no Pro UI scripts + plugins scripts + plugins","title":"Capabilities"},{"location":"dev/introducing-jeb-extensions.html#high-level-architecture","text":"Grasping the high-level concepts of how pieces fit together within JEB will make you a more efficient extensions developer. At the highest-level, JEB is separated into back-end and front-end components: The back-end components are responsible for processing input artifacts. They provide an execution environment for native and third-party plugins, including input artifact processor plugins, such as file parsers. The front-end components are responsible for processing input commands and rendering back-end results. A variety of front-ends may be created using the API exposed by the back-end. Note: As said earlier, all JEB distributions ship with the UI client front-end that runs on all major desktop operating systems. The diagram below shows the relationship between back-end and front-end components: Depending on their license type, users may be able to develop third-party plugins and instruct the back-end to load them. This enables power users to craft input processors that cater to their specific needs (eg, a disassembler for an exotic or virtual CPU). You may verify your API usage capabilities by starting JEB with the -c --license command line flag.","title":"High-level Architecture"},{"location":"dev/introducing-jeb-extensions.html#api","text":"The JEB Application Programming Interface offers power-users ways to: write clients such as command-line processors (headless) write extensions, from simple scripts in Python to advanced analysis modules in Java The JEB API reference documentation is available online as well as offline, within your JEB software package (file doc/apidoc.zip ). A exhaustive discussion of the API components is outside the scope of this guide.","title":"API"},{"location":"dev/introducing-jeb-extensions.html#scripts-vs-plugins","text":"Scripts... Implement IScript Are called by users to achieve small tasks Example: modify some code, navigate somewhere, display some info, etc. Have to to be written in Python (and are run within a Jython VM) Ideal for rapid development and prototyping Are executed by JEB on-demand In UI client, can be executed via the File menu Plugins... Implement IPlugin ( IUnitIdentifier for processor plugins, IEnginesPlugin for engines plugins) Are designed to process input (for processor plugins) or do other tasks (for engines plugins) Example: disassemble or decompile code, do complex file parsing, etc. Must be written in Java Ideal for complex, large code bases Are loaded by JEB at start-up time List of loaded plugins can be seen in the File menu Future : we may allow plugins to be written in Python soon, stay tuned!","title":"Scripts vs Plugins"},{"location":"dev/introducing-jeb-extensions.html#executing-scripts","text":"Note : All versions of JEB can execute client scripts inside the UI client. Scripts should be dropped in your scripts/ directory (or any other directory specified in your .ScriptsFolder client option ). Use the File, Script, Run Script... menu command to execute a script. The last run script can be executed again by pressing the F2 key. Client scripts are written in Python, and are executed within a Jython (a Java implementation of the Python VM) You will need to drop a copy of the Jython JAR runtime in your JEB scripts/ in order to execute scripts Scripts, like any extension, use the JEB API. Visit the reference documentation for details. Client scripts executed inside the UI client also have access to the UI-API (package com.pnfsoftware.jeb.client.ui ). Classes of the UI-API allow graphical manipulation of views, fragments, items, etc. (This sub-API is accessible only to clients that implement it; the UI client does.) You will find a large collection of sample scripts on our public Github repository .","title":"Executing Scripts"},{"location":"dev/introducing-jeb-extensions.html#executing-engines-plugins","text":"All third-party plugins must be dropped in your coreplugins/ directory (or any other directory specified in your .PluginsFolder back-end option ). Use the File, Engines, Execute, ... menu command to execute an engines plugin . Note : technically speaking, engines plugins are JEB plugins that implement the IEnginesPlugin interface. The full list of engines plugins loaded within your JEB instance context can be seen by running the File, Engines, Plugins command. (You may double-click a plugin to execute it.) A collection of open-source plugins can be found on our public Github repository .","title":"Executing Engines Plugins"},{"location":"dev/other-resources.html","text":"Additional Resources \u00b6 Technical drafts for developers: (available on Google Drive) Parser Delegation MVC and Unit Documents Positioning within Units Units Hierarchy","title":"Additional Resources"},{"location":"dev/other-resources.html#additional-resources","text":"Technical drafts for developers: (available on Google Drive) Parser Delegation MVC and Unit Documents Positioning within Units Units Hierarchy","title":"Additional Resources"},{"location":"dev/writing-client-scripts.html","text":"Writing Client Scripts \u00b6 All JEB builds permit running scripts : Scripts are meant to execute small, light-weight actions They can be written using the Python 2.5 or 2.7 syntax and features, and are executed by a Jython VM Prerequisite \u00b6 A Jython stand-alone package is required to run scripts. Jython ships by default with JEB 3.1 builds. Legacy : If you are using JEB2, download either Jython 2.7 (newer, slower to load) or Jython 2.5 (older and slimmer, faster to load) and drop it in your JEB scripts/ sub-directory. Features \u00b6 Scripts can: use the standard JEB API use the Client API package if run within a client that implements the UI-API, use the JEB UI Client API A client script implements the IScript interface. Upon execution, the script run() entry-point method is provided an IClientContext or derived object, such as an IGraphicalClientContext for UI clients, such as the official UI desktop client. A Simple Script \u00b6 Here is the simplest of all scripts: from com.pnfsoftware.jeb.client.api import IScript class JEBSampleScript(IScript): def run(self, ctx): print('Hello, JEB version %s' % ctx.getSoftwareVersion()) print('- Arguments: %s' % ctx.getArguments()) print('- Base directory: %s' % ctx.getBaseDirectory()) Within the official desktop client, scripts can be executed via the File, Scripts menu item. Remember that heavy-lifting operations (such as parsing or background event-driven tasks) should be implemented by back-end plugins in Java. More scripts \u00b6 Check out our GitHub repository for more sample scripts .","title":"Writing Client Scripts"},{"location":"dev/writing-client-scripts.html#writing-client-scripts","text":"All JEB builds permit running scripts : Scripts are meant to execute small, light-weight actions They can be written using the Python 2.5 or 2.7 syntax and features, and are executed by a Jython VM","title":"Writing Client Scripts"},{"location":"dev/writing-client-scripts.html#prerequisite","text":"A Jython stand-alone package is required to run scripts. Jython ships by default with JEB 3.1 builds. Legacy : If you are using JEB2, download either Jython 2.7 (newer, slower to load) or Jython 2.5 (older and slimmer, faster to load) and drop it in your JEB scripts/ sub-directory.","title":"Prerequisite"},{"location":"dev/writing-client-scripts.html#features","text":"Scripts can: use the standard JEB API use the Client API package if run within a client that implements the UI-API, use the JEB UI Client API A client script implements the IScript interface. Upon execution, the script run() entry-point method is provided an IClientContext or derived object, such as an IGraphicalClientContext for UI clients, such as the official UI desktop client.","title":"Features"},{"location":"dev/writing-client-scripts.html#a-simple-script","text":"Here is the simplest of all scripts: from com.pnfsoftware.jeb.client.api import IScript class JEBSampleScript(IScript): def run(self, ctx): print('Hello, JEB version %s' % ctx.getSoftwareVersion()) print('- Arguments: %s' % ctx.getArguments()) print('- Base directory: %s' % ctx.getBaseDirectory()) Within the official desktop client, scripts can be executed via the File, Scripts menu item. Remember that heavy-lifting operations (such as parsing or background event-driven tasks) should be implemented by back-end plugins in Java.","title":"A Simple Script"},{"location":"dev/writing-client-scripts.html#more-scripts","text":"Check out our GitHub repository for more sample scripts .","title":"More scripts"},{"location":"dev/writing-engines-plugins.html","text":"Writing Engines Plugins \u00b6 Engines plugins, just like any JEB extension (parser, script, etc.) use the JEB API. They are loaded when JEB starts. Unlike parsers, their role is not to process input data to produce units; they are meant to perform pointed tasks. They can be called on-demand by clients. From a programmer's standpoint, engines plugins extend the IEnginesPlugin (whereas processor plugins extend the IUnitIdentifier interface). Sample Plugins \u00b6 Sample plugins can be found on our GitHub account. Examples: Andhook : Android Cryptographic Primitives Hooking using the JEB Debuggers API ... Skeleton Plugin \u00b6 Full source code: Sample plugin skeleton on GitHub public class SampleEnginesPlugin implements IEnginesPlugin { private static final ILogger logger = GlobalLog.getLogger(SampleEnginesPlugin.class); @Override public IPluginInformation getPluginInformation() { return new PluginInformation(\"Sample Plugin\", \"A sample JEB plugin\", \"PNF Software\", Version.create(1, 0)); } @Override public List<? extends IOptionDefinition> getExecutionOptionDefinitions() { return null; } @Override public void execute(IEnginesContext context) { execute(context, null); } @Override public void execute(IEnginesContext engctx, Map<String, String> executionOptions) { logger.info(\"Executing sample plugin\"); } @Override public void dispose() { } }","title":"Writing Engines Plugins"},{"location":"dev/writing-engines-plugins.html#writing-engines-plugins","text":"Engines plugins, just like any JEB extension (parser, script, etc.) use the JEB API. They are loaded when JEB starts. Unlike parsers, their role is not to process input data to produce units; they are meant to perform pointed tasks. They can be called on-demand by clients. From a programmer's standpoint, engines plugins extend the IEnginesPlugin (whereas processor plugins extend the IUnitIdentifier interface).","title":"Writing Engines Plugins"},{"location":"dev/writing-engines-plugins.html#sample-plugins","text":"Sample plugins can be found on our GitHub account. Examples: Andhook : Android Cryptographic Primitives Hooking using the JEB Debuggers API ...","title":"Sample Plugins"},{"location":"dev/writing-engines-plugins.html#skeleton-plugin","text":"Full source code: Sample plugin skeleton on GitHub public class SampleEnginesPlugin implements IEnginesPlugin { private static final ILogger logger = GlobalLog.getLogger(SampleEnginesPlugin.class); @Override public IPluginInformation getPluginInformation() { return new PluginInformation(\"Sample Plugin\", \"A sample JEB plugin\", \"PNF Software\", Version.create(1, 0)); } @Override public List<? extends IOptionDefinition> getExecutionOptionDefinitions() { return null; } @Override public void execute(IEnginesContext context) { execute(context, null); } @Override public void execute(IEnginesContext engctx, Map<String, String> executionOptions) { logger.info(\"Executing sample plugin\"); } @Override public void dispose() { } }","title":"Skeleton Plugin"},{"location":"dev/writing-front-ends.html","text":"Writing Front-Ends \u00b6 JEB front-end are also referred to as \"JEB clients\" (or \"JEB third-party clients\", to contrast with the \"official UI desktop client\"). JEB back-end API makes writing new clients (aka, front-ends) an easy task. A client can be: An automated client (for testing, for an automation pipeline) A command-line client A graphical front-end (eg, the official UI desktop client) ... Note: Not all JEB licenses allow the creation of third-party clients. Verify this by checking your license information in the About dialog box. It should show any-client . Typically, JEB Pro licenses allow the execution of third-party clients. High-level Instructions \u00b6 Use the provided source code template (see below) as a base for your client. The basic steps any client should take are the following: Use JebCoreService to retrieve an instance to ICoreContext Create an IEnginesContext Load a project within that context ( IRuntimeProject ) Add artifacts and process them ( ILiveArtifact ) Retrieve the products ( IUnit ) Proceed as usual with the units We recommend developers to read our tutorial series on parser development to get familiar with units Refer to the our simplified architecture diagrams to better visualize how those components are connected to one another. Source Template \u00b6 Full source code: Command-line client skeleton on GitHub public class AutoClient { static final ILogger logger = GlobalLog.getLogger(AutoClient.class); static { GlobalLog.addDestinationStream(System.out); } // TODO: customize (should be replaced by the LicenseKey entry in your bin/jeb-client.cfg file) private static final String licenseKey = \"...\"; // TODO: customize private static final String baseDir = \"...\"; public static void main(String[] argv) throws Exception { if(argv.length <= 0) { return; } long t0 = System.currentTimeMillis(); String location = argv[0]; List<File> files = AutoUtil.retrieveFiles(location); test(files); logger.info(\"Done in %ds\", (System.currentTimeMillis() - t0) / 1000); } /** * Initialize a core. Create a context within that core. Then, for each input artifact, a * project is created and the artifact is loaded within that project. */ public static void test(List<File> files) throws Exception { // create or retrieve a core context (engines container) ICoreContext core = JebCoreService.getInstance(licenseKey); // create an engines context (project container) IFileDatabase projectdb = new JEB2FileDatabase(baseDir); IFileStore filestore = new SimpleFSFileStore(baseDir); BaseConfiguration cfg = new BaseConfiguration(); // TODO: customize (alternative is to read your configuration from .cfg file) cfg.setProperty(\".DevPluginClasspath\", \"...\"); // TODO: customize cfg.setProperty(\".DevPluginClassnames\", \"...\"); IConfiguration config = new CommonsConfigurationWrapper(cfg); IDataProvider dataProvider = new DataProvider(null, projectdb, filestore, null, null, config); IEnginesContext engctx = core.createEnginesContext(dataProvider, null); int i = 0; for(File file: files) { i++; logger.info(\"Testing file %d/%d : %s ...\", i, files.size(), file.getName()); // create or load a project (artifact container) IRuntimeProject prj = engctx.loadProject(\"ProjectTest\" + i); // process the artifact, get units ILiveArtifact art = prj.processArtifact(new Artifact(file.getName(), new FileInput(file))); // proceed with the units List<IUnit> units = art.getUnits(); // TODO: CUSTOMIZE -- this is the important part // Basic tests go here // example: for(IUnit unit: units) { logger.info(\"Unit: %s\", unit); //if(unit instanceof Xyz) { // ... //} } engctx.unloadProject(prj.getKey()); } // close the engines JebCoreService.getInstance().closeEnginesContext(engctx); } }","title":"Writing Front-Ends"},{"location":"dev/writing-front-ends.html#writing-front-ends","text":"JEB front-end are also referred to as \"JEB clients\" (or \"JEB third-party clients\", to contrast with the \"official UI desktop client\"). JEB back-end API makes writing new clients (aka, front-ends) an easy task. A client can be: An automated client (for testing, for an automation pipeline) A command-line client A graphical front-end (eg, the official UI desktop client) ... Note: Not all JEB licenses allow the creation of third-party clients. Verify this by checking your license information in the About dialog box. It should show any-client . Typically, JEB Pro licenses allow the execution of third-party clients.","title":"Writing Front-Ends"},{"location":"dev/writing-front-ends.html#high-level-instructions","text":"Use the provided source code template (see below) as a base for your client. The basic steps any client should take are the following: Use JebCoreService to retrieve an instance to ICoreContext Create an IEnginesContext Load a project within that context ( IRuntimeProject ) Add artifacts and process them ( ILiveArtifact ) Retrieve the products ( IUnit ) Proceed as usual with the units We recommend developers to read our tutorial series on parser development to get familiar with units Refer to the our simplified architecture diagrams to better visualize how those components are connected to one another.","title":"High-level Instructions"},{"location":"dev/writing-front-ends.html#source-template","text":"Full source code: Command-line client skeleton on GitHub public class AutoClient { static final ILogger logger = GlobalLog.getLogger(AutoClient.class); static { GlobalLog.addDestinationStream(System.out); } // TODO: customize (should be replaced by the LicenseKey entry in your bin/jeb-client.cfg file) private static final String licenseKey = \"...\"; // TODO: customize private static final String baseDir = \"...\"; public static void main(String[] argv) throws Exception { if(argv.length <= 0) { return; } long t0 = System.currentTimeMillis(); String location = argv[0]; List<File> files = AutoUtil.retrieveFiles(location); test(files); logger.info(\"Done in %ds\", (System.currentTimeMillis() - t0) / 1000); } /** * Initialize a core. Create a context within that core. Then, for each input artifact, a * project is created and the artifact is loaded within that project. */ public static void test(List<File> files) throws Exception { // create or retrieve a core context (engines container) ICoreContext core = JebCoreService.getInstance(licenseKey); // create an engines context (project container) IFileDatabase projectdb = new JEB2FileDatabase(baseDir); IFileStore filestore = new SimpleFSFileStore(baseDir); BaseConfiguration cfg = new BaseConfiguration(); // TODO: customize (alternative is to read your configuration from .cfg file) cfg.setProperty(\".DevPluginClasspath\", \"...\"); // TODO: customize cfg.setProperty(\".DevPluginClassnames\", \"...\"); IConfiguration config = new CommonsConfigurationWrapper(cfg); IDataProvider dataProvider = new DataProvider(null, projectdb, filestore, null, null, config); IEnginesContext engctx = core.createEnginesContext(dataProvider, null); int i = 0; for(File file: files) { i++; logger.info(\"Testing file %d/%d : %s ...\", i, files.size(), file.getName()); // create or load a project (artifact container) IRuntimeProject prj = engctx.loadProject(\"ProjectTest\" + i); // process the artifact, get units ILiveArtifact art = prj.processArtifact(new Artifact(file.getName(), new FileInput(file))); // proceed with the units List<IUnit> units = art.getUnits(); // TODO: CUSTOMIZE -- this is the important part // Basic tests go here // example: for(IUnit unit: units) { logger.info(\"Unit: %s\", unit); //if(unit instanceof Xyz) { // ... //} } engctx.unloadProject(prj.getKey()); } // close the engines JebCoreService.getInstance().closeEnginesContext(engctx); } }","title":"Source Template"}]}